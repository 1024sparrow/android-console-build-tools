<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
        <meta http-equiv="Content-Type" content="text/html;charset=utf-8">
        <title>Othello for Desktop, Mobile and Web: an AI and GUI Exercise</title>
        <link rel="stylesheet" type="text/css" href="style.css">
        <link rel="stylesheet" type="text/css" href="code-style.css">
        <link rel="alternate" type="application/rss+xml" href="feed.rss">
        <meta name="viewport" content="width=device-width, initial-scale=1">

<style type="text/css">
.othello {
  text-align: center;
  vertical-align: middle;
  color-adjust: exact;
  -webkit-print-color-adjust: exact;
}
.othello td {
  background: #008000;
  width: 30px;
  height: 30px;
  margin: 1px;
  padding: 1px;
}
.othello div {
  width: 30px;
  height: 30px;
  border-radius: 15px;
}
.othello div.black {
  background-color: black;
}
.othello div.white {
  background-color: white;
}
</style>
</head>
<body>
<div id="main">
        <a href="https://www.hanshq.net"><img src="gfx/header_dscf0079.jpg" id="header" alt="hanshq.net" style="max-width: 900px; max-height: 400px"></a>
        <div id="container">
                <div id="center">
                        <h1>Othello for Desktop, Mobile and Web: <br>an AI and GUI Exercise<br><span class="date">(24&nbsp;June&nbsp;2017)</span></h1>
                        <div id="left">

<p>Artificial intelligence (AI) is one of those subjects I really wish I'd taken while at university. Philosophical questions about intelligence aside, much of what AI comes down to in practice is techniques for solving problems with computers, which is really what computer science is all about.</p>

<p>A classic AI endeavour is programming computers to play chess. Shannon wrote <a href="https://vision.unipv.it/IA1/aa2009-2010/ProgrammingaComputerforPlayingChess.pdf">an article</a> about it already in 1948, and in 1997 the computer Deep Blue <a href="https://en.wikipedia.org/wiki/Deep_Blue_versus_Garry_Kasparov">defeated humankind</a> represented by world champion Garry Kasparov. A similar but much simpler board game is <a href="https://en.wikipedia.org/wiki/Reversi">Othello</a> (sometimes called Reversi), and writing an Othello program has become a popular exercise in AI classes.</p>

<p>I wanted to try my hand at writing an Othello game, but just doing a text-based version seemed lame; it really needs a graphical user interface. I never did much GUI programming (we did some in Java at university, but those weren't real programs), so it would be a good exercise for that too. The question was what platform to target. I use Linux, but most desktop computers run Windows or macOS. Also, most people run programs on smart-phones these days, and isn't the web the future of computing anyway? It would be interesting to learn about all of these platforms. The project scope had suddenly expanded.</p>

<p>This post describes the implementation of a basic Othello game engine in C with native user interfaces for Linux (X11), Windows, Mac, iOS, Android, and the web (asm.js and WebAssembly).</p>

<a name="download"></a>
<p>The source code is available in
<a href="files/othello.tar.gz"><span class="code">othello.tar.gz</span></a>,
the Windows executable in
<a href="files/othello/othello.exe"><span class="code">othello.exe</span></a>,
macOS application in
<a href="files/othello/mac/MacOthello.zip"><span class="code">MacOthello.zip</span></a>,
the iOS game
<a href="https://itunes.apple.com/us/app/othello-by-hanshq-net/id1248157746">in the App Store</a>,
the Android game
<a href="https://play.google.com/store/apps/details?id=net.hanshq.reversi">on Google Play</a>,
and the web version
<a href="files/othello/web/web_othello.html">right here.</a>
</p>

<p>Thanks to <a href="https://twitter.com/thakis">Nico</a> who provided valuable feedback on drafts of this post!</p>

<p><b>Update 2019-11-05:</b> Added dark mode support to the iOS port.</p>

<div style="text-align: center">
<a href="gfx/othello_reading_large.jpg"><img src="gfx/othello_reading.jpg" alt="Picture of books." style="width: 75%"></a>
</div>


<a name="toc"></a>
<h2>Table of Contents</h2>
<ul>
<li><a href="#ai">The Othello Engine</a><ul>
        <li><a href="#bitboards">Game Representation: Bitboards</a></li>
        <li><a href="#moves">Move Generation and Resolution</a></li>
        <li><a href="#eval">Position Evaluation</a></li>
        <li><a href="#minimax">Computing the Best Move</a></li>
</ul></li>
<li><a href="#ui">User Interfaces</a><ul>
        <li><a href="#x11">X11</a><ul>
                <li><a href="#x11_init">Initialization</a></li>
                <li><a href="#x11_draw">Drawing</a></li>
                <li><a href="#x11_events">Handling Events</a></li>
                <li><a href="#x11_moves">Making Moves</a></li>
                <li><a href="#x11_loop">Event Loop and main</a></li>
                <li><a href="#x11_build">Building</a></li>
        </ul></li>
        <li><a href="#win">Windows</a><ul>
                <li><a href="#win_init">Initialization and Message Loop</a></li>
                <li><a href="#win_resources">Resources</a></li>
                <li><a href="#win_draw">Drawing</a></li>
                <li><a href="#win_events">Handling Events</a></li>
                <li><a href="#win_moves">Making Moves</a></li>
                <li><a href="#win_build">Building</a></li>
        </ul></li>

        <li><a href="#mac">Mac</a><ul>
                <li><a href="#mac_anatomy">Anatomy of a Mac Application</a></li>
                <li><a href="#nibs">Nibs</a></li>
                <li><a href="#mac_controller">The Controller</a></li>
                <li><a href="#mac_view">The View</a></li>
                <li><a href="#mac_build">Building</a></li>
        </ul></li>
        <li><a href="#ios">iOS</a><ul>
                <li><a href="#ios_launchscreen">Launch Screen</a></li>
                <li><a href="#ios_main">Main and AppDelegate</a></li>
                <li><a href="#ios_viewcontroller">The View Controller</a></li>
                <li><a href="#ios_view">The View</a></li>
                <li><a href="#ios_build">Building</a></li>
        </ul></li>
        <li><a href="#android">Android</a><ul>
                <li><a href="#android_main">Manifest, Resources, and Main Activity</a></li>
                <li><a href="#android_jni">Accessing the Othello Engine</a></li>
                <li><a href="#android_view">The View</a></li>
                <li><a href="#android_build">Building</a></li>
        </ul></li>
        <li><a href="#web">Web</a><ul>
                <li><a href="#web_presentation">Presentation</a></li>
                <li><a href="#web_main">User Interface Logic</a></li>
                <li><a href="#web_worker">Worker Code</a></li>
                <li><a href="#web_build">Building</a></li>
        </ul></li>
</ul></li>
<li><a href="#exercises">Exercises</a></li>
</ul>


<a name="ai"></a>
<h2>The Othello Engine</h2>

<p>This section describes the implementation of a simple Othello engine. It's by no means very strong &mdash; other engines can beat it easily &mdash; but in practice it seems to win over most human players.</p>

<p>The code is in <a href="files/othello/othello.h"><span class="code">othello.h</span></a> and <a href="files/othello/othello.c"><span class="code">othello.c</span></a>.</p>

<a name="bitboards"></a>
<h3>Game Representation: Bitboards</h3>
<p>One particularly appealing aspect of Othello (and chess too) is that it is played on an 8-by-8 board, which means the number of squares on the board equals the number of bits in the machine word of a modern 64-bit computer.</p>

<p>Each cell on the board is assigned a corresponding bit position:</p>

<table border="1" class="othello" style="margin-left: auto; margin-right: auto">
<tr>
  <th></th>
  <th>A</th>
  <th>B</th>
  <th>C</th>
  <th>D</th>
  <th>E</th>
  <th>F</th>
  <th>G</th>
  <th>H</th>
</tr>
<tr>
  <th>1</th>
  <td>0</td>
  <td>1</td>
  <td>2</td>
  <td>3</td>
  <td>4</td>
  <td>5</td>
  <td>6</td>
  <td>7</td>
</tr>
<tr>
  <th>2</th>
  <td>8</td>
  <td>9</td>
  <td>10</td>
  <td>11</td>
  <td>12</td>
  <td>13</td>
  <td>14</td>
  <td>15</td>
</tr>
<tr>
  <th>3</th>
  <td>16</td>
  <td>17</td>
  <td>18</td>
  <td>19</td>
  <td>20</td>
  <td>21</td>
  <td>22</td>
  <td>23</td>
</tr>
<tr>
  <th>4</th>
  <td>24</td>
  <td>25</td>
  <td>26</td>
  <td>27</td>
  <td>28</td>
  <td>29</td>
  <td>30</td>
  <td>31</td>
</tr>
<tr>
  <th>5</th>
  <td>32</td>
  <td>33</td>
  <td>34</td>
  <td>35</td>
  <td>36</td>
  <td>37</td>
  <td>38</td>
  <td>39</td>
</tr>
<tr>
  <th>6</th>
  <td>40</td>
  <td>41</td>
  <td>42</td>
  <td>43</td>
  <td>44</td>
  <td>45</td>
  <td>46</td>
  <td>47</td>
</tr>
<tr>
  <th>7</th>
  <td>48</td>
  <td>49</td>
  <td>50</td>
  <td>51</td>
  <td>52</td>
  <td>53</td>
  <td>54</td>
  <td>55</td>
</tr>
<tr>
  <th>8</th>
  <td>56</td>
  <td>57</td>
  <td>58</td>
  <td>59</td>
  <td>60</td>
  <td>61</td>
  <td>62</td>
  <td>63</td>
</tr>
</table>

<p>We use two computer words, or <em>bitboards</em>, to keep track of the black and white disks. Each bitboard has the <span class="code">(row * 8 + col)</span>th least significant bit set if and only if there is a disk in that position:</p>

<div class="highlight"><pre><span></span><span class="k">typedef struct</span> <span class="p">{</span>
        <span class="kt">uint64_t</span> <span class="n">disks</span><span class="p">[</span><span class="mi">2</span><span class="p">];
}</span> <span class="n">othello_t</span><span class="p">;</span>

<span class="k">typedef enum</span> <span class="p">{</span>
        <span class="n">CELL_BLACK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">CELL_WHITE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">CELL_EMPTY</span> <span class="o">=</span> <span class="mi">2</span>
<span class="p">}</span> <span class="n">cell_state_t</span><span class="p">;</span>

<span class="k">typedef enum</span> <span class="p">{</span>
        <span class="n">PLAYER_BLACK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">PLAYER_WHITE</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">}</span> <span class="n">player_t</span><span class="p">;</span>

<span class="n">cell_state_t</span> <span class="nf">othello_cell_state</span><span class="p">(</span><span class="k">const</span> <span class="n">othello_t</span> <span class="o">*</span><span class="n">o</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)
{</span>
        <span class="kt">uint64_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">row</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">col</span><span class="p">);</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">row</span> <span class="o">&lt;=</span> <span class="mi">7</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">col</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">&lt;=</span> <span class="mi">7</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">disks</span><span class="p">[</span><span class="n">PLAYER_BLACK</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">) {</span>
                <span class="k">return</span> <span class="n">CELL_BLACK</span><span class="p">;
        }</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">disks</span><span class="p">[</span><span class="n">PLAYER_WHITE</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">) {</span>
                <span class="k">return</span> <span class="n">CELL_WHITE</span><span class="p">;
        }</span>
        <span class="k">return</span> <span class="n">CELL_EMPTY</span><span class="p">;
}</span>

<span class="kt">void</span> <span class="nf">othello_set_cell_state</span><span class="p">(</span><span class="n">othello_t</span> <span class="o">*</span><span class="n">o</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">,</span> <span class="n">cell_state_t s</span><span class="p">)
{</span>
        <span class="kt">uint64_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">row</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">col</span><span class="p">);</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">row</span> <span class="o">&lt;=</span> <span class="mi">7</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">col</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">&lt;=</span> <span class="mi">7</span><span class="p">);</span>

        <span class="n">o</span><span class="o">-&gt;</span><span class="n">disks</span><span class="p">[</span><span class="n">PLAYER_BLACK</span><span class="p">]</span> <span class="o">&amp;= ~</span><span class="n">mask</span><span class="p">;</span>
        <span class="n">o</span><span class="o">-&gt;</span><span class="n">disks</span><span class="p">[</span><span class="n">PLAYER_WHITE</span><span class="p">]</span> <span class="o">&amp;= ~</span><span class="n">mask</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">CELL_BLACK</span><span class="p">) {</span>
                <span class="n">o</span><span class="o">-&gt;</span><span class="n">disks</span><span class="p">[</span><span class="n">PLAYER_BLACK</span><span class="p">]</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;
        }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">CELL_WHITE</span><span class="p">) {</span>
                <span class="n">o</span><span class="o">-&gt;</span><span class="n">disks</span><span class="p">[</span><span class="n">PLAYER_WHITE</span><span class="p">]</span> <span class="o">|=</span> <span class="n">mask</span><span class="p">;
        }
}</span>
</pre></div>


<p>To set up a new game, we put disks in the starting position: black disks on D5 and E4, white disks on D4 and E5.</p>

<div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">othello_init</span><span class="p">(</span><span class="n">othello_t</span> <span class="o">*</span><span class="n">o</span><span class="p">)
{</span>
        <span class="n">o</span><span class="o">-&gt;</span><span class="n">disks</span><span class="p">[</span><span class="n">PLAYER_BLACK</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">o</span><span class="o">-&gt;</span><span class="n">disks</span><span class="p">[</span><span class="n">PLAYER_WHITE</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">othello_set_cell_state</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">CELL_BLACK</span><span class="p">);</span>
        <span class="n">othello_set_cell_state</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">CELL_BLACK</span><span class="p">);</span>
        <span class="n">othello_set_cell_state</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">CELL_WHITE</span><span class="p">);</span>
        <span class="n">othello_set_cell_state</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="n">CELL_WHITE</span><span class="p">);
}</span>
</pre></div>


<p>Counting the number of disks in a bitboard (the population count) is useful, for example to compute a player's score. Some processors provide special instructions for this (<span class="code">POPCNT</span> on x86), and GCC provides a built-in function to use such an instruction if available. For non-GCC we use a for-loop (see <a href="https://web.archive.org/web/20180820063833/http://www.hackersdelight.org/">Hacker's Delight</a>, Chapter 5 for <a href="https://web.archive.org/web/20180821003814/http://www.hackersdelight.org/hdcodetxt/pop.c.txt">many ways</a> of doing this).</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">popcount</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">x</span><span class="p">)
{</span>
<span class="cp">#ifdef __GNUC__</span>
        <span class="k">return</span> <span class="n">__builtin_popcountll</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
<span class="cp">#else</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">x</span><span class="p">) {</span>
                <span class="n">x</span> <span class="o">&amp;=</span> <span class="n">x</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
                <span class="n">n</span><span class="o">++</span><span class="p">;
        }</span>

        <span class="k">return</span> <span class="n">n</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">othello_score</span><span class="p">(</span><span class="k">const</span> <span class="n">othello_t</span> <span class="o">*</span><span class="n">o</span><span class="p">,</span> <span class="n">player_t p</span><span class="p">)
{</span>
        <span class="k">return</span> <span class="n">popcount</span><span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">disks</span><span class="p">[</span><span class="n">p</span><span class="p">]);
}</span>
</pre></div>



<p>Storing the disks in bitboards is memory efficient, but it's nothing more than a cute trick unless we can operate on them efficiently. It turns out that we can.</p>

<p>Using bitwise operators, we can perform set operations on the disks. For example, <span class="code">(black_disks | white_disks)</span> computes the union of both sets of disks, and <span class="code">~(black_disks | white_disks)</span> gets the complement, that is the set of empty squares on the board.</p>

<p>This is exciting because we are using a few very fast instructions to operate on many disks at the same time.</p>

<p>But it gets better! Using bitwise shift operations, we can move disks around. Looking at the bits with the least significant bit at the lower right, see what happens when we do <span class="code">bitboard &gt;&gt; 1</span>:</p>

<div style="text-align: center">
<table border="1" class="othello" style="display: inline-block">
<tr><th colspan="8"><span class="code">bitboard</span></th></tr>
<tr>
  <td>63</td>
  <td>62</td>
  <td>61</td>
  <td>60</td>
  <td>59</td>
  <td>58</td>
  <td>57</td>
  <td>56</td>
</tr>
<tr>
  <td>55</td>
  <td>54</td>
  <td>53</td>
  <td>52</td>
  <td>51</td>
  <td>50</td>
  <td>49</td>
  <td>48</td>
</tr>
<tr>
  <td>47</td>
  <td>46</td>
  <td>45</td>
  <td>44</td>
  <td>43</td>
  <td>42</td>
  <td>41</td>
  <td>40</td>
</tr>
<tr>
  <td>39</td>
  <td>38</td>
  <td>37</td>
  <td>36</td>
  <td>35</td>
  <td>34</td>
  <td>33</td>
  <td>32</td>
</tr>
<tr>
  <td>31</td>
  <td>30</td>
  <td>29</td>
  <td>28</td>
  <td>27</td>
  <td>26</td>
  <td>25</td>
  <td>24</td>
</tr>
<tr>
  <td>23</td>
  <td>22</td>
  <td>21</td>
  <td>20</td>
  <td>19</td>
  <td>18</td>
  <td>17</td>
  <td>16</td>
</tr>
<tr>
  <td>15</td>
  <td>14</td>
  <td>13</td>
  <td>12</td>
  <td>11</td>
  <td>10</td>
  <td>9</td>
  <td>8</td>
</tr>
<tr>
  <td>7</td>
  <td>6</td>
  <td>5</td>
  <td>4</td>
  <td>3</td>
  <td>2</td>
  <td>1</td>
  <td>0</td>
</tr>
</table>

<table border="1" class="othello" style="display: inline-block">
<tr><th colspan="8"><span class="code">bitboard &gt;&gt; 1</span></th></tr>
<tr>
  <td></td>
  <td>63</td>
  <td>62</td>
  <td>61</td>
  <td>60</td>
  <td>59</td>
  <td>58</td>
  <td>57</td>
</tr>
<tr>
  <td>56</td>
  <td>55</td>
  <td>54</td>
  <td>53</td>
  <td>52</td>
  <td>51</td>
  <td>50</td>
  <td>49</td>
</tr>
<tr>
  <td>48</td>
  <td>47</td>
  <td>46</td>
  <td>45</td>
  <td>44</td>
  <td>43</td>
  <td>42</td>
  <td>41</td>
</tr>
<tr>
  <td>40</td>
  <td>39</td>
  <td>38</td>
  <td>37</td>
  <td>36</td>
  <td>35</td>
  <td>34</td>
  <td>33</td>
</tr>
<tr>
  <td>32</td>
  <td>31</td>
  <td>30</td>
  <td>29</td>
  <td>28</td>
  <td>27</td>
  <td>26</td>
  <td>25</td>
</tr>
<tr>
  <td>24</td>
  <td>23</td>
  <td>22</td>
  <td>21</td>
  <td>20</td>
  <td>19</td>
  <td>18</td>
  <td>17</td>
</tr>
<tr>
  <td>16</td>
  <td>15</td>
  <td>14</td>
  <td>13</td>
  <td>12</td>
  <td>11</td>
  <td>10</td>
  <td>9</td>
</tr>
<tr>
  <td>8</td>
  <td>7</td>
  <td>6</td>
  <td>5</td>
  <td>4</td>
  <td>3</td>
  <td>2</td>
  <td>1</td>
</tr>
</table>
</div>

<p>Each bit has moved to the right, except the bits in the right-most column which wrapped around, or in the case of zero was pushed off the board. To exclude the bits that wrap around, we use a bitwise <span class="code">and</span> to mask them off (<span class="code">0x7F</span> in binary is <span class="code">01111111</span>):</p>

<table border="1" class="othello" style="margin-left: auto; margin-right: auto">
<tr><th colspan="8"><span class="code">(bitboard &gt;&gt; 1) &amp; 0x7F7F7F7F7F7F7F7FULL</span></th></tr>
<tr>
  <td></td>
  <td>63</td>
  <td>62</td>
  <td>61</td>
  <td>60</td>
  <td>59</td>
  <td>58</td>
  <td>57</td>
</tr>
<tr>
  <td></td>
  <td>55</td>
  <td>54</td>
  <td>53</td>
  <td>52</td>
  <td>51</td>
  <td>50</td>
  <td>49</td>
</tr>
<tr>
  <td></td>
  <td>47</td>
  <td>46</td>
  <td>45</td>
  <td>44</td>
  <td>43</td>
  <td>42</td>
  <td>41</td>
</tr>
<tr>
  <td></td>
  <td>39</td>
  <td>38</td>
  <td>37</td>
  <td>36</td>
  <td>35</td>
  <td>34</td>
  <td>33</td>
</tr>
<tr>
  <td></td>
  <td>31</td>
  <td>30</td>
  <td>29</td>
  <td>28</td>
  <td>27</td>
  <td>26</td>
  <td>25</td>
</tr>
<tr>
  <td></td>
  <td>23</td>
  <td>22</td>
  <td>21</td>
  <td>20</td>
  <td>19</td>
  <td>18</td>
  <td>17</td>
</tr>
<tr>
  <td></td>
  <td>15</td>
  <td>14</td>
  <td>13</td>
  <td>12</td>
  <td>11</td>
  <td>10</td>
  <td>9</td>
</tr>
<tr>
  <td></td>
  <td>7</td>
  <td>6</td>
  <td>5</td>
  <td>4</td>
  <td>3</td>
  <td>2</td>
  <td>1</td>
</tr>
</table>

<p>Since the bit in each position represents a disk on the board, we now have a way of moving all disks one step to the right with only a shift and an <span class="code">and</span>.</p>

<p>The same technique can be used for all eight directions. To move the disks left, left-shift one step and mask off the rightmost column. To move up or down, shift left or right 8 bits respectively, no masking necessary. To move down-and-left, shift right 7 bits, mask off the rightmost column and top row. And so on.</p>

<p>The function below shifts disks one step in a certain direction:</p>

<div class="highlight"><pre><span></span><span class="cp">#define NUM_DIRS 8</span>

<span class="cm">/* Shift disks in direction dir. */</span>
<span class="k">static</span> <span class="kt">uint64_t</span> <span class="nf">shift</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">disks</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dir</span><span class="p">)
{</span>
        <span class="cm">/* Note: the directions refer to how we shift the bits, not the
           positions on the board (where the least significant bit is
           the top-left corner). */</span>

        <span class="k">static const</span> <span class="kt">uint64_t</span> <span class="n">MASKS</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="mh">0x7F7F7F7F7F7F7F7FULL</span><span class="p">,</span> <span class="cm">/* Right. */</span>
                <span class="mh">0x007F7F7F7F7F7F7FULL</span><span class="p">,</span> <span class="cm">/* Down-right. */</span>
                <span class="mh">0xFFFFFFFFFFFFFFFFULL</span><span class="p">,</span> <span class="cm">/* Down. */</span>
                <span class="mh">0x00FEFEFEFEFEFEFEULL</span><span class="p">,</span> <span class="cm">/* Down-left. */</span>
                <span class="mh">0xFEFEFEFEFEFEFEFEULL</span><span class="p">,</span> <span class="cm">/* Left. */</span>
                <span class="mh">0xFEFEFEFEFEFEFE00ULL</span><span class="p">,</span> <span class="cm">/* Up-left. */</span>
                <span class="mh">0xFFFFFFFFFFFFFFFFULL</span><span class="p">,</span> <span class="cm">/* Up. */</span>
                <span class="mh">0x7F7F7F7F7F7F7F00ULL</span>  <span class="cm">/* Up-right. */</span>
        <span class="p">};</span>
        <span class="k">static const</span> <span class="kt">uint64_t</span> <span class="n">LSHIFTS</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="mi">0</span><span class="p">,</span> <span class="cm">/* Right. */</span>
                <span class="mi">0</span><span class="p">,</span> <span class="cm">/* Down-right. */</span>
                <span class="mi">0</span><span class="p">,</span> <span class="cm">/* Down. */</span>
                <span class="mi">0</span><span class="p">,</span> <span class="cm">/* Down-left. */</span>
                <span class="mi">1</span><span class="p">,</span> <span class="cm">/* Left. */</span>
                <span class="mi">9</span><span class="p">,</span> <span class="cm">/* Up-left. */</span>
                <span class="mi">8</span><span class="p">,</span> <span class="cm">/* Up. */</span>
                <span class="mi">7</span>  <span class="cm">/* Up-right. */</span>
        <span class="p">};</span>
        <span class="k">static const</span> <span class="kt">uint64_t</span> <span class="n">RSHIFTS</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
                <span class="mi">1</span><span class="p">,</span> <span class="cm">/* Right. */</span>
                <span class="mi">9</span><span class="p">,</span> <span class="cm">/* Down-right. */</span>
                <span class="mi">8</span><span class="p">,</span> <span class="cm">/* Down. */</span>
                <span class="mi">7</span><span class="p">,</span> <span class="cm">/* Down-left. */</span>
                <span class="mi">0</span><span class="p">,</span> <span class="cm">/* Left. */</span>
                <span class="mi">0</span><span class="p">,</span> <span class="cm">/* Up-left. */</span>
                <span class="mi">0</span><span class="p">,</span> <span class="cm">/* Up. */</span>
                <span class="mi">0</span>  <span class="cm">/* Up-right. */</span>
        <span class="p">};</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">dir</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">dir</span> <span class="o">&lt;</span> <span class="n">NUM_DIRS</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">dir</span> <span class="o">&lt;</span> <span class="n">NUM_DIRS</span> <span class="o">/</span> <span class="mi">2</span><span class="p">) {</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">LSHIFTS</span><span class="p">[</span><span class="n">dir</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Shifting right.&quot;</span><span class="p">);</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">disks</span> <span class="o">&gt;&gt;</span> <span class="n">RSHIFTS</span><span class="p">[</span><span class="n">dir</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">MASKS</span><span class="p">[</span><span class="n">dir</span><span class="p">];
        }</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">RSHIFTS</span><span class="p">[</span><span class="n">dir</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Shifting left.&quot;</span><span class="p">);</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">disks</span> <span class="o">&lt;&lt;</span> <span class="n">LSHIFTS</span><span class="p">[</span><span class="n">dir</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">MASKS</span><span class="p">[</span><span class="n">dir</span><span class="p">];
        }
}</span>
</pre></div>


<p>(Why shift all bits and mask afterwards instead of masking first, thereby only shifting the bits we want? It's because later we will do <span class="code">shift(x, dir) & opp_disks</span> repeatedly, and this way <span class="code">masks[dir] & opp_disks</span> becomes a <a href="https://en.wikipedia.org/wiki/Common_subexpression_elimination">common subexpression</a> that only needs to be computed once.)</p>

<a name="moves"></a>
<h3>Move Generation and Resolution</h3>

<p>Computing the set of legal moves for a player, a process known as <em>move generation</em>, is the first step towards computing the best move to make. The operations explained above allow us to do it efficiently.</p>

<p>A legal Othello move is one which captures one or more of the opponent's disks between the new disk and one of the player's current disks in a straight line &mdash; horizontally, vertically or diagonally.</p>

<p>For example, on the board below the legal moves for black are C3, C4 and C6 (marked with X):</p>
<table border="1" class="othello" style="margin-left: auto; margin-right: auto">
<tr>
  <th></th>
  <th>A</th>
  <th>B</th>
  <th>C</th>
  <th>D</th>
  <th>E</th>
  <th>F</th>
  <th>G</th>
  <th>H</th>
</tr>
<tr>
  <th>1</th>
  <td><div></div></td>
  <td><div></div></td>
  <td><div></div></td>
  <td><div></div></td>
  <td><div></div></td>
  <td><div></div></td>
  <td><div></div></td>
  <td><div></div></td>
</tr>
<tr>
  <th>2</th>
  <td><div></div></td>
  <td><div></div></td>
  <td><div></div></td>
  <td><div></div></td>
  <td><div></div></td>
  <td><div></div></td>
  <td><div></div></td>
  <td><div></div></td>
</tr>
<tr>
  <th>3</th>
  <td><div></div></td>
  <td><div></div></td>
  <td>X</td>
  <td><div></div></td>
  <td><div></div></td>
  <td><div></div></td>
  <td><div></div></td>
  <td><div></div></td>
</tr>
<tr>
  <th>4</th>
  <td><div></div></td>
  <td><div></div></td>
  <td>X</td>
  <td><div class="white"></div></td>
  <td><div class="black"></div></td>
  <td><div></div></td>
  <td><div></div></td>
  <td><div></div></td>
</tr>
<tr>
  <th>5</th>
  <td><div></div></td>
  <td><div></div></td>
  <td><div></div></td>
  <td><div class="white"></div></td>
  <td><div class="white"></div></td>
  <td><div></div></td>
  <td><div></div></td>
  <td><div></div></td>
</tr>
<tr>
  <th>6</th>
  <td><div></div></td>
  <td><div></div></td>
  <td>X</td>
  <td><div class="white"></div></td>
  <td><div class="black"></div></td>
  <td><div class="black"></div></td>
  <td><div class="black"></div></td>
  <td><div></div></td>
</tr>
<tr>
  <th>7</th>
  <td><div></div></td>
  <td><div></div></td>
  <td><div></div></td>
  <td><div></div></td>
  <td><div></div></td>
  <td><div></div></td>
  <td><div></div></td>
  <td><div></div></td>
</tr>
<tr>
  <th>8</th>
  <td><div></div></td>
  <td><div></div></td>
  <td><div></div></td>
  <td><div></div></td>
  <td><div></div></td>
  <td><div></div></td>
  <td><div></div></td>
  <td><div></div></td>
</tr>
</table>

<p>Consider the black disk at F6 above. Moving up-and-left, it has a white neighbour disk (E5), and then another one (D4), and then an empty square at C3 which means that's a valid move.</p>

<p>This reasoning can be turned into an algorithm. For each of our disks, we follow opponent neighbour disks in some direction until we hit an empty square, which is then a legal move. Since the board is 8 squares wide, that empty square can be a maximum of 7 squares away from the original disk. Repeating this for each direction will find all legal moves.</p>

<p>The bitboard representation allows us to work with all the disks simultaneously. For example, to get the opponent disks immediately to the right of ours, we do <span class="code">x = shift(my_disks, 0) &amp; opp_disks</span>, that is we take the intersection of our disks shifted one step right and the set of opponent disks. To add the opponent disks adjacent to those, we do it again: <span class="code">x |= shift(x, 0) &amp; opp_disks</span>. After seven shifts we intersect with the set of empty cells to get the of valid moves in that direction. The function below implements this technique to generate the moves:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">uint64_t</span> <span class="nf">generate_moves</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">my_disks</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">opp_disks</span><span class="p">)
{</span>
        <span class="kt">int</span> <span class="n">dir</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">x</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">empty_cells</span> <span class="o">= ~</span><span class="p">(</span><span class="n">my_disks</span> <span class="o">|</span> <span class="n">opp_disks</span><span class="p">);</span>
        <span class="kt">uint64_t</span> <span class="n">legal_moves</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">assert</span><span class="p">((</span><span class="n">my_disks</span> <span class="o">&amp;</span> <span class="n">opp_disks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Disk sets should be disjoint.&quot;</span><span class="p">);</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">dir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dir</span> <span class="o">&lt;</span> <span class="n">NUM_DIRS</span><span class="p">;</span> <span class="n">dir</span><span class="o">++</span><span class="p">) {</span>
                <span class="cm">/* Get opponent disks adjacent to my disks in direction dir. */</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">shift</span><span class="p">(</span><span class="n">my_disks</span><span class="p">,</span> <span class="n">dir</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">opp_disks</span><span class="p">;</span>

                <span class="cm">/* Add opponent disks adjacent to those, and so on. */</span>
                <span class="n">x</span> <span class="o">|=</span> <span class="n">shift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dir</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">opp_disks</span><span class="p">;</span>
                <span class="n">x</span> <span class="o">|=</span> <span class="n">shift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dir</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">opp_disks</span><span class="p">;</span>
                <span class="n">x</span> <span class="o">|=</span> <span class="n">shift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dir</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">opp_disks</span><span class="p">;</span>
                <span class="n">x</span> <span class="o">|=</span> <span class="n">shift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dir</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">opp_disks</span><span class="p">;</span>
                <span class="n">x</span> <span class="o">|=</span> <span class="n">shift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dir</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">opp_disks</span><span class="p">;</span>

                <span class="cm">/* Empty cells adjacent to those are valid moves. */</span>
                <span class="n">legal_moves</span> <span class="o">|=</span> <span class="n">shift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dir</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">empty_cells</span><span class="p">;
        }</span>

        <span class="k">return</span> <span class="n">legal_moves</span><span class="p">;
}</span>
</pre></div>


<p>(This method of "following" connected disks is a <a href="https://en.wikipedia.org/wiki/Flood_fill">flood fill</a> algorithm, and because we do it seven times, it is sometimes referred to as <a href="https://chessprogramming.wikispaces.com/Dumb7Fill">Dumb7Fill</a>.)</p>

<p>(While the bitwise operations are very efficient, having to repeat the whole process eight times might seem a little annoying. But note that except for the update of <span class="code">legal_moves</span>, each iteration of the loop body performs exactly the same operations over independent sets of data &mdash; it is perfect for <a href="https://en.wikipedia.org/wiki/SIMD">SIMD</a> machine instructions. Compiled with GCC 6 on my Haswell machine, the function can execute about 23 million times per second, but with <a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions#Advanced_Vector_Extensions_2">AVX2</a> instructions enabled it runs 85 million times per second. Pretty fast!)</p>

<p>We use <span class="code">generate_moves</span> to check whether a player has legal moves or whether a certain proposed move is valid in the code below. (Since <span class="code">p</span> is <span class="code">1</span> or <span class="code">0</span>, <span class="code">p ^ 1</span>, gets us the other player. <span class="code">!p</span> would also work, but the <span class="code">XOR</span> version tends to yield smaller and faster code.)</p>

<div class="highlight"><pre><span></span><span class="kt">bool</span> <span class="nf">othello_has_valid_move</span><span class="p">(</span><span class="k">const</span> <span class="n">othello_t</span> <span class="o">*</span><span class="n">o</span><span class="p">,</span> <span class="n">player_t p</span><span class="p">)
{</span>
        <span class="k">return</span> <span class="n">generate_moves</span><span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">disks</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">disks</span><span class="p">[</span><span class="n">p</span> <span class="o">^</span> <span class="mi">1</span><span class="p">])</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;
}</span>

<span class="kt">bool</span> <span class="nf">othello_is_valid_move</span><span class="p">(</span><span class="k">const</span> <span class="n">othello_t</span> <span class="o">*</span><span class="n">o</span><span class="p">,</span> <span class="n">player_t p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)
{</span>
        <span class="kt">uint64_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">row</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">col</span><span class="p">);</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">row</span> <span class="o">&lt;=</span> <span class="mi">7</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">col</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">&lt;=</span> <span class="mi">7</span><span class="p">);</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">generate_moves</span><span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">disks</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">disks</span><span class="p">[</span><span class="n">p</span> <span class="o">^</span> <span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="n">mask</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;
}</span>
</pre></div>


<p>To update the board after a move has been made, a process called <em>move resolution</em>, we add the new disk to the board and flip the opponent disks that were captured. To find the captured disks, we use a similar method to the one above. For each direction, we follow opponent disks adjacent to the new disk, and if we end up at one of our own disks, the opponent disks we followed are captured:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">resolve_move</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="o">*</span><span class="n">my_disks</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">opp_disks</span><span class="p">,</span> <span class="kt">int</span> <span class="n">board_idx</span><span class="p">)
{</span>
        <span class="kt">int</span> <span class="n">dir</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">x</span><span class="p">,</span> <span class="n">bounding_disk</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">new_disk</span> <span class="o">=</span> <span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">board_idx</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">captured_disks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">board_idx</span> <span class="o">&lt;</span> <span class="mi">64</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Move must be within the board.&quot;</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">((</span><span class="o">*</span><span class="n">my_disks</span> <span class="o">&amp; *</span><span class="n">opp_disks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Disk sets must be disjoint.&quot;</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="p">((</span><span class="o">*</span><span class="n">my_disks</span> <span class="o">| *</span><span class="n">opp_disks</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">new_disk</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Target not empty!&quot;</span><span class="p">);</span>

        <span class="o">*</span><span class="n">my_disks</span> <span class="o">|=</span> <span class="n">new_disk</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">dir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dir</span> <span class="o">&lt;</span> <span class="n">NUM_DIRS</span><span class="p">;</span> <span class="n">dir</span><span class="o">++</span><span class="p">) {</span>
                <span class="cm">/* Find opponent disk adjacent to the new disk. */</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">shift</span><span class="p">(</span><span class="n">new_disk</span><span class="p">,</span> <span class="n">dir</span><span class="p">)</span> <span class="o">&amp; *</span><span class="n">opp_disks</span><span class="p">;</span>

                <span class="cm">/* Add any adjacent opponent disk to that one, and so on. */</span>
                <span class="n">x</span> <span class="o">|=</span> <span class="n">shift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dir</span><span class="p">)</span> <span class="o">&amp; *</span><span class="n">opp_disks</span><span class="p">;</span>
                <span class="n">x</span> <span class="o">|=</span> <span class="n">shift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dir</span><span class="p">)</span> <span class="o">&amp; *</span><span class="n">opp_disks</span><span class="p">;</span>
                <span class="n">x</span> <span class="o">|=</span> <span class="n">shift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dir</span><span class="p">)</span> <span class="o">&amp; *</span><span class="n">opp_disks</span><span class="p">;</span>
                <span class="n">x</span> <span class="o">|=</span> <span class="n">shift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dir</span><span class="p">)</span> <span class="o">&amp; *</span><span class="n">opp_disks</span><span class="p">;</span>
                <span class="n">x</span> <span class="o">|=</span> <span class="n">shift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dir</span><span class="p">)</span> <span class="o">&amp; *</span><span class="n">opp_disks</span><span class="p">;</span>

                <span class="cm">/* Determine whether the disks were captured. */</span>
                <span class="n">bounding_disk</span> <span class="o">=</span> <span class="n">shift</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dir</span><span class="p">)</span> <span class="o">&amp; *</span><span class="n">my_disks</span><span class="p">;</span>
                <span class="n">captured_disks</span> <span class="o">|=</span> <span class="p">(</span><span class="n">bounding_disk</span> <span class="o">?</span> <span class="nl">x</span> <span class="p">:</span> <span class="mi">0</span><span class="p">);
        }</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">captured_disks</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;A valid move must capture disks.&quot;</span><span class="p">);</span>

        <span class="o">*</span><span class="n">my_disks</span> <span class="o">^=</span> <span class="n">captured_disks</span><span class="p">;</span>
        <span class="o">*</span><span class="n">opp_disks</span> <span class="o">^=</span> <span class="n">captured_disks</span><span class="p">;</span>

        <span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">my_disks</span> <span class="o">&amp; *</span><span class="n">opp_disks</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;The sets must still be disjoint.&quot;</span><span class="p">);
}</span>

<span class="kt">void</span> <span class="nf">othello_make_move</span><span class="p">(</span><span class="n">othello_t</span> <span class="o">*</span><span class="n">o</span><span class="p">,</span> <span class="n">player_t p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)
{</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">othello_is_valid_move</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">));</span>

        <span class="n">resolve_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">disks</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">disks</span><span class="p">[</span><span class="n">p</span> <span class="o">^</span> <span class="mi">1</span><span class="p">],</span> <span class="n">row</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">col</span><span class="p">);
}</span>
</pre></div>


<a name="eval"></a>
<h3>Position Evaluation</h3>

<p>In order to find a good move, the program needs to be able to differentiate between good and bad game positions. Obviously a won game is good and a lost one is bad, but since the program cannot look ahead until the end of the game most of the time, it needs to evaluate intermediate positions as well.</p>

<p>The evaluation function is a heuristic that estimates how good the position is for the current player: the better the position, the larger the returned value. If the position is better for the opponent, the value is negative.</p>

<p>Because the objective of Othello is to have the most disks in the end, a naive way of evaluating positions would be to simply compare the number of disks for both players. This is a bad idea since disks can flip and many disks for one player could become many disks for the opponent after the next move.</p>

<p>Another idea is to assign weights to the different squares on the board and compute a score based on disks in those squares. For example, corner disks are valuable because they cannot be flipped, and the squares next to the corners are dangerous because they potentially give the opponent access to the corner. Coming up with good weights for the whole board is tricky, though.</p>

<p>My evaluation function is based on the mobility-based approach <a href="http://radagast.se/othello/howto.html#evaluation">from Gunnar Andersson's homepage</a>. It computes a score using three features of the position: the number of available moves, frontier disks (disks adjacent to empty cells), and captured corners:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">frontier_disks</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">my_disks</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">opp_disks</span><span class="p">,</span>
                           <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">my_frontier</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="o">*</span><span class="n">opp_frontier</span><span class="p">)
{</span>
        <span class="kt">uint64_t</span> <span class="n">empty_cells</span> <span class="o">= ~</span><span class="p">(</span><span class="n">my_disks</span> <span class="o">|</span> <span class="n">opp_disks</span><span class="p">);</span>
        <span class="kt">uint64_t</span> <span class="n">x</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">dir</span><span class="p">;</span>

        <span class="o">*</span><span class="n">my_frontier</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="o">*</span><span class="n">opp_frontier</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="n">dir</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">dir</span> <span class="o">&lt;</span> <span class="n">NUM_DIRS</span><span class="p">;</span> <span class="n">dir</span><span class="o">++</span><span class="p">) {</span>
                <span class="cm">/* Check cells adjacent to empty cells. */</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">shift</span><span class="p">(</span><span class="n">empty_cells</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
                <span class="o">*</span><span class="n">my_frontier</span> <span class="o">|=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="n">my_disks</span><span class="p">;</span>
                <span class="o">*</span><span class="n">opp_frontier</span> <span class="o">|=</span> <span class="n">x</span> <span class="o">&amp;</span> <span class="n">opp_disks</span><span class="p">;
        }
}</span>

<span class="cp">#define WIN_BONUS (1 &lt;&lt; 20)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">eval</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">my_disks</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">opp_disks</span><span class="p">,</span>
                <span class="kt">uint64_t</span> <span class="n">my_moves</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">opp_moves</span><span class="p">)
{</span>
        <span class="k">static const</span> <span class="kt">uint64_t</span> <span class="n">CORNER_MASK</span> <span class="o">=</span> <span class="mh">0x8100000000000081ULL</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">my_disk_count</span><span class="p">,</span> <span class="n">opp_disk_count</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">my_corners</span><span class="p">,</span> <span class="n">opp_corners</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">my_frontier</span><span class="p">,</span> <span class="n">opp_frontier</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">score</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">my_moves</span> <span class="o">&amp;&amp; !</span><span class="n">opp_moves</span><span class="p">) {</span>
                <span class="cm">/* Terminal state. */</span>
                <span class="n">my_disk_count</span> <span class="o">=</span> <span class="n">popcount</span><span class="p">(</span><span class="n">my_disks</span><span class="p">);</span>
                <span class="n">opp_disk_count</span> <span class="o">=</span> <span class="n">popcount</span><span class="p">(</span><span class="n">opp_disks</span><span class="p">);</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">my_disk_count</span> <span class="o">-</span> <span class="n">opp_disk_count</span><span class="p">)</span> <span class="o">*</span> <span class="n">WIN_BONUS</span><span class="p">;
        }</span>

        <span class="n">my_corners</span> <span class="o">=</span> <span class="n">my_disks</span> <span class="o">&amp;</span> <span class="n">CORNER_MASK</span><span class="p">;</span>
        <span class="n">opp_corners</span> <span class="o">=</span> <span class="n">opp_disks</span> <span class="o">&amp;</span> <span class="n">CORNER_MASK</span><span class="p">;</span>

        <span class="n">frontier_disks</span><span class="p">(</span><span class="n">my_disks</span><span class="p">,</span> <span class="n">opp_disks</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">my_frontier</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opp_frontier</span><span class="p">);</span>

        <span class="cm">/* Optimize for corners, mobility and few frontier disks. */</span>
        <span class="n">score</span> <span class="o">+=</span> <span class="p">(</span><span class="n">popcount</span><span class="p">(</span><span class="n">my_corners</span><span class="p">)</span> <span class="o">-</span> <span class="n">popcount</span><span class="p">(</span><span class="n">opp_corners</span><span class="p">))</span> <span class="o">*</span> <span class="mi">16</span><span class="p">;</span>
        <span class="n">score</span> <span class="o">+=</span> <span class="p">(</span><span class="n">popcount</span><span class="p">(</span><span class="n">my_moves</span><span class="p">)</span> <span class="o">-</span> <span class="n">popcount</span><span class="p">(</span><span class="n">opp_moves</span><span class="p">))</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">score</span> <span class="o">+=</span> <span class="p">(</span><span class="n">popcount</span><span class="p">(</span><span class="n">my_frontier</span><span class="p">)</span> <span class="o">-</span> <span class="n">popcount</span><span class="p">(</span><span class="n">opp_frontier</span><span class="p">))</span> <span class="o">* -</span><span class="mi">1</span><span class="p">;</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">score</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">WIN_BONUS</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">score</span><span class="p">;
}</span>
</pre></div>


<p>Note that scores in the end state are computed separately; an actual win is better than even the most promising non-final position.</p>

<p>The evaluation function is very much a "careful what you wish for" kind of thing. If you give a large bonus for capturing corners, the program will try to capture corners at the expense of the other criteria. A program with a sufficiently strong evaluation function will beat an opponent with a weaker one, even if the opponent is considering moves further ahead in the game; optimizing for the wrong metric is no use in the end, no matter how well one does it.</p>


<a name="minimax"></a>
<h3>Computing the Best Move</h3>

<p>Now that we know what legal moves are available and have a heuristic for scoring different positions, how do we compute the best move?</p>

<p>One optimistic approach would be to consider each move and pick the one that could lead to the best future position. The only problem is that our opponent is likely to do their best in preventing us from reaching it.</p>

<p>A more carefully calculated approach is to assume our opponent is doing their best to defeat us. For each move we could make, we assume that the opponent would play to minimize the score for us, and so we pick the move which yields the largest, maximum, of those scores &mdash; the <em><a href="https://en.wikipedia.org/wiki/Minimax">minimax</a></em> value.</p>

<p>How do we know what move our opponent would make to minimize the score? We use the same idea: the opponent considers how we would follow their move, and picks the minimum of those scores. This gives us a recursive algorithm:</p>

<div class="highlight"><pre><span></span>function minimax(position, player):
  if position is terminal or max depth reached:
    return eval(position)

  if player == black:
    max_score = -infinity
    for each move:
      new_position = resolve(position, move)
      score = minimax(new_position, white)
      if score &gt; max_score:
        max_score = score
        best_move = move
    return max_score

  if player == white:
    min_score = infinity
    for each move:
      new_position = resolve(position, move)
      score = minimax(new_position, black)
      if score &lt; min_score:
        min_score = score
        best_move = move
    return min_score
</pre></div>


<p><em><a href="https://en.wikipedia.org/wiki/Alpha%E2%80%93beta_pruning">Alpha-beta pruning</a></em> is an important optimization of this algorithm.
The idea is to keep track of the best guaranteed result for black (alpha) and for white (beta) in the search so far, that is <span class="code">alpha &lt;= score &lt;= beta</span>. As long as those bounds can be tightened, in other words while <span class="code">alpha &lt; beta</span>, the search continues, but scores outside the range are not worth considering since they cannot impact the result. This significantly reduces the number of moves that need to be considered:</p>

<div class="highlight"><pre><span></span>function minimax(position, player, alpha, beta):
  if position is terminal or max depth reached:
    return eval(position)

  if player == black:
    max_score = -infinity
    for each move:
      new_position = resolve(position, move)
      score = minimax(new_position, white, alpha, beta)
      if score &gt; max_score:
        max_score = score
        best_move = move
        alpha = max(alpha, score)
      if alpha &gt;= beta:
        break
    return max_score

  if player == white:
    min_score = infinity
    for each move:
      new_position = resolve(position, move)
      score = minimax(new_position, black, alpha, beta)
      if score &lt; min_score:
        min_score = score
        best_move = move
        beta = min(beta, score)
      if alpha &gt;= beta:
        break
    return min_score
</pre></div>


<p>Patrick Winston explains minimax with alpha-beta pruning in <a href="https://www.youtube.com/watch?v=STjW3eH0Cik&amp;list=PLUl4u3cNGP63gFHB6xb-kVBiQHYe_4hSi&amp;index=6">his lecture from the MIT AI course</a> (minimax starts at <a href="https://www.youtube.com/watch?v=STjW3eH0Cik&amp;list=PLUl4u3cNGP63gFHB6xb-kVBiQHYe_4hSi&amp;index=6&amp;t=16m30s">16:30</a>).</p>

<p>As a convenience when implementing this, to avoid having separate cases for black and white in the <span class="code">minimax</span> function, we will use a formulation of the algorithm called <a href="https://en.wikipedia.org/wiki/Negamax"><em>negamax</em></a>.
Instead of letting the white player search for a minimum score from the position after our move, we reverse the position (black disks become white and vice versa) and search for a maximum score from there. We then negate the result of that (high scores for the opponent are low scores for us). This computes the exact same value as before, but with the same code for both players:</p>

<div class="highlight"><pre><span></span>function negamax(position, alpha, beta):
  if position is terminal or max depth reached:
    return eval(position)

  max_score = -infinity
  for each move:
    new_position = resolve(position, move)
    score = -negamax(reverse(new_position), -beta, -alpha)
    if score &gt; max_score:
      max_score = score
      best_move = move
      alpha = max(alpha, score)
    if alpha &gt;= beta:
      break
  return max_score
</pre></div>


<p>This is what the implementation looks like:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">negamax</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">my_disks</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">opp_disks</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_depth</span><span class="p">,</span>
                   <span class="kt">int</span> <span class="n">alpha</span><span class="p">,</span> <span class="kt">int</span> <span class="n">beta</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">best_move</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">eval_count</span><span class="p">)
{</span>
        <span class="kt">uint64_t</span> <span class="n">my_moves</span><span class="p">,</span> <span class="n">opp_moves</span><span class="p">;</span>
        <span class="kt">uint64_t</span> <span class="n">my_new_disks</span><span class="p">,</span> <span class="n">opp_new_disks</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">best</span><span class="p">;</span>

        <span class="cm">/* Generate moves. */</span>
        <span class="n">my_moves</span> <span class="o">=</span> <span class="n">generate_moves</span><span class="p">(</span><span class="n">my_disks</span><span class="p">,</span> <span class="n">opp_disks</span><span class="p">);</span>
        <span class="n">opp_moves</span> <span class="o">=</span> <span class="n">generate_moves</span><span class="p">(</span><span class="n">opp_disks</span><span class="p">,</span> <span class="n">my_disks</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">my_moves</span> <span class="o">&amp;&amp;</span> <span class="n">opp_moves</span><span class="p">) {</span>
                <span class="cm">/* Null move. */</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">negamax</span><span class="p">(</span><span class="n">opp_disks</span><span class="p">,</span> <span class="n">my_disks</span><span class="p">,</span> <span class="n">max_depth</span><span class="p">,</span> <span class="o">-</span><span class="n">beta</span><span class="p">,</span> <span class="o">-</span><span class="n">alpha</span><span class="p">,</span>
                                <span class="n">best_move</span><span class="p">,</span> <span class="n">eval_count</span><span class="p">);
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">max_depth</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="p">(</span><span class="o">!</span><span class="n">my_moves</span> <span class="o">&amp;&amp; !</span><span class="n">opp_moves</span><span class="p">)) {</span>
                <span class="cm">/* Maximum depth or terminal state reached. */</span>
                <span class="o">++*</span><span class="n">eval_count</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">eval</span><span class="p">(</span><span class="n">my_disks</span><span class="p">,</span> <span class="n">opp_disks</span><span class="p">,</span> <span class="n">my_moves</span><span class="p">,</span> <span class="n">opp_moves</span><span class="p">);
        }</span>

        <span class="cm">/* Find the best move. */</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">alpha</span> <span class="o">&lt;</span> <span class="n">beta</span><span class="p">);</span>
        <span class="n">best</span> <span class="o">= -</span><span class="n">INT_MAX</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">my_moves</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1ULL</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">))) {</span>
                        <span class="k">continue</span><span class="p">;
                }</span>
                <span class="n">my_new_disks</span> <span class="o">=</span> <span class="n">my_disks</span><span class="p">;</span>
                <span class="n">opp_new_disks</span> <span class="o">=</span> <span class="n">opp_disks</span><span class="p">;</span>
                <span class="n">resolve_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_new_disks</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">opp_new_disks</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

                <span class="n">s</span> <span class="o">= -</span><span class="n">negamax</span><span class="p">(</span><span class="n">opp_new_disks</span><span class="p">,</span> <span class="n">my_new_disks</span><span class="p">,</span>
                             <span class="n">max_depth</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">beta</span><span class="p">,</span> <span class="o">-</span><span class="n">alpha</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
                             <span class="n">eval_count</span><span class="p">);</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">&gt;</span> <span class="n">best</span><span class="p">) {</span>
                        <span class="n">best</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">best_move</span><span class="p">) {</span>
                                <span class="o">*</span><span class="n">best_move</span> <span class="o">=</span> <span class="n">i</span><span class="p">;
                        }</span>
                        <span class="n">alpha</span> <span class="o">=</span> <span class="n">s</span> <span class="o">&gt;</span> <span class="n">alpha</span> <span class="o">?</span> <span class="nl">s</span> <span class="p">:</span> <span class="n">alpha</span><span class="p">;</span>

                        <span class="k">if</span> <span class="p">(</span><span class="n">alpha</span> <span class="o">&gt;=</span> <span class="n">beta</span><span class="p">) {</span>
                                <span class="k">break</span><span class="p">;
                        }
                }
        }</span>

        <span class="k">return</span> <span class="n">best</span><span class="p">;
}</span>
</pre></div>


<p>How deep should we search? That depends on how long we're willing to wait and where we are in the game: towards the end of the game we can search deeper because there are fewer possible moves.</p>

<p>The technique we will use is called <em>iterative deepening</em>. The idea is to keep searching deeper until the best move is a win or loss, or we run out of time. However, since I would like the program to play identically across all platforms and devices, instead of a time budget we will use a budget for number of evaluations:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span> <span class="nf">iterative_negamax</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">my_disks</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">opp_disks</span><span class="p">,</span>
                             <span class="kt">int</span> <span class="n">start_depth</span><span class="p">,</span> <span class="kt">int</span> <span class="n">eval_budget</span><span class="p">)
{</span>
        <span class="kt">int</span> <span class="n">depth</span><span class="p">,</span> <span class="n">best_move</span><span class="p">,</span> <span class="n">eval_count</span><span class="p">,</span> <span class="n">s</span><span class="p">;</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">start_depth</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;At least one move must be explored.&quot;</span><span class="p">);</span>

        <span class="n">eval_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">best_move</span> <span class="o">= -</span><span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">depth</span> <span class="o">=</span> <span class="n">start_depth</span><span class="p">;</span> <span class="n">eval_count</span> <span class="o">&lt;</span> <span class="n">eval_budget</span><span class="p">;</span> <span class="n">depth</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">negamax</span><span class="p">(</span><span class="n">my_disks</span><span class="p">,</span> <span class="n">opp_disks</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="o">-</span><span class="n">INT_MAX</span><span class="p">,</span> <span class="n">INT_MAX</span><span class="p">,</span>
                            <span class="o">&amp;</span><span class="n">best_move</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eval_count</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">s</span> <span class="o">&gt;=</span> <span class="n">WIN_BONUS</span> <span class="o">|| -</span><span class="n">s</span> <span class="o">&gt;=</span> <span class="n">WIN_BONUS</span><span class="p">) {</span>
                        <span class="k">break</span><span class="p">;
                }
        }</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">best_move</span> <span class="o">!= -</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;No move found?&quot;</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">best_move</span><span class="p">;
}</span>

<span class="kt">void</span> <span class="nf">othello_compute_move</span><span class="p">(</span><span class="k">const</span> <span class="n">othello_t</span> <span class="o">*</span><span class="n">o</span><span class="p">,</span> <span class="n">player_t p</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">col</span><span class="p">)
{</span>
        <span class="kt">int</span> <span class="n">move_idx</span><span class="p">;</span>

        <span class="k">static const</span> <span class="kt">int</span> <span class="n">START_DEPTH</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
        <span class="k">static const</span> <span class="kt">int</span> <span class="n">EVAL_BUDGET</span> <span class="o">=</span> <span class="mi">500000</span><span class="p">;</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">othello_has_valid_move</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">p</span><span class="p">));</span>

        <span class="n">move_idx</span> <span class="o">=</span> <span class="n">iterative_negamax</span><span class="p">(</span><span class="n">o</span><span class="o">-&gt;</span><span class="n">disks</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">disks</span><span class="p">[</span><span class="n">p</span> <span class="o">^</span> <span class="mi">1</span><span class="p">],</span>
                                     <span class="n">START_DEPTH</span><span class="p">,</span> <span class="n">EVAL_BUDGET</span><span class="p">);</span>

        <span class="o">*</span><span class="n">row</span> <span class="o">=</span> <span class="n">move_idx</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
        <span class="o">*</span><span class="n">col</span> <span class="o">=</span> <span class="n">move_idx</span> <span class="o">%</span> <span class="mi">8</span><span class="p">;
}</span>
</pre></div>


<a name="ui"></a>
<h2>User Interfaces</h2>

<a name="x11"></a>
<h3>X11</h3>
<p>The <a href="https://en.wikipedia.org/wiki/X_Window_System">X Window System</a>, X11 (11 being the latest major revision, released in 1987), or just X, is like an ancient beast lurking at the bottom of the lake of Unix, old and ever-present. First developed at MIT in the eighties, it's still at the centre of desktop environments today. It is slated to be replaced by <a href="https://wayland.freedesktop.org/">Wayland</a>, but that hasn't happened yet.</p>

<p>While virtually all graphical Unix applications use it, almost none interact with X directly. Instead, a graphical toolkit library such as <a href="https://www.gtk.org/">GTK+</a> or <a href="https://www.qt.io/">Qt</a> is normally used. Besides providing a more modern programming interface, such toolkits provide routines for using application <em>widgets</em> &mdash; buttons, text boxes, menus, etc. Even really old X programs used toolkits such as <a href="https://en.wikipedia.org/wiki/Xaw">Xaw</a> or <a href="https://en.wikipedia.org/wiki/Motif_%28software%29">Motif</a>, because X itself only deals with primitives such as windows, lines, circles, etc.</p>

<p>The Othello game doesn't really need any widgets though, and I would like to learn about X at a low level, so we will use it directly through its client library, <a href="https://en.wikipedia.org/wiki/Xlib">Xlib</a>. (One could go even deeper: since X is a network protocol, we could send packets to the server directly, no client library needed. However, that might be one step too far even for this post.)</p>

<p>I learned about X from the classic manuals published by O'Reilly: <a href="http://shop.oreilly.com/product/9781565920026.do">Xlib Programming Manual</a> (Vol 1) and <a href="http://shop.oreilly.com/product/9781565920064.do">Xlib Reference Manual</a> (Vol 2) edited by Adrian Nye. (According <a href="https://web.archive.org/web/20010315073933/http://www.forbes.com/1997/08/18/feat.html">to</a> <a href="https://www.wired.com/2005/10/oreilly/">legend</a>, the X manuals were what got O'Reilly started.) These are now out of print, but used copies are easy to come by. X.Org has <a href="https://www.x.org/wiki/ProgrammingDocumentation/">more documentation</a>. See also Jasper St. Pierre's <a href="http://magcius.github.io/xplain/article/index.html">Xplain</a> series.</p>

<p>The code is available in <a href="files/othello/x11_othello.c"><span class="code">x11_othello.c</span></a>.</p>

<p>Our Othello program will be organized more or less according to the <a href="https://en.wikipedia.org/wiki/Model%E2%80%93view%E2%80%93controller">Model-view-controller</a> pattern. We model the game using the structures and routines defined in the previous section, and an enum to keep track of whose turn it is:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">othello_t board</span><span class="p">;</span>
<span class="k">static enum</span> <span class="p">{</span> <span class="n">BLACKS_MOVE</span><span class="p">,</span> <span class="n">WHITES_MOVE</span><span class="p">,</span> <span class="n">GAME_OVER</span> <span class="p">}</span> <span class="n">state</span><span class="p">;</span>
</pre></div>


<p>The view is what the user sees, the visualization of the game. It is drawn as a grid with disks in the appropriate cells, etc. We keep track of the grid's size and position in the window, as well as the currently selected cell:</p>

<div class="highlight"><pre><span></span><span class="k">static struct</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>      <span class="cm">/* Position of the grid relative to window origin. */</span>
        <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>      <span class="cm">/* Size (width and height are equal) of the grid. */</span>
        <span class="kt">int</span> <span class="n">cell_size</span><span class="p">;</span> <span class="cm">/* Size of a grid cell, not including its border. */</span>
        <span class="kt">int</span> <span class="n">sel_row</span><span class="p">;</span>   <span class="cm">/* Currently selected row, or -1 if none. */</span>
        <span class="kt">int</span> <span class="n">sel_col</span><span class="p">;</span>   <span class="cm">/* Currently selected column. */</span>
<span class="p">}</span> <span class="n">grid</span><span class="p">;</span>
</pre></div>


<p>To draw our grid and interact with X in general, we need a few more things:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">Display</span> <span class="o">*</span><span class="n">display</span><span class="p">;</span>
<span class="k">static</span> <span class="n">Window win</span><span class="p">;</span>
<span class="k">static</span> <span class="n">GC black_gc</span><span class="p">;</span>
<span class="k">static</span> <span class="n">GC white_gc</span><span class="p">;</span>
<span class="k">static</span> <span class="n">GC board_gc</span><span class="p">;</span>     <span class="cm">/* For the board background. */</span>
<span class="k">static</span> <span class="n">GC highlight_gc</span><span class="p">;</span> <span class="cm">/* For selected grid cells. */</span>
<span class="k">static</span> <span class="n">XFontStruct</span> <span class="o">*</span><span class="n">font</span><span class="p">;</span>
<span class="k">static</span> <span class="n">Atom wm_delete_window</span><span class="p">;</span>
</pre></div>


<p>X11 is a network protocol, the idea being that an application does not necessarily have to be running on the same computer through which a user interacts with it. The application (X client) could be running on one machine, perhaps a beefy computer in a data centre, while the user interacts with it through the keyboard, mouse and monitor of a computer (X server) in their office. The <span class="code">Display</span> object represents the connection to the X server, which these days is normally on the same machine as the application itself.</p>

<p>The <span class="code">Window</span> object represents the window our program will use to interact with the user. The <span class="code">GC</span> objects are <em>graphics contexts</em>. They determine the style (colour, stroke width, etc) when drawing lines and such. The <span class="code">XFontStruct</span> is what we'll use for text, and the <span class="code">Atom</span> refers to a message we need to handle.</p>

<a name="x11_init"></a>
<h4>Initialization</h4>
<p>We need a fair amount of boilerplate code to initialize our application. (This is what we get for using a low-level library.) First, we attempt to connect to the server with <span class="code"><a href="https://www.x.org/releases/X11R7.7/doc/libX11/libX11/libX11.html#XOpenDisplay">XOpenDisplay</a></span>:</p>

<div class="highlight"><pre><span></span><span class="cp">#define CELL_GAP 1       </span><span class="cm">/* Cell gap in pixels. */</span><span class="cp">
#define FONT_NAME &quot;9x15&quot; </span><span class="cm">/* Font for labels and status. */</span><span class="cp">
#define MIN_SIZE 300     </span><span class="cm">/* Minimum window size. */</span><span class="cp">
#define INIT_SIZE 450    </span><span class="cm">/* Initial window size. */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)
{</span>
        <span class="n">XSizeHints</span> <span class="o">*</span><span class="n">size_hints</span><span class="p">;</span>
        <span class="n">XWMHints</span> <span class="o">*</span><span class="n">wm_hints</span><span class="p">;</span>
        <span class="n">XClassHint</span> <span class="o">*</span><span class="n">class_hint</span><span class="p">;</span>
        <span class="kt">unsigned long</span> <span class="n">black_color</span><span class="p">,</span> <span class="n">white_color</span><span class="p">,</span> <span class="n">grey_color</span><span class="p">;</span>
        <span class="kt">unsigned long</span> <span class="n">board_color</span><span class="p">,</span> <span class="n">hl_color</span><span class="p">;</span>
        <span class="kt">char</span> <span class="o">*</span><span class="n">window_name</span> <span class="o">=</span> <span class="s">&quot;Othello&quot;</span><span class="p">;</span>
        <span class="n">XTextProperty window_name_prop</span><span class="p">;</span>

        <span class="cm">/* Connect to the display. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">display</span> <span class="o">=</span> <span class="n">XOpenDisplay</span><span class="p">(</span><span class="nb">NULL</span><span class="p">))) {</span>
                <span class="n">err</span><span class="p">(</span><span class="s">&quot;cannot connect to X server %s&quot;</span><span class="p">,</span> <span class="n">XDisplayName</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));
        }</span>
</pre></div>


<p>The <span class="code">NULL</span> argument specifies that we want the default screen (specified by the <span class="code">DISPLAY</span> envionment variable, usually as <span class="code">:0</span>, meaning the first display on the local machine).</p>

<p>Once connected, we allocate some colours. <span class="code"><a href="https://www.x.org/releases/X11R7.7/doc/libX11/libX11/libX11.html#XAllocColor">XAllocColor</a></span> asks the server to add a specific colour (or as close an approximation as possible) to its <em>colormap</em>, or palette, and returns an index into this map. We wrap the call in a convenience function:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">unsigned long</span> <span class="nf">alloc_color</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="n">red</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">green</span><span class="p">,</span> <span class="kt">uint8_t</span> <span class="n">blue</span><span class="p">)
{</span>
        <span class="n">XColor color</span><span class="p">;</span>
        <span class="n">Colormap map</span><span class="p">;</span>

        <span class="n">map</span> <span class="o">=</span> <span class="n">DefaultColormap</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">DefaultScreen</span><span class="p">(</span><span class="n">display</span><span class="p">));</span>
        <span class="n">color</span><span class="p">.</span><span class="n">red</span>   <span class="o">=</span> <span class="n">red</span>   <span class="o">*</span> <span class="mi">256</span><span class="p">;</span>
        <span class="n">color</span><span class="p">.</span><span class="n">green</span> <span class="o">=</span> <span class="n">green</span> <span class="o">*</span> <span class="mi">256</span><span class="p">;</span>
        <span class="n">color</span><span class="p">.</span><span class="n">blue</span>  <span class="o">=</span> <span class="n">blue</span>  <span class="o">*</span> <span class="mi">256</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">XAllocColor</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">color</span><span class="p">)) {</span>
                <span class="n">err</span><span class="p">(</span><span class="s">&quot;XAllocColor failed&quot;</span><span class="p">);
        }</span>

        <span class="k">return</span> <span class="n">color</span><span class="p">.</span><span class="n">pixel</span><span class="p">;
}</span>
</pre></div>


<p>and use that to allocate the colours we'll need for drawing (back in <span class="code">init</span>):</p>

<div class="highlight"><pre><span></span>        <span class="cm">/* Allocate colours. */</span>
        <span class="n">black_color</span> <span class="o">=</span> <span class="n">alloc_color</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>
        <span class="n">white_color</span> <span class="o">=</span> <span class="n">alloc_color</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">);</span>
        <span class="n">grey_color</span>  <span class="o">=</span> <span class="n">alloc_color</span><span class="p">(</span><span class="mh">0xC0</span><span class="p">,</span> <span class="mh">0xC0</span><span class="p">,</span> <span class="mh">0xC0</span><span class="p">);</span>
        <span class="n">board_color</span> <span class="o">=</span> <span class="n">alloc_color</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>
        <span class="n">hl_color</span>    <span class="o">=</span> <span class="n">alloc_color</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">);</span>
</pre></div>


<p>Then we create the window with a call to <span class="code"><a href="https://www.x.org/releases/X11R7.7/doc/libX11/libX11/libX11.html#XCreateSimpleWindow">XCreateSimpleWindow</a></span>:</p>

<div class="highlight"><pre><span></span>        <span class="cm">/* Create the window. */</span>
        <span class="n">win</span> <span class="o">=</span> <span class="n">XCreateSimpleWindow</span><span class="p">(</span><span class="n">display</span><span class="p">,</span>
                                  <span class="n">RootWindow</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">DefaultScreen</span><span class="p">(</span><span class="n">display</span><span class="p">)),</span>
                                  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">INIT_SIZE</span><span class="p">,</span> <span class="n">INIT_SIZE</span><span class="p">,</span> <span class="n">CELL_GAP</span><span class="p">,</span>
                                  <span class="n">black_color</span><span class="p">,</span> <span class="n">grey_color</span><span class="p">);</span>
</pre></div>


<p>The parameters specify the <span class="code">display</span> (X server), and that we want our window to be the child of the <em>root window</em> of the default screen on that server. (Historically there could be multiple X screens if multiple monitors were attached to one machine; these days, there is usually just one screen that covers all monitors.) The other parameters specify the initial position (0,0), size, border width (mostly ignored these days I think), foreground and background colour.</p>

<p>Note that the new window is not shown yet. We will reveal it later, after everything has been initialized.</p>

<p>Next, we pass more information about the window to the window manager. This includes the title of the window (in the form of an <span class="code">XTextProperty</span>, created with <span class="code"><a href="https://www.x.org/releases/X11R7.7/doc/libX11/libX11/libX11.html#XStringListToTextProperty">XStringListToTextProperty</a></span>), the minimum size, initial state (minimized or normal), whether the window takes input, the name of the application, and so on. For both <span class="code">size_hints</span> and <span class="code">wm_hints</span>, we use the <span class="code">flags</span> field to indicate which parts of the structure we're filling in.</p>

<p>In <span class="code">wm_hints</span> we also set the icon for the application. It is loaded from an <a href="https://en.wikipedia.org/wiki/X_PixMap#XPM">XPM</a> file, which is <span class="code">#include</span>d directly into our source, using <span class="code">XpmCreatePixmapFromData</span>. That function isn't strictly part of Xlib, but a separate XPM library. That is normally always available on systems that have X, though.</p>

<div class="highlight"><pre><span></span>        <span class="cm">/* Prepare window name property. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">XStringListToTextProperty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">window_name</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">window_name_prop</span><span class="p">)) {</span>
                <span class="n">err</span><span class="p">(</span><span class="s">&quot;XStringListToTextProperty failed&quot;</span><span class="p">);
        }</span>

        <span class="cm">/* Prepare size hints. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">size_hints</span> <span class="o">=</span> <span class="n">XAllocSizeHints</span><span class="p">())) {</span>
                <span class="n">err</span><span class="p">(</span><span class="s">&quot;XAllocSizeHints() failed&quot;</span><span class="p">);
        }</span>
        <span class="n">size_hints</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">PMinSize</span><span class="p">;</span>
        <span class="n">size_hints</span><span class="o">-&gt;</span><span class="n">min_width</span> <span class="o">=</span> <span class="n">MIN_SIZE</span><span class="p">;</span>
        <span class="n">size_hints</span><span class="o">-&gt;</span><span class="n">min_height</span> <span class="o">=</span> <span class="n">MIN_SIZE</span><span class="p">;</span>

        <span class="cm">/* Prepare window manager hints. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">wm_hints</span> <span class="o">=</span> <span class="n">XAllocWMHints</span><span class="p">())) {</span>
                <span class="n">err</span><span class="p">(</span><span class="s">&quot;XAllocWMHints() failed&quot;</span><span class="p">);
        }</span>
        <span class="n">wm_hints</span><span class="o">-&gt;</span><span class="n">initial_state</span> <span class="o">=</span> <span class="n">NormalState</span><span class="p">;</span>
        <span class="n">wm_hints</span><span class="o">-&gt;</span><span class="n">input</span> <span class="o">=</span> <span class="n">True</span><span class="p">;</span>
        <span class="n">wm_hints</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">StateHint</span> <span class="o">|</span> <span class="n">InputHint</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">XpmCreatePixmapFromData</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">win</span><span class="p">,</span> <span class="n">othello_icon</span><span class="p">,</span>
                                    <span class="o">&amp;</span><span class="n">wm_hints</span><span class="o">-&gt;</span><span class="n">icon_pixmap</span><span class="p">,</span>
                                    <span class="o">&amp;</span><span class="n">wm_hints</span><span class="o">-&gt;</span><span class="n">icon_mask</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">==</span> <span class="n">XpmSuccess</span><span class="p">) {</span>
                <span class="n">wm_hints</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">IconPixmapHint</span> <span class="o">|</span> <span class="n">IconMaskHint</span><span class="p">;
        }</span>

        <span class="cm">/* Prepare class hint. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">class_hint</span> <span class="o">=</span> <span class="n">XAllocClassHint</span><span class="p">())) {</span>
                <span class="n">err</span><span class="p">(</span><span class="s">&quot;XAllocClassHint() failed&quot;</span><span class="p">);
        }</span>
        <span class="n">class_hint</span><span class="o">-&gt;</span><span class="n">res_name</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
        <span class="n">class_hint</span><span class="o">-&gt;</span><span class="n">res_class</span> <span class="o">=</span> <span class="n">window_name</span><span class="p">;</span>

        <span class="cm">/* Set name property, size, wm and class hints for the window. */</span>
        <span class="n">XSetWMProperties</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">win</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">window_name_prop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">window_name_prop</span><span class="p">,</span>
                         <span class="n">argv</span><span class="p">,</span> <span class="n">argc</span><span class="p">,</span> <span class="n">size_hints</span><span class="p">,</span> <span class="n">wm_hints</span><span class="p">,</span> <span class="n">class_hint</span><span class="p">);</span>
        <span class="n">XFree</span><span class="p">(</span><span class="n">window_name_prop</span><span class="p">.</span><span class="n">value</span><span class="p">);</span>
        <span class="n">XFree</span><span class="p">(</span><span class="n">size_hints</span><span class="p">);</span>
        <span class="n">XFree</span><span class="p">(</span><span class="n">wm_hints</span><span class="p">);</span>
        <span class="n">XFree</span><span class="p">(</span><span class="n">class_hint</span><span class="p">);</span>
</pre></div>


<p>We tell the X server what type of events we want to be notified of, by passing an <a href="https://www.x.org/releases/X11R7.7/doc/libX11/libX11/libX11.html#id2737408">event mask</a> to <span class="code"><a href="https://www.x.org/releases/X11R7.7/doc/libX11/libX11/libX11.html#XSelectInput">XSelectInput</a></span>. We also tell the window manager that we would like to use the <span class="code"><a href="https://tronche.com/gui/x/icccm/sec-4.html#s-4.2.8.1">WM_DELETE_WINDOW</a></span> protocol, which means we want to be notified if the user clicks the close button on the window.</p>


<div class="highlight"><pre><span></span>        <span class="cm">/* Register for events. */</span>
        <span class="n">XSelectInput</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">win</span><span class="p">,</span> <span class="n">ExposureMask</span> <span class="o">|</span> <span class="n">KeyPressMask</span> <span class="o">|</span>
                        <span class="n">ButtonPressMask</span> <span class="o">|</span> <span class="n">StructureNotifyMask</span> <span class="o">|</span>
                        <span class="n">PointerMotionMask</span> <span class="o">|</span> <span class="n">PointerMotionHintMask</span><span class="p">);</span>

        <span class="n">wm_delete_window</span> <span class="o">=</span> <span class="n">XInternAtom</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="s">&quot;WM_DELETE_WINDOW&quot;</span><span class="p">,</span> <span class="n">False</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">XSetWMProtocols</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">win</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wm_delete_window</span><span class="p">,</span> <span class="mi">1</span><span class="p">)) {</span>
                <span class="n">err</span><span class="p">(</span><span class="s">&quot;XSetWMProtocols failed&quot;</span><span class="p">);
        }</span>
</pre></div>


<p>As the final steps of initialization, we load the font and create the graphics contexts that we'll need for drawing:</p>

<div class="highlight"><pre><span></span>        <span class="cm">/* Load the font. */</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">font</span> <span class="o">=</span> <span class="n">XLoadQueryFont</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">FONT_NAME</span><span class="p">))) {</span>
                <span class="n">err</span><span class="p">(</span><span class="s">&quot;cannot open %s font&quot;</span><span class="p">,</span> <span class="n">FONT_NAME</span><span class="p">);
        }</span>

        <span class="cm">/* Set up GCs. */</span>
        <span class="n">black_gc</span> <span class="o">=</span> <span class="n">XCreateGC</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">win</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">XSetForeground</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">black_gc</span><span class="p">,</span> <span class="n">black_color</span><span class="p">);</span>
        <span class="n">XSetFont</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">black_gc</span><span class="p">,</span> <span class="n">font</span><span class="o">-&gt;</span><span class="n">fid</span><span class="p">);</span>

        <span class="n">white_gc</span> <span class="o">=</span> <span class="n">XCreateGC</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">win</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">XSetForeground</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">white_gc</span><span class="p">,</span> <span class="n">white_color</span><span class="p">);</span>

        <span class="n">board_gc</span> <span class="o">=</span> <span class="n">XCreateGC</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">win</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">XSetForeground</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">board_gc</span><span class="p">,</span> <span class="n">board_color</span><span class="p">);</span>

        <span class="n">highlight_gc</span> <span class="o">=</span> <span class="n">XCreateGC</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">win</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">XSetForeground</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">highlight_gc</span><span class="p">,</span> <span class="n">hl_color</span><span class="p">);</span>
</pre></div>


<p>And now we're ready to request the window to be shown, or <em>mapped</em> in X parlance:</p>

<div class="highlight"><pre><span></span>        <span class="cm">/* Show the window. */</span>
        <span class="n">XMapWindow</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">win</span><span class="p">);
}</span>
</pre></div>


<a name="x11_draw"></a>
<h4>Drawing</h4>

<p>Before drawing the grid, we need to know exactly where to draw it. We divide the height or width (whichever is smallest) of the window to fit a 10-by-10 grid of equal-size quadratic cells with <span class="code">CELL_GAP</span> pixels in between them. Then we position the grid in the centre of the window:</p>

<div class="highlight"><pre><span></span><span class="cm">/* Compute the grid&#39;s size and position in the window. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">compute_grid_position</span><span class="p">(</span><span class="kt">int</span> <span class="n">win_width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">win_height</span><span class="p">)
{</span>
        <span class="cm">/* The grid is a 10x10 grid. The 8x8 centre is the Othello
           board, the top row and left column are used for labels, and the
           bottom row for status text. */</span>

        <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">win_width</span><span class="p">,</span> <span class="n">win_height</span><span class="p">)</span> <span class="o">-</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">CELL_GAP</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
        <span class="n">grid</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">CELL_GAP</span><span class="p">;</span>
        <span class="n">grid</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">win_width</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">grid</span><span class="p">.</span><span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">grid</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">win_height</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">grid</span><span class="p">.</span><span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;
}</span>
</pre></div>


<p>Knowing the size and position of the grid is also necessary for <em>hit testing</em>, checking whether a position (the mouse position in our case) intersects with an Othello cell:</p>

<div class="highlight"><pre><span></span><span class="cm">/* Check whether the position is over an Othello cell. */</span>
<span class="k">static</span> <span class="kt">bool</span> <span class="nf">grid_hit_test</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">col</span><span class="p">)
{</span>
        <span class="o">*</span><span class="n">row</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">grid</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="o">*</span><span class="n">col</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">grid</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp; *</span><span class="n">row</span> <span class="o">&lt;</span> <span class="mi">8</span> <span class="o">&amp;&amp; *</span><span class="n">col</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp; *</span><span class="n">col</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">) {</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;
        }</span>

        <span class="k">return</span> <span class="nb">false</span><span class="p">;
}</span>
</pre></div>


<p>The code below is used to draw an Othello cell. First, the cell background is drawn using <span class="code"><a href="https://www.x.org/releases/X11R7.7/doc/libX11/libX11/libX11.html#XFillRectangle">XFillRectangle</a></span>. A different graphics context is used for different colour depending on whether the cell is currently selected. If there is a disk in the cell, <span class="code"><a href="https://www.x.org/releases/X11R7.7/doc/libX11/libX11/libX11.html#XFillArc">XFillArc</a></span> is used to draw it as a filled circle.</p>

<div class="highlight"><pre><span></span><span class="cm">/* Draw an Othello cell and its contents. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">draw_othello_cell</span><span class="p">(</span><span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)
{</span>
        <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">highlight</span><span class="p">;</span>
        <span class="n">cell_state_t cs</span><span class="p">;</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="p">);</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="p">);</span>

        <span class="n">highlight</span> <span class="o">=</span> <span class="p">(</span><span class="n">row</span> <span class="o">==</span> <span class="n">grid</span><span class="p">.</span><span class="n">sel_row</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">==</span> <span class="n">grid</span><span class="p">.</span><span class="n">sel_col</span> <span class="o">&amp;&amp;</span>
                     <span class="n">state</span> <span class="o">==</span> <span class="n">BLACKS_MOVE</span><span class="p">);</span>

        <span class="cm">/* Draw the cell background. */</span>
        <span class="n">XFillRectangle</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">win</span><span class="p">,</span> <span class="n">highlight</span> <span class="o">?</span> <span class="nl">highlight_gc</span> <span class="p">:</span> <span class="n">board_gc</span><span class="p">,</span>
                       <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span><span class="p">,</span> <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">cs</span> <span class="o">=</span> <span class="n">othello_cell_state</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span> <span class="o">!=</span> <span class="n">CELL_EMPTY</span><span class="p">) {</span>
                <span class="cm">/* Draw the disk. */</span>
                <span class="n">XFillArc</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">win</span><span class="p">,</span> <span class="n">cs</span> <span class="o">==</span> <span class="n">CELL_BLACK</span> <span class="o">?</span> <span class="nl">black_gc</span> <span class="p">:</span> <span class="n">white_gc</span><span class="p">,</span>
                         <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span><span class="p">,</span> <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">360</span> <span class="o">*</span> <span class="mi">64</span><span class="p">);
        }
}</span>
</pre></div>


<p>To draw row and column labels around the board, and status text below it, we use a helper function for drawing text centered at a specific position:</p>

<div class="highlight"><pre><span></span><span class="cm">/* Draw string s of length len centered at (x,y). */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">draw_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)
{</span>
        <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">;</span>

        <span class="n">width</span> <span class="o">=</span> <span class="n">XTextWidth</span><span class="p">(</span><span class="n">font</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">font</span><span class="o">-&gt;</span><span class="n">ascent</span> <span class="o">+</span> <span class="n">font</span><span class="o">-&gt;</span><span class="n">descent</span><span class="p">;</span>

        <span class="n">XDrawString</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">win</span><span class="p">,</span> <span class="n">black_gc</span><span class="p">,</span>
                    <span class="n">x</span> <span class="o">-</span> <span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                    <span class="n">s</span><span class="p">,</span> <span class="n">len</span><span class="p">);
}</span>
</pre></div>


<p>Finally, the function below is used to draw the whole grid:</p>

<div class="highlight"><pre><span></span><span class="cm">/* Draw the grid and its contents. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">draw_grid</span><span class="p">(</span><span class="kt">void</span><span class="p">)
{</span>
        <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bs</span><span class="p">,</span> <span class="n">ws</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">status</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>

        <span class="n">XClearWindow</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">win</span><span class="p">);</span>

        <span class="cm">/* Draw a background square around the 8x8 centre cells. */</span>
        <span class="n">XFillRectangle</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">win</span><span class="p">,</span> <span class="n">black_gc</span><span class="p">,</span>
                       <span class="n">grid</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span><span class="p">,</span>
                       <span class="n">grid</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span><span class="p">,</span>
                       <span class="mi">8</span> <span class="o">*</span> <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">+</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">CELL_GAP</span><span class="p">,</span>
                       <span class="mi">8</span> <span class="o">*</span> <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">+</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">CELL_GAP</span><span class="p">);</span>

        <span class="cm">/* Draw labels. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="p">)</span> <span class="o">+</span>
                        <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
                <span class="n">draw_string</span><span class="p">(</span><span class="o">&amp;</span><span class="s">&quot;12345678&quot;</span><span class="p">[</span><span class="n">row</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);
        }</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">col</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="p">)</span> <span class="o">+</span>
                        <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
                <span class="n">draw_string</span><span class="p">(</span><span class="o">&amp;</span><span class="s">&quot;ABCDEFGH&quot;</span><span class="p">[</span><span class="n">col</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);
        }</span>

        <span class="cm">/* Draw status text. */</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">) {</span>
        <span class="k">case</span> <span class="nl">BLACKS_MOVE</span><span class="p">:</span>
                <span class="n">sprintf</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;Human&#39;s move.&quot;</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">WHITES_MOVE</span><span class="p">:</span>
                <span class="n">sprintf</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;Computer&#39;s move..&quot;</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">GAME_OVER</span><span class="p">:</span>
                <span class="n">bs</span> <span class="o">=</span> <span class="n">othello_score</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_BLACK</span><span class="p">);</span>
                <span class="n">ws</span> <span class="o">=</span> <span class="n">othello_score</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_WHITE</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">bs</span> <span class="o">&gt;</span> <span class="n">ws</span><span class="p">) {</span>
                        <span class="n">sprintf</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;Human wins %d-%d!&quot;</span><span class="p">,</span> <span class="n">bs</span><span class="p">,</span> <span class="n">ws</span><span class="p">);
                }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">ws</span> <span class="o">&gt;</span> <span class="n">bs</span><span class="p">) {</span>
                        <span class="n">sprintf</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;Computer wins %d-%d!&quot;</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">bs</span><span class="p">);
                }</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="n">sprintf</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;Draw!&quot;</span><span class="p">);
                }
        }</span>
        <span class="n">draw_string</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">status</span><span class="p">),</span> <span class="n">grid</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">grid</span><span class="p">.</span><span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                    <span class="n">grid</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">grid</span><span class="p">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>

        <span class="cm">/* Draw cells. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">) {</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">col</span><span class="o">++</span><span class="p">) {</span>
                        <span class="n">draw_othello_cell</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">);
                }
        }
}</span>
</pre></div>


<a name="x11_events"></a>
<h4>Handling Events</h4>

<p>The program needs to handle three main user events: mouse moves, mouse clicks, and keyboard presses.</p>

<p>When the mouse moves, we'd like to select and highlight the cell currently under the cursor, if any:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">select_othello_cell</span><span class="p">(</span><span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)
{</span>
        <span class="kt">int</span> <span class="n">old_row</span> <span class="o">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">sel_row</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">old_col</span> <span class="o">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">sel_col</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">==</span> <span class="n">old_row</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">==</span> <span class="n">old_col</span><span class="p">) {</span>
                <span class="cm">/* This cell is already selected. */</span>
                <span class="k">return</span><span class="p">;
        }</span>

        <span class="n">grid</span><span class="p">.</span><span class="n">sel_row</span> <span class="o">=</span> <span class="n">row</span><span class="p">;</span>
        <span class="n">grid</span><span class="p">.</span><span class="n">sel_col</span> <span class="o">=</span> <span class="n">col</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">old_row</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="cm">/* Re-draw the previously selected cell. */</span>
                <span class="n">draw_othello_cell</span><span class="p">(</span><span class="n">old_row</span><span class="p">,</span> <span class="n">old_col</span><span class="p">);
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="cm">/* Draw the newly selected cell. */</span>
                <span class="n">draw_othello_cell</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">);
        }
}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">on_mouse_move</span><span class="p">(</span><span class="kt">void</span><span class="p">)
{</span>
        <span class="n">Window root</span><span class="p">,</span> <span class="n">child</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">root_x</span><span class="p">,</span> <span class="n">root_y</span><span class="p">,</span> <span class="n">win_x</span><span class="p">,</span> <span class="n">win_y</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="n">mask</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">XQueryPointer</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">win</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">child</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root_x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root_y</span><span class="p">,</span>
                           <span class="o">&amp;</span><span class="n">win_x</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">win_y</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mask</span><span class="p">)) {</span>
                <span class="k">return</span><span class="p">;
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">grid_hit_test</span><span class="p">(</span><span class="n">win_x</span><span class="p">,</span> <span class="n">win_y</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">row</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">col</span><span class="p">)) {</span>
                <span class="n">select_othello_cell</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">);
        }</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">select_othello_cell</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);
        }
}</span>
</pre></div>


<p>Because we used <span class="code">PointerMotionHintMask</span> when registering for events, we are not guaranteed to receive an event for each position the mouse moves through. Instead, we receive notifications after the mouse has moved, and then requests the exact position with <span class="code"><a href="https://www.x.org/releases/X11R7.7/doc/libX11/libX11/libX11.html#XQueryPointer">XQueryPointer</a></span>. This cuts down on the number of events that has to be processed.</p>

<p>A mouse click is taken as a request to make a move in the currently selected cell, or to start a new game if the current one has finished:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">new_game</span><span class="p">(</span><span class="kt">void</span><span class="p">)
{</span>
        <span class="n">othello_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">);</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">BLACKS_MOVE</span><span class="p">;
}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">on_mouse_click</span><span class="p">(</span><span class="kt">void</span><span class="p">)
{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">GAME_OVER</span><span class="p">) {</span>
                <span class="n">new_game</span><span class="p">();</span>
                <span class="k">return</span><span class="p">;
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">BLACKS_MOVE</span> <span class="o">&amp;&amp;</span> <span class="n">grid</span><span class="p">.</span><span class="n">sel_row</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="n">make_move</span><span class="p">(</span><span class="n">grid</span><span class="p">.</span><span class="n">sel_row</span><span class="p">,</span> <span class="n">grid</span><span class="p">.</span><span class="n">sel_col</span><span class="p">);
        }
}</span>
</pre></div>


<p>The keyboard can be used to quit the game, make a move or select a cell. <span class="code"><a href="https://www.x.org/releases/X11R7.7/doc/libX11/libX11/libX11.html#XLookupKeysym">XLookupKeysym</a></span> is used to determine which key, or <span class="code">KeySym</span>, was pressed:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">on_key_press</span><span class="p">(</span><span class="n">XKeyEvent</span> <span class="o">*</span><span class="n">xkey</span><span class="p">,</span> <span class="kt">bool</span> <span class="o">*</span><span class="n">quit</span><span class="p">,</span> <span class="kt">bool</span> <span class="o">*</span><span class="n">draw</span><span class="p">)
{</span>
        <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">;</span>

        <span class="n">row</span> <span class="o">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">sel_row</span><span class="p">;</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">sel_col</span><span class="p">;</span>

        <span class="k">switch</span> <span class="p">(</span><span class="n">XLookupKeysym</span><span class="p">(</span><span class="n">xkey</span><span class="p">,</span> <span class="mi">0</span><span class="p">)) {</span>
        <span class="k">default</span><span class="o">:</span>
                <span class="k">return</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">XK_q</span><span class="p">:</span>
                <span class="o">*</span><span class="n">quit</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="k">return</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">XK_space</span><span class="p">:</span>
        <span class="k">case</span> <span class="nl">XK_Return</span><span class="p">:</span>
                <span class="n">on_mouse_click</span><span class="p">();</span>
                <span class="o">*</span><span class="n">draw</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                <span class="k">return</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">XK_Right</span><span class="p">:</span> <span class="n">col</span><span class="o">++</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">XK_Left</span><span class="p">:</span>  <span class="n">col</span><span class="o">--</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">XK_Down</span><span class="p">:</span>  <span class="n">row</span><span class="o">++</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">XK_Up</span><span class="p">:</span>    <span class="n">row</span><span class="o">--</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">XK_a</span><span class="p">:</span>     <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">XK_b</span><span class="p">:</span>     <span class="n">col</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">XK_c</span><span class="p">:</span>     <span class="n">col</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">XK_d</span><span class="p">:</span>     <span class="n">col</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">XK_e</span><span class="p">:</span>     <span class="n">col</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">XK_f</span><span class="p">:</span>     <span class="n">col</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">XK_g</span><span class="p">:</span>     <span class="n">col</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">XK_h</span><span class="p">:</span>     <span class="n">col</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">XK_1</span><span class="p">:</span>     <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">XK_2</span><span class="p">:</span>     <span class="n">row</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">XK_3</span><span class="p">:</span>     <span class="n">row</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">XK_4</span><span class="p">:</span>     <span class="n">row</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">XK_5</span><span class="p">:</span>     <span class="n">row</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">XK_6</span><span class="p">:</span>     <span class="n">row</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">XK_7</span><span class="p">:</span>     <span class="n">row</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">XK_8</span><span class="p">:</span>     <span class="n">row</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span> <span class="k">break</span><span class="p">;
        }</span>

        <span class="n">select_othello_cell</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="mi">7</span><span class="p">)),</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="mi">7</span><span class="p">)));
}</span>
</pre></div>


<a name="x11_moves"></a>
<h4>Making Moves</h4>

<p>When either player makes a move, we need to update the board, figure out whose turn it is or whether the game is over, and if it becomes white's turn we need to compute its next move:</p>

<div class="highlight"><pre><span></span><span class="cm">/* Make a move for the current player and transition the game state. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">make_move</span><span class="p">(</span><span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)
{</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">BLACKS_MOVE</span> <span class="o">||</span> <span class="n">state</span> <span class="o">==</span> <span class="n">WHITES_MOVE</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">BLACKS_MOVE</span><span class="p">) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">othello_is_valid_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_BLACK</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)) {</span>
                        <span class="cm">/* Illegal move; ignored. */</span>
                        <span class="k">return</span><span class="p">;
                }</span>

                <span class="n">othello_make_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_BLACK</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">);</span>
                <span class="n">state</span> <span class="o">=</span> <span class="n">WHITES_MOVE</span><span class="p">;
        }</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">othello_make_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_WHITE</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">);</span>
                <span class="n">state</span> <span class="o">=</span> <span class="n">BLACKS_MOVE</span><span class="p">;
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">othello_has_valid_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_BLACK</span><span class="p">)</span> <span class="o">&amp;&amp;
            !</span><span class="n">othello_has_valid_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_WHITE</span><span class="p">)) {</span>
                <span class="n">state</span> <span class="o">=</span> <span class="n">GAME_OVER</span><span class="p">;
        }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">WHITES_MOVE</span> <span class="o">&amp;&amp;
                   !</span><span class="n">othello_has_valid_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_WHITE</span><span class="p">)) {</span>
                <span class="n">state</span> <span class="o">=</span> <span class="n">BLACKS_MOVE</span><span class="p">;
        }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">BLACKS_MOVE</span> <span class="o">&amp;&amp;
                   !</span><span class="n">othello_has_valid_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_BLACK</span><span class="p">)) {</span>
                <span class="n">state</span> <span class="o">=</span> <span class="n">WHITES_MOVE</span><span class="p">;
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">WHITES_MOVE</span><span class="p">) {</span>
                <span class="n">compute_white_move</span><span class="p">();
        }
}</span>
</pre></div>


<p>When computing white's move, it's important not to do so on the main thread. Doing non-trivial work on the same thread that handles user interface events is a cardinal sin, as it makes the program feel unresponsive and frustrates the user. In our case, we must for example be able to redraw the board if the window is moved.</p>

<p>It turns out that interacting with Xlib from multiple threads is fraught with peril. In particular, I couldn't find a reliable way to send an event from a background thread to the main thread.</p>

<p>Ideally, we would like to be able to wait for two events at the same time: regular X events and notifications that white's move has been computed. Remember that X is a network protocol, so Xlib is using a socket to communicate with the server. We can get the file descriptor for this socket using <span class="code"><a href="https://www.x.org/releases/X11R7.7/doc/libX11/libX11/libX11.html#XConnectionNumber">XConnectionNumber</a></span>, and we can use <span class="code"><a href="https://linux.die.net/man/2/select">select(2)</a></span> to wait for events on that and other file descriptors at the same time.</p>

<p>Therefore, we will use a <span class="code"><a href="https://linux.die.net/man/2/pipe">pipe(2)</a></span> to communicate white's move back to the event loop, and we use <span class="code"><a href="https://linux.die.net/man/2/fork">fork(2)</a></span> to create a separate process for computing the move &mdash; classic Unix inter-process communication:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">int</span> <span class="n">white_move_pipe</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="cm">/* [0] for reading, [1] for writing. */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">compute_white_move</span><span class="p">(</span><span class="kt">void</span><span class="p">)
{</span>
        <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">WHITES_MOVE</span><span class="p">);</span>

        <span class="cm">/* Compute white&#39;s move in a background process. */</span>
        <span class="k">if</span> <span class="p">((</span><span class="n">x</span> <span class="o">=</span> <span class="n">fork</span><span class="p">())</span> <span class="o">== -</span><span class="mi">1</span><span class="p">) {</span>
                <span class="n">err</span><span class="p">(</span><span class="s">&quot;fork() failed: %s&quot;</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));
        }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="cm">/* Parent process. */</span>
                <span class="k">return</span><span class="p">;
        }</span>

        <span class="cm">/* Child process: compute the move and send it through the pipe. */</span>
        <span class="n">othello_compute_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_WHITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">row</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">col</span><span class="p">);</span>
        <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)(</span><span class="n">row</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">col</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">(</span><span class="n">white_move_pipe</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">) {</span>
                <span class="n">err</span><span class="p">(</span><span class="s">&quot;write() failed&quot;</span><span class="p">);
        }</span>

        <span class="n">exit</span><span class="p">(</span><span class="n">EXIT_SUCCESS</span><span class="p">);
}</span>
</pre></div>


<a name="x11_loop"></a>
<h4>Event Loop and main</h4>

<p>The event loop is the heart of our program. It calls <span class="code"><a href="https://www.x.org/releases/X11R7.7/doc/libX11/libX11/libX11.html#XPending">XPending</a></span> to check if there are events ready to be processed, otherwise it uses the technique explained above to wait for either a new event or a white move.</p>

<p>In addition to the mouse and keyboard events described previously, there are some other events we need to handle. <span class="code"><a href="https://www.x.org/releases/X11R7.7/doc/libX11/libX11/libX11.html#ConfigureNotify_Events">ConfigureNotify</a></span> reports changes to a window's configuration (size, position and such), including its initial one. <span class="code"><a href="https://www.x.org/releases/X11R7.7/doc/libX11/libX11/libX11.html#Expose_Events">Expose</a></span> events fire when the window (or part of it) becomes exposed, such as when it is first shown, or if it was previously hidden by another window.</p>

<p>After creating and mapping the window, we will first receive a <span class="code">ConfigureNotify</span> event, then an <span class="code">Expose</span> event, and then we're in business, ready for the user's input.</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">event_loop</span><span class="p">(</span><span class="kt">void</span><span class="p">)
{</span>
        <span class="kt">int</span> <span class="n">display_fd</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">quit</span><span class="p">,</span> <span class="n">draw</span><span class="p">;</span>
        <span class="n">fd_set fds</span><span class="p">;</span>
        <span class="n">XEvent event</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>

        <span class="n">display_fd</span> <span class="o">=</span> <span class="n">XConnectionNumber</span><span class="p">(</span><span class="n">display</span><span class="p">);</span>
        <span class="n">quit</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">draw</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">quit</span><span class="p">) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">draw</span><span class="p">) {</span>
                        <span class="n">draw_grid</span><span class="p">();</span>
                        <span class="n">draw</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;
                }</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">XPending</span><span class="p">(</span><span class="n">display</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {</span>
                        <span class="cm">/* Wait for X event or a white move. */</span>
                        <span class="n">FD_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fds</span><span class="p">);</span>
                        <span class="n">FD_SET</span><span class="p">(</span><span class="n">display_fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fds</span><span class="p">);</span>
                        <span class="n">FD_SET</span><span class="p">(</span><span class="n">white_move_pipe</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">fds</span><span class="p">);</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">select</span><span class="p">(</span><span class="n">max</span><span class="p">(</span><span class="n">display_fd</span><span class="p">,</span> <span class="n">white_move_pipe</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                   <span class="o">&amp;</span><span class="n">fds</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">== -</span><span class="mi">1</span><span class="p">) {</span>
                                <span class="n">err</span><span class="p">(</span><span class="s">&quot;select() failed: %s&quot;</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));
                        }</span>

                        <span class="k">if</span> <span class="p">(</span><span class="n">FD_ISSET</span><span class="p">(</span><span class="n">white_move_pipe</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">fds</span><span class="p">)) {</span>
                                <span class="cm">/* Read white move from the pipe. */</span>
                                <span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="p">(</span><span class="n">white_move_pipe</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">) {</span>
                                        <span class="n">err</span><span class="p">(</span><span class="s">&quot;read() failed&quot;</span><span class="p">);
                                }</span>
                                <span class="n">make_move</span><span class="p">(</span><span class="n">c</span> <span class="o">/</span> <span class="mi">8</span><span class="p">,</span> <span class="n">c</span> <span class="o">%</span> <span class="mi">8</span><span class="p">);</span>
                                <span class="n">draw</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                                <span class="k">continue</span><span class="p">;
                        }
                }</span>

                <span class="n">XNextEvent</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">event</span><span class="p">);</span>

                <span class="k">switch</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">type</span><span class="p">) {</span>
                <span class="k">case</span> <span class="nl">ConfigureNotify</span><span class="p">:</span>
                        <span class="cm">/* The window&#39;s configuration has changed. */</span>
                        <span class="n">compute_grid_position</span><span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">xconfigure</span><span class="p">.</span><span class="n">width</span><span class="p">,</span>
                                              <span class="n">event</span><span class="p">.</span><span class="n">xconfigure</span><span class="p">.</span><span class="n">height</span><span class="p">);</span>
                        <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="nl">Expose</span><span class="p">:</span>
                        <span class="cm">/* The window has become visible. */</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">xexpose</span><span class="p">.</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {</span>
                                <span class="n">draw</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;
                        }</span>
                        <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="nl">MotionNotify</span><span class="p">:</span>
                        <span class="n">on_mouse_move</span><span class="p">();</span>
                        <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="nl">KeyPress</span><span class="p">:</span>
                        <span class="n">on_key_press</span><span class="p">(</span><span class="o">&amp;</span><span class="n">event</span><span class="p">.</span><span class="n">xkey</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">quit</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">draw</span><span class="p">);</span>
                        <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="nl">ButtonPress</span><span class="p">:</span>
                        <span class="n">on_mouse_move</span><span class="p">();</span>
                        <span class="n">on_mouse_click</span><span class="p">();</span>
                        <span class="n">draw</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
                        <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="nl">ClientMessage</span><span class="p">:</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="p">.</span><span class="n">xclient</span><span class="p">.</span><span class="n">data</span><span class="p">.</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">wm_delete_window</span><span class="p">) {</span>
                                <span class="cm">/* Window closed. */</span>
                                <span class="n">quit</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;
                        }</span>
                        <span class="k">break</span><span class="p">;
                }
        }
}</span>
</pre></div>


<p>Finally, <span class="code">main</span> ties it all together: initializing, running the event loop until it's time to quit, and freeing resources in the end.</p>

<div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)
{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">pipe</span><span class="p">(</span><span class="n">white_move_pipe</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="n">err</span><span class="p">(</span><span class="s">&quot;pipe() failed: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">strerror</span><span class="p">(</span><span class="n">errno</span><span class="p">));
        }</span>

        <span class="n">grid</span><span class="p">.</span><span class="n">sel_row</span> <span class="o">= -</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">init</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
        <span class="n">new_game</span><span class="p">();</span>

        <span class="n">event_loop</span><span class="p">();</span>

        <span class="n">XFreeGC</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">black_gc</span><span class="p">);</span>
        <span class="n">XFreeGC</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">white_gc</span><span class="p">);</span>
        <span class="n">XFreeGC</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">board_gc</span><span class="p">);</span>
        <span class="n">XFreeGC</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">highlight_gc</span><span class="p">);</span>
        <span class="n">XFreeFont</span><span class="p">(</span><span class="n">display</span><span class="p">,</span> <span class="n">font</span><span class="p">);</span>
        <span class="n">XCloseDisplay</span><span class="p">(</span><span class="n">display</span><span class="p">);</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;
}</span>
</pre></div>



<a name="x11_build"></a>
<h4>Building</h4>

<p>If it's not already installed, you may need to install Xlib and XPM in order to build the program. On a Debian system:</p>

<div class="highlight"><pre><span></span><span class="gp">$</span> sudo apt-get install libx11-dev libxpm-dev
</pre></div>


<p>To compile, link and run:</p>

<div class="highlight"><pre><span></span><span class="gp">$</span> gcc -O3 -march<span class="o">=</span>native -DNDEBUG othello.c x11_othello.c -lX11 -lXpm -o othello
<span class="gp">$</span> ./othello
</pre></div>


<p>On my machine, it looks like the first of the images below (click for larger versions).</p>

<p>Because it's written in C and has few dependencies, the program should be extremely portable and run on most Unix systems. The second image shows it in the <a href="https://en.wikipedia.org/wiki/Common_Desktop_Environment">Common Desktop Environment</a> on an old version of <a href="https://en.wikipedia.org/wiki/Solaris_%28operating_system%29">Solaris</a>.</p>

<p>It is also possible to run the program on Mac. macOS is based on Unix, but no longer comes with an X server. However, the one that used to be included can be downloaded from <a href="https://www.xquartz.org/">XQuartz.org</a>. Once that's installed, our program can be compiled with:</p>

<div class="highlight"><pre><span></span><span class="gp">$</span> clang -O3 -march<span class="o">=</span>native -DNDEBUG othello.c x11_othello.c <span class="se">\</span>
           -I/usr/X11/include -L/usr/X11/lib -lX11 -lXpm -o othello
</pre></div>


<p>The third image below shows the program running on Mac. Note that it doesn't blend in as well as the native <a href="#mac">Mac port</a>.</p>

<div style="text-align: center">
<a href="gfx/gnome_othello.png"><img src="gfx/gnome_othello_small.png" alt="Screenshot of X11 Othello running in GNOME."></a>
<a href="gfx/solaris_othello.png"><img src="gfx/solaris_othello_small.png" alt="Screenshot of X11 Othello running in the Common Desktop Environment on OpenSolaris."></a>
<a href="gfx/mac_x11_othello.png"><img src="gfx/mac_x11_othello_small.png" alt="Screenshot of X11 Othello running in macOS with XQuartz."></a>
</div>

<a name="win"></a>
<h3>Windows</h3>
<p>Besides a few early years of using MS-DOS, Windows is the operating system I grew up with, and it is still the most widely used OS on desktop computers. After having switched to Linux, using Windows mostly feels cumbersome; however, learning Windows programming does have a certain thrill to it. Perhaps it's the nostalgia, or maybe it's the engineering challenge of overcoming the ugliness and building something useful in a hostile environment &mdash; a little bit of order out of chaos.</p>

<p>Win32, the 32-bit version of the Windows API, was introduced with the release of Windows NT in July 1993. There have been many APIs and technologies for Windows development since (see <a href="https://www.joelonsoftware.com/2004/06/13/how-microsoft-lost-the-api-war/">Joel Spolsky's rant</a>), but Win32 remains the truly native way for applications to interact with Windows.</p>

<p>I used Charles Petzold's <a href="http://www.charlespetzold.com/pw5/">Programming Windows (5th ed.)</a> as a tutorial to Win32. It appears to be out of print, but used copies are easy to buy online. There is a sixth edition available, but that doesn't seem to cover Win32, instead focusing on C# and XAML to build Metro/<a href="https://en.wikipedia.org/wiki/Universal_Windows_Platform_apps">UWP</a> (<a href="https://www.digitaltrends.com/computing/microsoft-universal-apps/">the name keeps changing</a>) apps.</p>



<a name="win_init"></a>
<h4>Initialization and Message Loop</h4>

<p>Graphical Windows programs start in a function called <span class="code"><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms633559.aspx">WinMain</a></span> as opposed to <span class="code">main</span> used by standard C programs. This allows the operating system to pass in a few extra parameters (and tells the linker which <a href="https://msdn.microsoft.com/en-us/library/aa278557.aspx">subsystem</a> to use for the executable). In <a href="files/othello/win_othello.c"><span class="code">win_othello.c</span></a>:</p>

<div class="highlight"><pre><span></span><span class="cp">#define CELL_GAP 1       </span><span class="cm">/* Cell gap in pixels. */</span><span class="cp">
#define MIN_SIZE 300     </span><span class="cm">/* Minimum window size. */</span><span class="cp">
#define INIT_SIZE 450    </span><span class="cm">/* Initial window size. */</span><span class="cp">
#define WM_WHITE_MOVE (WM_USER + 0)</span>

<span class="k">static const</span> <span class="kt">char</span> <span class="n">APP_NAME</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;othello&quot;</span><span class="p">;</span>
<span class="k">static</span> <span class="n">HBRUSH background_brush</span><span class="p">,</span> <span class="n">board_brush</span><span class="p">,</span> <span class="n">highlight_brush</span><span class="p">,</span>
              <span class="n">white_brush</span><span class="p">,</span> <span class="n">black_brush</span><span class="p">;</span>

<span class="k">static</span> <span class="n">othello_t board</span><span class="p">;</span>
<span class="k">static enum</span> <span class="p">{</span> <span class="n">BLACKS_MOVE</span><span class="p">,</span> <span class="n">WHITES_MOVE</span><span class="p">,</span> <span class="n">GAME_OVER</span> <span class="p">}</span> <span class="n">state</span><span class="p">;</span>

<span class="kt">int</span> <span class="n">WINAPI</span> <span class="nf">WinMain</span><span class="p">(</span><span class="n">HINSTANCE instance</span><span class="p">,</span> <span class="n">HINSTANCE prev_instance</span><span class="p">,</span>
                   <span class="n">LPSTR cmd_line</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd_show</span><span class="p">)
{</span>
        <span class="n">WNDCLASS window_class</span><span class="p">;</span>
        <span class="n">HWND window</span><span class="p">;</span>
        <span class="n">HACCEL accelerators</span><span class="p">;</span>
        <span class="n">MSG message</span><span class="p">;</span>
</pre></div>


<p>The <span class="code">instance</span> parameter is a handle to the current instance of the program. It will be used for example when requesting resources from the program, such as the icon. The <span class="code">prev_instance</span> parameter was historically (before 32-bit Windows) used to refer to any already running instance of the program. It is no longer used.</p>

<p>The <span class="code">cmd_line</span> parameter is a <span class="code">char*</span> pointing at the command-line arguments, not including the program name, as a single string. (<a href="https://msdn.microsoft.com/en-us/library/bb776391%28VS.85%29.aspx"><span class="code">CommandLineToArgvW</span></a> allows for getting an argument array instead, similar to <span class="code">argc</span> and <span class="code">argv</span> in regular C programs.)</p>

<p>The <span class="code">cmd_show</span> parameter specifies how the window should be shown initially (minimized, maximized or normal). It will be used when the window is shown later.</p>

<p><span class="code">WINAPI</span> is a macro that expands to <span class="code">__stdcall</span>, a <a href="https://msdn.microsoft.com/en-us/library/984x0h58.aspx">calling convention</a> used by most functions in the Windows API. It specifies that arguments to the function should be passed on the stack like regular C-style (<span class="code">__cdecl</span>) calls, but that the called function must remove the arguments from the stack before returning ("callee cleanup"), relieving the calling function of that responsibility. The idea was probably to allow user programs to save a few instructions by letting the system libraries do the cleanup. (See Raymond Chen's The History of Calling Conventions, part
<a href="https://blogs.msdn.microsoft.com/oldnewthing/20040102-00/?p=41213">1</a>
<a href="https://blogs.msdn.microsoft.com/oldnewthing/20040107-00/?p=41183">2</a>
<a href="https://blogs.msdn.microsoft.com/oldnewthing/20040108-00/?p=41163">3</a>
<a href="https://blogs.msdn.microsoft.com/oldnewthing/20040113-00/?p=41073">4</a>
<a href="https://blogs.msdn.microsoft.com/oldnewthing/20040114-00/?p=41053">5</a>.)
</p>

<p>First we initialize the game state:</p>

<div class="highlight"><pre><span></span>        <span class="n">grid</span><span class="p">.</span><span class="n">sel_row</span> <span class="o">= -</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">new_game</span><span class="p">();</span>
</pre></div>


<p>Then we define <em>brushes</em> for the various colours that will be used. A brush is used when drawing filled shapes like circles or rectangles, and when drawing text. There are also <em>pen</em> objects which are used for drawing outlines, like the border around a square.</p>

<div class="highlight"><pre><span></span>        <span class="n">background_brush</span> <span class="o">=</span> <span class="n">CreateSolidBrush</span><span class="p">(</span><span class="n">GetSysColor</span><span class="p">(</span><span class="n">COLOR_BTNFACE</span><span class="p">));</span>
        <span class="n">board_brush</span>      <span class="o">=</span> <span class="n">CreateSolidBrush</span><span class="p">(</span><span class="n">RGB</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0x80</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">));</span>
        <span class="n">highlight_brush</span>  <span class="o">=</span> <span class="n">CreateSolidBrush</span><span class="p">(</span><span class="n">RGB</span><span class="p">(</span><span class="mh">0x00</span><span class="p">,</span> <span class="mh">0xAA</span><span class="p">,</span> <span class="mh">0x00</span><span class="p">));</span>
        <span class="n">white_brush</span>      <span class="o">=</span> <span class="n">CreateSolidBrush</span><span class="p">(</span><span class="n">RGB</span><span class="p">(</span><span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">,</span> <span class="mh">0xFF</span><span class="p">));</span>
        <span class="n">black_brush</span>      <span class="o">=</span> <span class="n">CreateSolidBrush</span><span class="p">(</span><span class="n">RGB</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
</pre></div>


<p>The <span class="code"><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms633576.aspx">WNDCLASS</a></span> object is used to specify properties of the window we are about to create:</p>

<div class="highlight"><pre><span></span>        <span class="n">window_class</span><span class="p">.</span><span class="n">style</span>         <span class="o">=</span> <span class="n">CS_HREDRAW</span> <span class="o">|</span> <span class="n">CS_VREDRAW</span><span class="p">;</span>
        <span class="n">window_class</span><span class="p">.</span><span class="n">lpfnWndProc</span>   <span class="o">= &amp;</span><span class="n">wnd_proc</span><span class="p">;</span>
        <span class="n">window_class</span><span class="p">.</span><span class="n">cbClsExtra</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">window_class</span><span class="p">.</span><span class="n">cbWndExtra</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">window_class</span><span class="p">.</span><span class="n">hInstance</span>     <span class="o">=</span> <span class="n">instance</span><span class="p">;</span>
        <span class="n">window_class</span><span class="p">.</span><span class="n">hIcon</span>         <span class="o">=</span> <span class="n">LoadIcon</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span>
                                              <span class="n">MAKEINTRESOURCE</span><span class="p">(</span><span class="n">IDI_ICON</span><span class="p">));</span>
        <span class="n">window_class</span><span class="p">.</span><span class="n">hCursor</span>       <span class="o">=</span> <span class="n">LoadCursor</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">IDC_ARROW</span><span class="p">);</span>
        <span class="n">window_class</span><span class="p">.</span><span class="n">hbrBackground</span> <span class="o">=</span> <span class="n">background_brush</span><span class="p">;</span>
        <span class="n">window_class</span><span class="p">.</span><span class="n">lpszMenuName</span>  <span class="o">=</span> <span class="n">MAKEINTRESOURCE</span><span class="p">(</span><span class="n">IDM_MENU</span><span class="p">);</span>
        <span class="n">window_class</span><span class="p">.</span><span class="n">lpszClassName</span> <span class="o">=</span> <span class="n">APP_NAME</span><span class="p">;</span>
</pre></div>


<p>The most important property is <span class="code">lpfnWndProc</span> which specifies the <em>window procedure</em>, a function which handles messages sent to a window of that class. (<span class="code">lpfn</span> stands for "long pointer to function"; Win32 uses <a href="https://en.wikipedia.org/wiki/Hungarian_notation">Hungarian notation</a> for most names.) <span class="code">CS_HREDRAW</span> and <span class="code">CS_VREDRAW</span> specify that the window must be redrawn if the horizontal or vertical size changes. We also specify the cursor and background colour, as well as the icon, which is loaded from a <a href="#win_resources">resource</a> identified as <span class="code">IDI_ICON</span>. The menu is specified by <span class="code">lpszMenuName</span>, referring to another resource, and finally we set <span class="code">lpszClassName</span> which is the name by which we will refer to the window class.</p>

<p>The window class is registered with a call to <span class="code"><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms633586.aspx">RegisterClassA</a></span>, and we create a window of that class with <span class="code"><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms632679.aspx">CreateWindowA</a></span>, specifying the window name (title), initial size, etc.</p>

<div class="highlight"><pre><span></span>        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">RegisterClassA</span><span class="p">(</span><span class="o">&amp;</span><span class="n">window_class</span><span class="p">)) {</span>
                <span class="n">err</span><span class="p">(</span><span class="s">&quot;RegisterClassA failed!&quot;</span><span class="p">);
        }</span>

        <span class="n">window</span> <span class="o">=</span> <span class="n">CreateWindowA</span><span class="p">(</span><span class="n">APP_NAME</span><span class="p">,</span> <span class="s">&quot;Othello&quot;</span><span class="p">,</span> <span class="n">WS_OVERLAPPEDWINDOW</span><span class="p">,</span>
                               <span class="n">CW_USEDEFAULT</span><span class="p">,</span> <span class="n">CW_USEDEFAULT</span><span class="p">,</span>
                               <span class="n">INIT_SIZE</span><span class="p">,</span> <span class="n">INIT_SIZE</span><span class="p">,</span>
                               <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
</pre></div>


<p>Like the two functions called above, many functions in the Win32 API have an <span class="code">A</span> or <span class="code">W</span> suffix. These are function variants that take ASCII or UTF-16 (wide character) strings. There is usually a macro, for example <span class="code">RegisterClass</span>, that expands to the <span class="code">A</span> or <span class="code">W</span> variant based on whether the <span class="code">UNICODE</span> macro is defined. The <span class="code">TEXT</span> (or <span class="code">_T</span>) macros can be used for string literals, for example <span class="code">TEXT("Othello")</span> expands to <span class="code">"Othello"</span> (of type <span class="code">char[]</span>) or <span class="code">L"Othello</span> (of type <span class="code">wchar_t[]</span>) depending on whether <span class="code">UNICODE</span> is defined. The motivation for this clever but confusing mechanism is to allow for building the same program with or without Unicode support based on a single macro. However, modern programs should probably always support Unicode if they accept text input, and referring to functions explicitly by their real name, <span class="code">A</span> or <span class="code">W</span> suffix included, avoids potential confusion about which function is being called. (See the <a href="http://utf8everywhere.org/">UTF-8 Everywhere Manifesto</a>, in particular <a href="http://utf8everywhere.org/#windows">How to do text on Windows</a>.)</p>

<p>Now we are ready to show the window (<span class="code"><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms633548.aspx">ShowWindow</a></span>) and tell it to paint itself (<span class="code"><a href="https://msdn.microsoft.com/en-us/library/dd145167.aspx">UpdateWindow</a></span>):</p>

<div class="highlight"><pre><span></span>        <span class="n">ShowWindow</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">cmd_show</span><span class="p">);</span>
        <span class="n">UpdateWindow</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
</pre></div>


<p>Once the window is ready, the program spends the rest of its lifetime processing messages, or events, in what is called a message loop:</p>

<div class="highlight"><pre><span></span>        <span class="n">accelerators</span> <span class="o">=</span> <span class="n">LoadAccelerators</span><span class="p">(</span><span class="n">instance</span><span class="p">,</span> <span class="n">MAKEINTRESOURCE</span><span class="p">(</span><span class="n">IDA_ACC</span><span class="p">));</span>

        <span class="k">while</span> <span class="p">(</span><span class="n">GetMessage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">message</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">TranslateAccelerator</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">accelerators</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">message</span><span class="p">)) {</span>
                        <span class="n">TranslateMessage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">message</span><span class="p">);</span>
                        <span class="n">DispatchMessage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">message</span><span class="p">);
                }
        }</span>
</pre></div>


<p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms646370.aspx"><span class="code">LoadAccelerators</span></a> loads a table of accelerators, that is, keyboard shortcuts (a resource defined together with the menu). <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms644936.aspx"><span class="code">GetMessage</span></a> waits for and gets the next window message from the application's message queue. It returns a non-zero value unless the message is <span class="code">WM_QUIT</span>, in which case we exit the message loop.</p>

<p>We use <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms646373.aspx"><span class="code">TranslateAccelerator</span></a> to check if the message is the invocation of a keyboard shortcut. If it is, the function will call the window procedure, and we don't need to process the message further here.</p>

<p><a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms644955.aspx"><span class="code">TranslateMessage</span></a> is used to translate keystroke messages to character messages. For example, if an "a" key press message is received while the "shift" key is pressed, <span class="code">TranslateMessage</span> will generate an "A" character message to be fetched with the next <span class="code">GetMessage</span> call. Since our program doesn't accept text input, this isn't strictly necessary, but writing the message loop like this is a standard pattern.</p>

<p>After any "translation", the message is dispatched to the message destination's window procedure with <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms644934.aspx"><span class="code">DispatchMessage</span></a>.</p>

<p>After the message loop, we clean up and exit with the parameter of the <span class="code">WM_QUIT</span> message as status code:</p>

<div class="highlight"><pre><span></span>        <span class="n">DeleteObject</span><span class="p">(</span><span class="n">background_brush</span><span class="p">);</span>
        <span class="n">DeleteObject</span><span class="p">(</span><span class="n">board_brush</span><span class="p">);</span>
        <span class="n">DeleteObject</span><span class="p">(</span><span class="n">highlight_brush</span><span class="p">);</span>
        <span class="n">DeleteObject</span><span class="p">(</span><span class="n">white_brush</span><span class="p">);</span>
        <span class="n">DeleteObject</span><span class="p">(</span><span class="n">black_brush</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">message</span><span class="p">.</span><span class="n">wParam</span><span class="p">;
}</span>
</pre></div>


<a name="win_resources"></a>
<h4>Resources</h4>

<p>Resources are various pieces of data that can be included in an executable (or DLL) file and referred to by programs. In <span class="code">WinMain</span> above, we refer to resources for the program's icon, menu and accelerator table.</p>

<p>The resources we use have numerical identifiers (strings can also be used as identifiers), which we define in a regular header file, <a href="files/othello/win_othello_res.h"><span class="code">win_othello_res.h</span></a>:</p>

<div class="highlight"><pre><span></span><span class="cp">#define IDI_ICON        1
#define IDM_MENU        2
#define IDM_NEW_GAME    3
#define IDM_EXIT        4
#define IDA_ACC         5</span>
</pre></div>


<p>A <em>resource-definition script</em>, <a href="files/othello/win_othello_res.rc"><span class="code">win_othello_res.rc</span></a>, is then used to define the resources:</p>

<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&quot;win_othello_res.h&quot;</span><span class="cp">
#include</span> <span class="cpf">&quot;windows.h&quot;</span><span class="cp"></span>

<span class="n">IDI_ICON ICON</span> <span class="s">&quot;icons/othello.ico&quot;</span>

<span class="n">IDM_MENU MENU
BEGIN
        POPUP</span> <span class="s">&quot;&amp;Game&quot;</span>
        <span class="n">BEGIN
                MENUITEM</span> <span class="s">&quot;&amp;New Game</span><span class="se">\t</span><span class="s">F2&quot;</span><span class="p">,</span> <span class="n">IDM_NEW_GAME
                MENUITEM SEPARATOR
                MENUITEM</span> <span class="s">&quot;E&amp;xit&quot;</span><span class="p">,</span>         <span class="n">IDM_EXIT
        END
END

IDA_ACC ACCELERATORS
BEGIN
        VK_F2</span><span class="p">,</span>  <span class="n">IDM_NEW_GAME</span><span class="p">,</span>   <span class="n">VIRTKEY
END</span>
</pre></div>


<p>The <span class="code">.rc</span> file supports C preprocessor directives like <span class="code">#include</span>, but mainly consists of <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/aa381043.aspx">resource-definition statements</a>. Each such statement defines a resource with a numeric or string id, and type.</p>

<p>The first statement defines an <span class="code">ICON</span> resource with the numerical identifier <span class="code">IDI_ICON</span> (defined as 1 in the header file). Its content is provided by the <span class="code">othello.ico</span> file.</p>

<p>We define a <span class="code">MENU</span> resource with the identifier <span class="code">IDI_MENU</span> to use as our main menu. The sub-statements define the structure and contents of the menu, and numerical identifiers to use when each menu item is activated. (The identifier will be a parameter of a <span class="code">WM_COMMAND</span> message). Using <span class="code">&amp;</span> in a title makes the following character appear underlined and act as a keyboard shortcut. For example, <span class="code">ALT-G</span> will open the "Game" menu.</p>

<p>The <span class="code">ACCELERATORS</span> resource defines keyboard shortcuts and what numeric id to use when they're invoked. In our case we want the <span class="code">F2</span> key to have the same effect as the "New Game" menu option.</p>

<p>These are the most common types of resources, but there are several others, and one can define custom ones to include any kind of data.</p>

<p>To include the resources in our program, the Resource Compiler <span class="code">rc.exe</span> is used to compile the <span class="code">.rc</span> file and its dependencies (like <span class="code">othello.ico</span>) into an intermediate <span class="code">.res</span> file, which the linker will then bake into the executable of the program (see <a href="#win_build">Building</a> below).</p>

<a name="win_draw"></a>
<h4>Drawing</h4>

<p>The drawing strategy is exactly the same as for the X11 port: we use a 10-by-10 grid of equal-size quadratic cells, with the Othello board occupying the middle 8-by-8 cells.</p>

<p>Computing the grid's position and hit testing is done exactly as for X11:</p>

<div class="highlight"><pre><span></span><span class="k">static struct</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>       <span class="cm">/* Position of the grid relative to window origin. */</span>
        <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>       <span class="cm">/* Size (width and height are equal) of the grid. */</span>
        <span class="kt">int</span> <span class="n">cell_size</span><span class="p">;</span>  <span class="cm">/* Size of a grid cell, not including its border. */</span>
        <span class="kt">int</span> <span class="n">sel_row</span><span class="p">;</span>    <span class="cm">/* Currently selected row, or -1 if none. */</span>
        <span class="kt">int</span> <span class="n">sel_col</span><span class="p">;</span>    <span class="cm">/* Currently selected column. */</span>
<span class="p">}</span> <span class="n">grid</span><span class="p">;</span>

<span class="cm">/* Compute the grid&#39;s size and position in the window. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">compute_grid_position</span><span class="p">(</span><span class="kt">int</span> <span class="n">win_width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">win_height</span><span class="p">)
{</span>
        <span class="cm">/* The grid is a 10x10 grid. The 8x8 centre is the Othello
           board, the top row and left column are used for labels, and the
           bottom row for status text. */</span>

        <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">min</span><span class="p">(</span><span class="n">win_width</span><span class="p">,</span> <span class="n">win_height</span><span class="p">)</span> <span class="o">-</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">CELL_GAP</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
        <span class="n">grid</span><span class="p">.</span><span class="n">size</span> <span class="o">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">CELL_GAP</span><span class="p">;</span>
        <span class="n">grid</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">win_width</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">grid</span><span class="p">.</span><span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="n">grid</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">win_height</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">grid</span><span class="p">.</span><span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;
}</span>

<span class="cm">/* Check whether the position is over an Othello cell. */</span>
<span class="k">static</span> <span class="kt">bool</span> <span class="nf">grid_hit_test</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">col</span><span class="p">)
{</span>
        <span class="o">*</span><span class="n">row</span> <span class="o">=</span> <span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">grid</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="o">*</span><span class="n">col</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">grid</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp; *</span><span class="n">row</span> <span class="o">&lt;</span> <span class="mi">8</span> <span class="o">&amp;&amp; *</span><span class="n">col</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp; *</span><span class="n">col</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">) {</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;
        }</span>

        <span class="k">return</span> <span class="nb">false</span><span class="p">;
}</span>
</pre></div>


<p>Drawing is done with a part of the Win32 API called <a href="https://msdn.microsoft.com/en-us/library/dd145203.aspx">GDI</a> (Graphics Device Interface). The drawing commands are performed with reference to a <a href="https://msdn.microsoft.com/en-us/library/dd162467.aspx">Device Context</a> which the system provides for us.</p>

<div class="highlight"><pre><span></span><span class="cm">/* Draw an Othello cell and its contents. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">draw_othello_cell</span><span class="p">(</span><span class="n">HDC dc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)
{</span>
        <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="n">highlight</span><span class="p">;</span>
        <span class="n">cell_state_t cs</span><span class="p">;</span>

        <span class="n">x</span> <span class="o">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="p">);</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="p">);</span>

        <span class="n">highlight</span> <span class="o">=</span> <span class="p">(</span><span class="n">row</span> <span class="o">==</span> <span class="n">grid</span><span class="p">.</span><span class="n">sel_row</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">==</span> <span class="n">grid</span><span class="p">.</span><span class="n">sel_col</span> <span class="o">&amp;&amp;</span>
                     <span class="n">state</span> <span class="o">==</span> <span class="n">BLACKS_MOVE</span><span class="p">);</span>

        <span class="cm">/* Draw the cell background. */</span>
        <span class="n">SelectObject</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">GetStockObject</span><span class="p">(</span><span class="n">NULL_PEN</span><span class="p">));</span>
        <span class="n">SelectObject</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">highlight</span> <span class="o">?</span> <span class="nl">highlight_brush</span> <span class="p">:</span> <span class="n">board_brush</span><span class="p">);</span>
        <span class="n">Rectangle</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">((</span><span class="n">cs</span> <span class="o">=</span> <span class="n">othello_cell_state</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span> <span class="o">!=</span> <span class="n">CELL_EMPTY</span><span class="p">) {</span>
                <span class="cm">/* Draw the disk. */</span>
                <span class="n">SelectObject</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">cs</span> <span class="o">==</span> <span class="n">CELL_BLACK</span> <span class="o">?</span> <span class="nl">black_brush</span> <span class="p">:</span> <span class="n">white_brush</span><span class="p">);</span>
                <span class="n">Ellipse</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="o">+</span> <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span><span class="p">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span><span class="p">);
        }
}</span>

<span class="cm">/* Draw string s of length len centered at (x,y). */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">draw_string</span><span class="p">(</span><span class="n">HDC dc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)
{</span>
        <span class="n">SIZE size</span><span class="p">;</span>

        <span class="n">GetTextExtentPoint32A</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">);</span>
        <span class="n">TextOut</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">x</span> <span class="o">-</span> <span class="n">size</span><span class="p">.</span><span class="n">cx</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">y</span> <span class="o">-</span> <span class="n">size</span><span class="p">.</span><span class="n">cy</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">len</span><span class="p">);
}</span>

<span class="cm">/* Draw the grid and its contents. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">draw_grid</span><span class="p">(</span><span class="n">HDC dc</span><span class="p">)
{</span>
        <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">bs</span><span class="p">,</span> <span class="n">ws</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">status</span><span class="p">[</span><span class="mi">128</span><span class="p">];</span>

        <span class="cm">/* Draw a background square around the 8x8 centre cells. */</span>
        <span class="n">SelectObject</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">GetStockObject</span><span class="p">(</span><span class="n">NULL_PEN</span><span class="p">));</span>
        <span class="n">SelectObject</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">black_brush</span><span class="p">);</span>
        <span class="n">Rectangle</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">grid</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span><span class="p">,</span>
                      <span class="n">grid</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span><span class="p">,</span>
                      <span class="n">grid</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">+</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">CELL_GAP</span><span class="p">,</span>
                      <span class="n">grid</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">+</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">CELL_GAP</span><span class="p">);</span>

        <span class="cm">/* Draw labels. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="p">)</span> <span class="o">+</span>
                        <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
                <span class="n">draw_string</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="o">&amp;</span><span class="s">&quot;12345678&quot;</span><span class="p">[</span><span class="n">row</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);

        }</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">col</span><span class="o">++</span><span class="p">) {</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="p">)</span> <span class="o">+</span>
                        <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
                <span class="n">draw_string</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="o">&amp;</span><span class="s">&quot;ABCDEFGH&quot;</span><span class="p">[</span><span class="n">col</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);
        }</span>

        <span class="cm">/* Draw status text. */</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">) {</span>
        <span class="k">case</span> <span class="nl">BLACKS_MOVE</span><span class="p">:</span>
                <span class="n">sprintf</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;Human&#39;s move.&quot;</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">WHITES_MOVE</span><span class="p">:</span>
                <span class="n">sprintf</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;Computer&#39;s move..&quot;</span><span class="p">);</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">GAME_OVER</span><span class="p">:</span>
                <span class="n">bs</span> <span class="o">=</span> <span class="n">othello_score</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_BLACK</span><span class="p">);</span>
                <span class="n">ws</span> <span class="o">=</span> <span class="n">othello_score</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_WHITE</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">bs</span> <span class="o">&gt;</span> <span class="n">ws</span><span class="p">) {</span>
                        <span class="n">sprintf</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;Human wins %d-%d!&quot;</span><span class="p">,</span> <span class="n">bs</span><span class="p">,</span> <span class="n">ws</span><span class="p">);
                }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">ws</span> <span class="o">&gt;</span> <span class="n">bs</span><span class="p">) {</span>
                        <span class="n">sprintf</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;Computer wins %d-%d!&quot;</span><span class="p">,</span> <span class="n">ws</span><span class="p">,</span> <span class="n">bs</span><span class="p">);
                }</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="n">sprintf</span><span class="p">(</span><span class="n">status</span><span class="p">,</span> <span class="s">&quot;Draw!&quot;</span><span class="p">);
                }
        }</span>
        <span class="n">draw_string</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">status</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">status</span><span class="p">),</span> <span class="n">grid</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">grid</span><span class="p">.</span><span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                    <span class="n">grid</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">grid</span><span class="p">.</span><span class="n">size</span> <span class="o">-</span> <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>

        <span class="cm">/* Draw cells. */</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">) {</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">col</span><span class="o">++</span><span class="p">) {</span>
                        <span class="n">draw_othello_cell</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">);
                }
        }
}</span>
</pre></div>


<a name="win_events"></a>
<h4>Handling Events</h4>

<p>Separate functions are used to handle events that need more than a few lines of code to process. We call <a href="https://msdn.microsoft.com/en-us/library/dd145002.aspx"><span class="code">InvalidateRect</span></a> when the window needs repainting, causing the system to send us a <span class="code">WM_PAINT</span> message.</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">new_game</span><span class="p">(</span><span class="kt">void</span><span class="p">)
{</span>
        <span class="n">othello_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">);</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">BLACKS_MOVE</span><span class="p">;
}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">on_mouse_click</span><span class="p">(</span><span class="n">HWND window</span><span class="p">)
{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">GAME_OVER</span><span class="p">) {</span>
                <span class="n">new_game</span><span class="p">();</span>
                <span class="n">InvalidateRect</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">BLACKS_MOVE</span> <span class="o">&amp;&amp;</span> <span class="n">grid</span><span class="p">.</span><span class="n">sel_row</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="n">make_move</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">grid</span><span class="p">.</span><span class="n">sel_row</span><span class="p">,</span> <span class="n">grid</span><span class="p">.</span><span class="n">sel_col</span><span class="p">);
        }
}</span>
</pre></div>


<p>When a cell is selected, we take care to only invalidate that part of the window, and not clear (the <span class="code">false</span> argument) but to paint over it. When only part of the window is invalidated, the next <span class="code">WM_PAINT</span> message will run as usual, but only the painting operations inside the invalidated area will be applied. This avoids flickering from repainting the whole window each time a new cell is selected.</p>

<div class="highlight"><pre><span></span><span class="cm">/* Invalidate an Othello cell, causing it to be repainted. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">invalidate_othello_cell</span><span class="p">(</span><span class="n">HWND window</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)
{</span>
        <span class="n">RECT r</span><span class="p">;</span>

        <span class="n">r</span><span class="p">.</span><span class="n">left</span> <span class="o">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="p">(</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="p">);</span>
        <span class="n">r</span><span class="p">.</span><span class="n">top</span> <span class="o">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="p">(</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="p">);</span>
        <span class="n">r</span><span class="p">.</span><span class="n">right</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">left</span> <span class="o">+</span> <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span><span class="p">;</span>
        <span class="n">r</span><span class="p">.</span><span class="n">bottom</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">top</span> <span class="o">+</span> <span class="n">grid</span><span class="p">.</span><span class="n">cell_size</span><span class="p">;</span>

        <span class="n">InvalidateRect</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">,</span> <span class="nb">false</span><span class="p">);
}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">select_othello_cell</span><span class="p">(</span><span class="n">HWND window</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)
{</span>
        <span class="kt">int</span> <span class="n">old_row</span> <span class="o">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">sel_row</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">old_col</span> <span class="o">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">sel_col</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">==</span> <span class="n">old_row</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">==</span> <span class="n">old_col</span><span class="p">) {</span>
                <span class="cm">/* This cell is already selected. */</span>
                <span class="k">return</span><span class="p">;
        }</span>

        <span class="n">grid</span><span class="p">.</span><span class="n">sel_row</span> <span class="o">=</span> <span class="n">row</span><span class="p">;</span>
        <span class="n">grid</span><span class="p">.</span><span class="n">sel_col</span> <span class="o">=</span> <span class="n">col</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">old_row</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="cm">/* Re-draw the previously selected cell. */</span>
                <span class="n">invalidate_othello_cell</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">old_row</span><span class="p">,</span> <span class="n">old_col</span><span class="p">);
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">) {</span>
                <span class="cm">/* Need to draw the newly selected cell. */</span>
                <span class="n">invalidate_othello_cell</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">);
        }
}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">on_key_press</span><span class="p">(</span><span class="n">HWND window</span><span class="p">,</span> <span class="n">WPARAM wparam</span><span class="p">)
{</span>
        <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">;</span>

        <span class="n">row</span> <span class="o">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">sel_row</span><span class="p">;</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">grid</span><span class="p">.</span><span class="n">sel_col</span><span class="p">;</span>

        <span class="k">switch</span> <span class="p">(</span><span class="n">wparam</span><span class="p">) {</span>
        <span class="k">default</span><span class="o">:</span>
               <span class="k">return</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">VK_SPACE</span><span class="p">:</span>
        <span class="k">case</span> <span class="nl">VK_RETURN</span><span class="p">:</span>
                <span class="n">on_mouse_click</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;</span>

        <span class="k">case</span> <span class="nl">VK_RIGHT</span><span class="p">:</span> <span class="n">col</span><span class="o">++</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">VK_LEFT</span><span class="p">:</span>  <span class="n">col</span><span class="o">--</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">VK_DOWN</span><span class="p">:</span>  <span class="n">row</span><span class="o">++</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="nl">VK_UP</span><span class="p">:</span>    <span class="n">row</span><span class="o">--</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="sc">&#39;A&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;B&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;C&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;D&#39;</span><span class="o">:</span>
        <span class="k">case</span> <span class="sc">&#39;E&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;F&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;G&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;H&#39;</span><span class="o">:</span>
                <span class="n">col</span> <span class="o">=</span> <span class="n">wparam</span> <span class="o">-</span> <span class="sc">&#39;A&#39;</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="sc">&#39;1&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;2&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;3&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;4&#39;</span><span class="o">:</span>
        <span class="k">case</span> <span class="sc">&#39;5&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;6&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;7&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;8&#39;</span><span class="o">:</span>
                <span class="n">row</span> <span class="o">=</span> <span class="n">wparam</span> <span class="o">-</span> <span class="sc">&#39;1&#39;</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;
        }</span>

        <span class="n">select_othello_cell</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="mi">7</span><span class="p">)),</span> <span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">min</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="mi">7</span><span class="p">)));
}</span>
</pre></div>


<p>Events, or messages, are processed by the window procedure, which in our program is implemented by the <span class="code">wnd_proc</span> function.</p>

<p>Each message can take two mysteriously named parameters, <span class="code">wparam</span> and <span class="code">lparam</span>. The names are historical: before 32-bit Windows, the procedure used to take a 16-bit "word" parameter, used for handles and integers, and a 32-bit "long" parameter, used for pointers. With the introduction of Win32, both parameters became 32-bit values. (See <a href="https://blogs.msdn.microsoft.com/oldnewthing/20031125-00/?p=41713">Raymond Chen</a>.)</p>

<p>The <span class="code">CALLBACK</span> macro sets the calling convention to <span class="code">__stdcall</span>, just as <span class="code">WINAPI</span> did for <span class="code">WinMain</span>. Again, the different macros exist for historical reasons; on 16-bit Windows they expanded to different things.</p>

<p><span class="code">LRESULT</span> is just a macro which expands to <span class="code">long</span>. The appropriate return value depends on the message type, but returning zero usually means we processed the message successfully.</p>


<div class="highlight"><pre><span></span><span class="k">static</span> <span class="n">LRESULT CALLBACK</span> <span class="nf">wnd_proc</span><span class="p">(</span><span class="n">HWND window</span><span class="p">,</span> <span class="n">UINT message</span><span class="p">,</span> <span class="n">WPARAM wparam</span><span class="p">,</span>
                                 <span class="n">LPARAM lparam</span><span class="p">)
{</span>
        <span class="n">HDC dc</span><span class="p">;</span>
        <span class="n">PAINTSTRUCT ps</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">;</span>

        <span class="k">switch</span> <span class="p">(</span><span class="n">message</span><span class="p">) {</span>
        <span class="k">case</span> <span class="nl">WM_SIZE</span><span class="p">:</span>
                <span class="cm">/* The window size changed. */</span>
                <span class="n">compute_grid_position</span><span class="p">(</span><span class="n">LOWORD</span><span class="p">(</span><span class="n">lparam</span><span class="p">),</span> <span class="n">HIWORD</span><span class="p">(</span><span class="n">lparam</span><span class="p">));</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">case</span> <span class="nl">WM_GETMINMAXINFO</span><span class="p">:</span>
                <span class="cm">/* Windows is asking about the size constraints. */</span>
                <span class="p">((</span><span class="n">MINMAXINFO</span><span class="o">*</span><span class="p">)</span><span class="n">lparam</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ptMinTrackSize</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">MIN_SIZE</span><span class="p">;
                ((</span><span class="n">MINMAXINFO</span><span class="o">*</span><span class="p">)</span><span class="n">lparam</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ptMinTrackSize</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">MIN_SIZE</span><span class="p">;</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">case</span> <span class="nl">WM_PAINT</span><span class="p">:</span>
                <span class="cm">/* The window needs a re-paint. */</span>
                <span class="n">EnableMenuItem</span><span class="p">(</span><span class="n">GetMenu</span><span class="p">(</span><span class="n">window</span><span class="p">),</span> <span class="n">IDM_NEW_GAME</span><span class="p">,</span>
                               <span class="n">state</span> <span class="o">!=</span> <span class="n">WHITES_MOVE</span> <span class="o">?</span> <span class="nl">MF_ENABLED</span> <span class="p">:</span> <span class="n">MF_GRAYED</span><span class="p">);</span>
                <span class="n">dc</span> <span class="o">=</span> <span class="n">BeginPaint</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ps</span><span class="p">);</span>
                <span class="n">SetBkMode</span><span class="p">(</span><span class="n">dc</span><span class="p">,</span> <span class="n">TRANSPARENT</span><span class="p">);</span>
                <span class="n">draw_grid</span><span class="p">(</span><span class="n">dc</span><span class="p">);</span>
                <span class="n">EndPaint</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ps</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">case</span> <span class="nl">WM_MOUSEMOVE</span><span class="p">:</span>
                <span class="cm">/* The mouse moved. */</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">grid_hit_test</span><span class="p">(</span><span class="n">LOWORD</span><span class="p">(</span><span class="n">lparam</span><span class="p">),</span> <span class="n">HIWORD</span><span class="p">(</span><span class="n">lparam</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">row</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">col</span><span class="p">)) {</span>
                        <span class="n">select_othello_cell</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">);
                }</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="n">select_othello_cell</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);
                }</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">case</span> <span class="nl">WM_LBUTTONUP</span><span class="p">:</span>
                <span class="cm">/* Left mouse button up. */</span>
                <span class="n">on_mouse_click</span><span class="p">(</span><span class="n">window</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">case</span> <span class="nl">WM_KEYDOWN</span><span class="p">:</span>
                <span class="cm">/* Keyboard key down. */</span>
                <span class="n">on_key_press</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">wparam</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">case</span> <span class="nl">WM_COMMAND</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">lparam</span> <span class="o">==</span> <span class="mi">0</span><span class="p">) {</span>
                        <span class="cm">/* Menu item activated. */</span>
                        <span class="k">switch</span> <span class="p">(</span><span class="n">LOWORD</span><span class="p">(</span><span class="n">wparam</span><span class="p">)) {</span>
                        <span class="k">case</span> <span class="nl">IDM_NEW_GAME</span><span class="p">:</span>
                                <span class="n">assert</span><span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">WHITES_MOVE</span><span class="p">);</span>
                                <span class="n">new_game</span><span class="p">();</span>
                                <span class="n">InvalidateRect</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);</span>
                                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

                        <span class="k">case</span> <span class="nl">IDM_EXIT</span><span class="p">:</span>
                                <span class="n">PostQuitMessage</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
                                <span class="k">return</span> <span class="mi">0</span><span class="p">;
                        }
                }</span>
                <span class="k">break</span><span class="p">;</span>

        <span class="k">case</span> <span class="nl">WM_WHITE_MOVE</span><span class="p">:</span>
                <span class="cm">/* White computed a move. */</span>
                <span class="n">assert</span><span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">WHITES_MOVE</span><span class="p">);</span>
                <span class="n">make_move</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">wparam</span><span class="p">,</span> <span class="n">lparam</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">case</span> <span class="nl">WM_DESTROY</span><span class="p">:</span>
                <span class="cm">/* The window is closing. */</span>
                <span class="n">PostQuitMessage</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
                <span class="k">return</span> <span class="mi">0</span><span class="p">;
        }</span>

        <span class="k">return</span> <span class="n">DefWindowProc</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="n">wparam</span><span class="p">,</span> <span class="n">lparam</span><span class="p">);
}</span>
</pre></div>


<a name="win_moves"></a>
<h4>Making Moves</h4>

<p>The code for updating the game state with a new move is almost exactly the same as for the X11 version:</p>

<div class="highlight"><pre><span></span><span class="cm">/* Make a move for the current player and transition the game state. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">make_move</span><span class="p">(</span><span class="n">HWND window</span><span class="p">,</span> <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="kt">int</span> <span class="n">col</span><span class="p">)
{</span>
        <span class="n">assert</span><span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">BLACKS_MOVE</span> <span class="o">||</span> <span class="n">state</span> <span class="o">==</span> <span class="n">WHITES_MOVE</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">BLACKS_MOVE</span><span class="p">) {</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">othello_is_valid_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_BLACK</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)) {</span>
                        <span class="cm">/* Illegal move; ignored. */</span>
                        <span class="k">return</span><span class="p">;
                }</span>

                <span class="n">othello_make_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_BLACK</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">);</span>
                <span class="n">state</span> <span class="o">=</span> <span class="n">WHITES_MOVE</span><span class="p">;
        }</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">othello_make_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_WHITE</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">);</span>
                <span class="n">state</span> <span class="o">=</span> <span class="n">BLACKS_MOVE</span><span class="p">;
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">othello_has_valid_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_BLACK</span><span class="p">)</span> <span class="o">&amp;&amp;
            !</span><span class="n">othello_has_valid_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_WHITE</span><span class="p">)) {</span>
                <span class="n">state</span> <span class="o">=</span> <span class="n">GAME_OVER</span><span class="p">;
        }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">WHITES_MOVE</span> <span class="o">&amp;&amp;
                   !</span><span class="n">othello_has_valid_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_WHITE</span><span class="p">)) {</span>
                <span class="n">state</span> <span class="o">=</span> <span class="n">BLACKS_MOVE</span><span class="p">;
        }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">BLACKS_MOVE</span> <span class="o">&amp;&amp;
                   !</span><span class="n">othello_has_valid_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_BLACK</span><span class="p">)) {</span>
                <span class="n">state</span> <span class="o">=</span> <span class="n">WHITES_MOVE</span><span class="p">;
        }</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">WHITES_MOVE</span><span class="p">) {</span>
                <span class="n">_beginthread</span><span class="p">(</span><span class="n">compute_white_move</span><span class="p">,</span> <span class="mi">0</span><span class="p">, (</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">window</span><span class="p">);
        }</span>

        <span class="n">InvalidateRect</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">TRUE</span><span class="p">);
}</span>
</pre></div>


<p>One thing that's different is how we compute white's move. On Windows, it's easy to send a message from one thread to another in a safe way, so that's what we do. <a href="https://msdn.microsoft.com/en-us/library/kdzttdcb.aspx"><span class="code">_beginthread</span></a> starts execution of <span class="code">compute_white_move</span> on a new thread. When the computation is done, it simply sends a message to our window that we handle in the message loop:</p>

<div class="highlight"><pre><span></span><span class="k">static</span> <span class="kt">void</span> <span class="nf">compute_white_move</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">window</span><span class="p">)
{</span>
        <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">;</span>

        <span class="n">assert</span><span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">WHITES_MOVE</span><span class="p">);</span>

        <span class="n">othello_compute_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_WHITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">row</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">col</span><span class="p">);</span>
        <span class="n">SendMessage</span><span class="p">((</span><span class="n">HWND</span><span class="p">)</span><span class="n">window</span><span class="p">,</span> <span class="n">WM_WHITE_MOVE</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">);
}</span>
</pre></div>


<p><span class="code">WM_WHITE_MOVE</span> is a message number that we defined ourselves, based on the <a href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms644931.aspx"><span class="code">WM_USER</span></a> macro. We exploit the fact that messages take two parameters, and pass the computed row in <span class="code">wparam</span> and the column in <span class="code">lparam</span>.</p>

<p>We have to take care to make sure our program is thread safe. While <span class="code">compute_white_move</span> accesses the Othello board on its thread, the main thread must not be allowed to change the board. The code makes sure that while in the <span class="code">WHITES_MOVE</span> state, the board is never changed until the <span class="code">WM_WHITE_MOVE</span> message is received. Note that for this reason, the "New Game" menu option is disabled when it's white's turn.</p>

<a name="win_build"></a>
<h4>Building</h4>

<p>The program can be built with the compiler from Visual Studio (I used the free version, <a href="https://www.visualstudio.com/en-us/products/visual-studio-express-vs.aspx">Visual Studio Express</a>) by running the following commands in a Visual Studio Developer Command Prompt (the name varies a little between versions, but it should be available in the Start menu, somewhere in the Visual Studio folder).</p>

<p>First we compile the resource file to a <span class="code">.res</span> file:</p>

<div class="highlight"><pre><span></span>C:\othello&gt;rc win_othello_res.rc
Microsoft (R) Windows (R) Resource Compiler Version 10.0.10011.16384
Copyright (C) Microsoft Corporation.  All rights reserved.
</pre></div>


<p>Next, the C files are compiled. <span class="code">/Ox</span> means maximum optimization and <span class="code">/DNDEBUG</span> disables the asserts. <span class="code">/MT</span> makes our program link statically against the C run-time library, which means we don't need to distribute the C run-time DLL with our executable.</p>

<div class="highlight"><pre><span></span>C:\othello&gt;cl /c /Ox /DNDEBUG /MT win_othello.c othello.c
Microsoft (R) C/C++ Optimizing Compiler Version 19.00.23506 for x86
Copyright (C) Microsoft Corporation.  All rights reserved.

win_othello.c
othello.c
Generating Code...
</pre></div>


<p>And finally we link it all together into an executable:</p>

<div class="highlight"><pre><span></span>C:\othello&gt;link /out:othello.exe win_othello.obj othello.obj win_othello_res.res
 user32.lib gdi32.lib
Microsoft (R) Incremental Linker Version 14.00.23506.0
Copyright (C) Microsoft Corporation.  All rights reserved.
</pre></div>


<p>This creates an executable that will run on Windows Vista or later. However, our code is not using any new fancy APIs &mdash; in fact everything it uses was present in Win32 from the very beginning. Would it be possible to build our program so that it runs on <em>all</em> versions of Windows that support Win32?</p>

<p>The problem is that the libraries in current versions of the Windows SDK only work with Windows XP and later, as they end up referencing functionality that was not present in older versions of Windows. We need an older SDK. The <a href="https://en.wikipedia.org/wiki/Microsoft_Windows_SDK">Wikipedia article</a> provides some download links, but another way is to install an older version of Visual Studio, as they include contemporary SDKs.</p>

<p>I used "Visual C++ .NET Standard 2003". Unfortunately, despite the year it was released in, the included compiler cannot handle basic C99 features (such as <span class="code">stdint.h</span>) that are used in the Othello program. But since all we wanted was the libraries, we can use <a href="http://clang.llvm.org/">Clang</a> for the actual compilation.</p>

<p>In a Visual Studio .NET 2003 Command Prompt:</p>

<div class="highlight"><pre><span></span>C:\othello&gt;rc win_othello_res.rc

C:\othello&gt;clang-cl /c /Ox /DNDEBUG /MT /arch:IA32 win_othello.c othello.c

C:\othello&gt;link /out:othello.exe win_othello.obj othello.obj win_othello_res.res
 user32.lib gdi32.lib
Microsoft (R) Incremental Linker Version 7.10.3077
Copyright (C) Microsoft Corporation.  All rights reserved.
</pre></div>


<p>That produces an executable that will run on Windows NT 4.0 or later. However, the binary might still work if we could convince older versions of Windows to load it. This is determined by the subsystem version field in the PE header of the executable (see <a href="making-executables.html#pe">Ones and Zeros, Part 2: Executables</a>), and we can change it to 3.10, the version number of the first Windows NT release, like this:</p>

<div class="highlight"><pre><span></span>C:\othello&gt;editbin /subsystem:windows,3.10 othello.exe
Microsoft (R) COFF/PE Editor Version 7.10.3077
Copyright (C) Microsoft Corporation.  All rights reserved.
</pre></div>


<p>It works! The screenshots below show the executable running on Windows NT 3.51 and Windows 10, versions that were released more than twenty years apart. For some reason, I find this extremely satisfying. (Perhaps in this sense, our executable is a lot more universal than programs using the newfangled Universal Windows Platform model?)</p>

<div style="text-align: center">
<a href="gfx/nt_othello.png"><img src="gfx/nt_othello_small.png" alt="Screenshot of Othello running on Windows NT 3.51."></a>
<a href="gfx/win10_othello.png"><img src="gfx/win10_othello_small.png" alt="Screenshot of Othello running on Windows 10."></a>
</div>

<p>The Windows executable can also be built on Linux using the <a href="http://mingw-w64.org/">mingw-w64</a> toolchain:</p>

<div class="highlight"><pre><span></span><span class="gp">$</span> sudo apt-get install mingw-w64
<span class="gp">$</span> i686-w64-mingw32-windres win_othello_res.rc win_othello_res.o
<span class="gp">$</span> i686-w64-mingw32-gcc -O3 -DNDEBUG othello.c win_othello.c win_othello_res.o <span class="se">\</span>
                -o othello.exe -luser32 -lgdi32 -mwindows
</pre></div>



<a name="mac"></a>
<h3>Mac</h3>

<p>Applications for macOS (originally called Mac OS X and later just OS X) have traditionally been written in Objective-C using the Cocoa framework. The history of this operating system is quite fascinating, and Amit Singh provides an excellent account of it in the online <a href="https://web.archive.org/web/20170717175311/http://osxbook.com/book/bonus/chapter1/">extended version</a> of the first chapter of his book, <a href="https://web.archive.org/web/20170717175311/http://osxbook.com/">Mac OS X Internals</a>.</p>

<p><a href="https://en.wikipedia.org/wiki/Objective-C">Objective-C</a> is a <a href="https://en.wikipedia.org/wiki/Smalltalk">Smalltalk</a>-inspired object-oriented extension of C created by Brad Cox and Tom Love in the eighties. It was licensed by <a href="https://en.wikipedia.org/wiki/NeXT">NeXT</a>, Steve Jobs's start-up after his ejection from Apple, for use in their <a href="https://en.wikipedia.org/wiki/NeXTSTEP">NeXTSTEP</a> operating system. After Apple's acquisition of NeXT, much of the software ended up in Mac OS X, including the use of Objective-C and the software "kits" which became <a href="https://en.wikipedia.org/wiki/Cocoa_%28API%29">Cocoa</a>. (<a href="https://stackoverflow.com/a/903647">One plausible theory</a> is that the name is a play on Java, considered hot stuff at the time, and a way to recycle the trademark of <a href="https://www.youtube.com/watch?v=NtmGTrr3R-E">an old Cocoa product</a>.)</p>

<p>As opposed to C, C++, and other languages that are standardised by organizations such as ISO, Objective-C is implementation defined: the language is what the toolchain in Xcode implements. There are plenty of <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/Introduction/Introduction.html">guides</a> and such, but frustratingly there is no actual language specification.</p>

<p>(In 2014, Apple introduced the <a href="https://en.wikipedia.org/wiki/Swift_%28programming_language%29">Swift</a> programming language, which seems to have become the language of choice for new development on Mac. However, I'm sticking with Objective-C here because I was curious about its history and I run into it at work sometimes.)</p>

<p>To learn about Mac programming, I mainly used the fourth edition (the last one based on Objective-C) of Hillegass &amp; Preble "Cocoa Programming For Mac OS X" (Addison-Wesley 2012). I also read parts of Amit Singh's <a href="https://web.archive.org/web/20170717175311/http://osxbook.com/">Mac OS X Internals</a>, some of Brad Cox's "Object Oriented Programming: An Evolutionary Approach" (Addison-Wesley 1986) which is the original description of the language, and I peeked in David Chisnall's "Cocoa Programming Developer's Handbook" (Addison-Wesley 2009) which is not new but very rich in technical detail.</p>

<a name="mac_anatomy"></a>
<h4>Anatomy of a Mac Application</h4>

<p>On Linux and Windows, our Othello programs consist of a single executable file. On Mac however, most apps consist of multiple files that make up an <em>application bundle</em>.</p>

<p>A <a href="https://developer.apple.com/library/content/documentation/CoreFoundation/Conceptual/CFBundles/Introduction/Introduction.html"><em>bundle</em></a> is a directory that gets special treatment from the operating system due to its filename extension, such as <span class="code">.app</span> for application bundles. For example, our application will be a directory called <span class="code">Othello.app</span>. In Finder, it looks like a single file called <span class="code">Othello</span>, and starts when double-clicked on, but in a terminal we can see that it is just a directory of files:</p>

<div style="text-align: center">
<img src="gfx/othello_bundle_finder.png" alt="Screenshot of the Othello bundle as shown in Finder.">
<img src="gfx/othello_bundle_console.png" alt="Screenshot of the Othello bundle when listed in a terminal.">
</div>

<p>(To start the application bundle from a terminal, run <span class="code">open Othello.app</span>. To see the contents of a bundle in Finder, Ctrl-click on it and select Show Package Contents.)</p>

<p>Bundles are a nice way to keep applications in a self-contained package. Installing a program on macOS usually just means dragging the bundle into the Applications folder.</p>

<p>Inside the bundle is an <em><a href="https://developer.apple.com/library/content/documentation/General/Reference/InfoPlistKeyReference/Introduction/Introduction.html">information property list</a></em>, <a href="files/othello/mac/Info.plist"><span class="code">Info.plist</span></a>, which contains metadata about the bundle:</p>

<div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE plist PUBLIC &quot;-//Apple//DTD PLIST 1.0//EN&quot;
&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;&gt;</span>
<span class="nt">&lt;plist</span> <span class="na">version=</span><span class="s">&quot;1.0&quot;</span><span class="nt">&gt;
&lt;dict&gt;
	&lt;key&gt;</span>CFBundleDevelopmentRegion<span class="nt">&lt;/key&gt;
	&lt;string&gt;</span>en<span class="nt">&lt;/string&gt;
	&lt;key&gt;</span>CFBundleDisplayName<span class="nt">&lt;/key&gt;
	&lt;string&gt;</span>Othello<span class="nt">&lt;/string&gt;
	&lt;key&gt;</span>CFBundleExecutable<span class="nt">&lt;/key&gt;
	&lt;string&gt;</span>Othello<span class="nt">&lt;/string&gt;
	&lt;key&gt;</span>CFBundleIconFile<span class="nt">&lt;/key&gt;
	&lt;string&gt;</span>Othello<span class="nt">&lt;/string&gt;
	&lt;key&gt;</span>CFBundleIdentifier<span class="nt">&lt;/key&gt;
	&lt;string&gt;</span>net.hanshq.Othello<span class="nt">&lt;/string&gt;
	&lt;key&gt;</span>CFBundleInfoDictionaryVersion<span class="nt">&lt;/key&gt;
	&lt;string&gt;</span>6.0<span class="nt">&lt;/string&gt;
	&lt;key&gt;</span>CFBundleName<span class="nt">&lt;/key&gt;
	&lt;string&gt;</span>Othello<span class="nt">&lt;/string&gt;
	&lt;key&gt;</span>CFBundlePackageType<span class="nt">&lt;/key&gt;
	&lt;string&gt;</span>APPL<span class="nt">&lt;/string&gt;
	&lt;key&gt;</span>CFBundleShortVersionString<span class="nt">&lt;/key&gt;
	&lt;string&gt;</span>1.2<span class="nt">&lt;/string&gt;
	&lt;key&gt;</span>CFBundleVersion<span class="nt">&lt;/key&gt;
	&lt;string&gt;</span>1.2<span class="nt">&lt;/string&gt;
	&lt;key&gt;</span>NSHumanReadableCopyright<span class="nt">&lt;/key&gt;
	&lt;string&gt;</span>Copyright © 2017 Hans Wennborg<span class="nt">&lt;/string&gt;
	&lt;key&gt;</span>NSMainNibFile<span class="nt">&lt;/key&gt;
	&lt;string&gt;</span>MainMenu<span class="nt">&lt;/string&gt;
	&lt;key&gt;</span>NSPrincipalClass<span class="nt">&lt;/key&gt;
	&lt;string&gt;</span>NSApplication<span class="nt">&lt;/string&gt;
	&lt;key&gt;</span>LSMinimumSystemVersion<span class="nt">&lt;/key&gt;
	&lt;string&gt;</span>10.7<span class="nt">&lt;/string&gt;
&lt;/dict&gt;
&lt;/plist&gt;</span>
</pre></div>


<p>The file specifies things like version number, icon (<span class="code">Othello.icns</span> from the <span class="code">Contents/Resources</span> folder in the bundle), and most importantly, which executable to run when starting the application. In our case, the executable is called <span class="code">Othello</span> (in the <span class="code">Contents/MacOS</span> folder), and its main function is defined in <a href="files/othello/mac/main.m"><span class="code">main.m</span></a>:</p>

<div class="highlight"><pre><span></span><span class="cp">#import &lt;Cocoa/Cocoa.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">) {</span>
    <span class="k">return</span> <span class="n">NSApplicationMain</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);
}</span>
</pre></div>


<p>This is an Objective-C source file (its extension is <span class="code">.m</span>), but it doesn't really use any Objective-C features: <span class="code">main</span> is the usual function from C, and it contains a regular function call and return statement. However, it does include an Objective-C header, <span class="code">Cocoa.h</span> (for the declaration of <span class="code">NSApplicationMain</span>). Objective-C headers are normally included with an <span class="code">#import</span> directive, which is a language extension that works just like <span class="code">#include</span> except that it guarantees to only include the file once, without any need for <a href="https://en.wikipedia.org/wiki/Include_guard">include guards</a>.</p>

<p>(It's not entirely clear why Objective-C uses <span class="code">.m</span> as the file extension. <a href="https://web.archive.org/web/20180103073843/http://www.cocoabuilder.com/archive/cocoa/80101-ot-meaning-of-extension.html#80102">The best theory</a> indicates that it is for "messages", a core concept in Objective-C.)</p>

<p>The only thing <span class="code">main</span> does is call on <a href="https://developer.apple.com/reference/appkit/1428499-nsapplicationmain"><span class="code">NSApplicationMain</span></a>, which will fire up the Cocoa application framework and load the main <em>nib file</em> from our application bundle, as specified by <span class="code">NSMainNibFile</span> in the property list.</p>

<a name="nibs"></a>
<h4>Nibs</h4>

<p><em>Nibs</em> are files generated by Interface Builder, which is part of Xcode these days. It was originally called NeXT Interface Builder, which is why the files had a <span class="code">.nib</span> extension. Current versions of Interface Builder generate XML files with the extension <span class="code">.xib</span> instead, but the files are still referred to as nibs, and they are converted to <span class="code">.nib</span> files as part of the build process.</p>

<p>Nib files contain the serialization of an object graph (sometimes called a set of freeze-dried objects). That is, they describe a set of objects and connections between them. Those objects can be user interface elements such as windows, buttons, etc. along with attributes that define their appearance, or other objects. Connections allow objects to reference each other; for example, clicking a button might invoke some method on another object. When the framework loads a nib file, it instantiates the objects from the file and sets up the connections between them.</p>

<p>The screenshot below shows the nib for our Othello program in Xcode:</p>

<div style="text-align: center">
<img src="gfx/othello_nib.png" alt="Screenshot of the Othello MainMenu nib in Xcode.">
</div>

<p>Here, Xcode has been used to create a custom <span class="code">OthelloView</span> object that fills the window, as well as the main menu for our program.</p>

<p>Interface Builder has also been used to set up connections between objects. For example, the <span class="code">delegate</span> outlet of the <span class="code">OthelloView</span> (an outlet is a kind of instance variable) is connected to the <span class="code">AppDelegate</span> object, which acts as the controller for our program.</p>

<p>Other connections, which are not visible in the screenshot above, can be seen in the <span class="code">.xib</span> file itself, <a href="files/othello/mac/MainMenu.xib"><span class="code">MainMenu.xib</span></a>: (Apologies for the huge blob of XML, but that is what we get for using this kind of tool.)</p>

<div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="nt">&lt;document</span> <span class="na">type=</span><span class="s">&quot;com.apple.InterfaceBuilder3.Cocoa.XIB&quot;</span> <span class="na">version=</span><span class="s">&quot;3.0&quot;</span> <span class="na">toolsVersion=</span><span class="s">&quot;11762&quot;</span>
<span class="na">systemVersion=</span><span class="s">&quot;16D32&quot;</span> <span class="na">targetRuntime=</span><span class="s">&quot;MacOSX.Cocoa&quot;</span> <span class="na">propertyAccessControl=</span><span class="s">&quot;none&quot;</span>
<span class="na">useAutolayout=</span><span class="s">&quot;YES&quot;</span> <span class="na">customObjectInstantitationMethod=</span><span class="s">&quot;direct&quot;</span><span class="nt">&gt;
  &lt;dependencies&gt;
    &lt;deployment</span> <span class="na">identifier=</span><span class="s">&quot;macosx&quot;</span><span class="nt">/&gt;
    &lt;plugIn</span> <span class="na">identifier=</span><span class="s">&quot;com.apple.InterfaceBuilder.CocoaPlugin&quot;</span> <span class="na">version=</span><span class="s">&quot;11762&quot;</span><span class="nt">/&gt;
    &lt;capability</span> <span class="na">name=</span><span class="s">&quot;documents saved in the Xcode 8 format&quot;</span> <span class="na">minToolsVersion=</span><span class="s">&quot;8.0&quot;</span><span class="nt">/&gt;
  &lt;/dependencies&gt;
  &lt;objects&gt;
    &lt;customObject</span> <span class="na">id=</span><span class="s">&quot;-2&quot;</span> <span class="na">userLabel=</span><span class="s">&quot;File&#39;s Owner&quot;</span> <span class="na">customClass=</span><span class="s">&quot;NSApplication&quot;</span><span class="nt">&gt;
      &lt;connections&gt;
        &lt;outlet</span> <span class="na">property=</span><span class="s">&quot;delegate&quot;</span> <span class="na">destination=</span><span class="s">&quot;1&quot;</span> <span class="na">id=</span><span class="s">&quot;15&quot;</span><span class="nt">/&gt;
      &lt;/connections&gt;
    &lt;/customObject&gt;
    &lt;customObject</span> <span class="na">id=</span><span class="s">&quot;-1&quot;</span> <span class="na">userLabel=</span><span class="s">&quot;First Responder&quot;</span> <span class="na">customClass=</span><span class="s">&quot;FirstResponder&quot;</span><span class="nt">/&gt;
    &lt;customObject</span> <span class="na">id=</span><span class="s">&quot;-3&quot;</span> <span class="na">userLabel=</span><span class="s">&quot;Application&quot;</span> <span class="na">customClass=</span><span class="s">&quot;NSObject&quot;</span><span class="nt">/&gt;
    &lt;customObject</span> <span class="na">id=</span><span class="s">&quot;1&quot;</span> <span class="na">customClass=</span><span class="s">&quot;AppDelegate&quot;</span><span class="nt">&gt;
      &lt;connections&gt;
        &lt;outlet</span> <span class="na">property=</span><span class="s">&quot;newgameMenu&quot;</span> <span class="na">destination=</span><span class="s">&quot;2&quot;</span> <span class="na">id=</span><span class="s">&quot;12&quot;</span><span class="nt">/&gt;
        &lt;outlet</span> <span class="na">property=</span><span class="s">&quot;othelloView&quot;</span> <span class="na">destination=</span><span class="s">&quot;3&quot;</span> <span class="na">id=</span><span class="s">&quot;13&quot;</span><span class="nt">/&gt;
        &lt;outlet</span> <span class="na">property=</span><span class="s">&quot;window&quot;</span> <span class="na">destination=</span><span class="s">&quot;4&quot;</span> <span class="na">id=</span><span class="s">&quot;14&quot;</span><span class="nt">/&gt;
      &lt;/connections&gt;
    &lt;/customObject&gt;
    &lt;customObject</span> <span class="na">id=</span><span class="s">&quot;16&quot;</span> <span class="na">customClass=</span><span class="s">&quot;NSFontManager&quot;</span><span class="nt">/&gt;
    &lt;menu</span> <span class="na">title=</span><span class="s">&quot;Main Menu&quot;</span> <span class="na">systemMenu=</span><span class="s">&quot;main&quot;</span> <span class="na">id=</span><span class="s">&quot;5&quot;</span><span class="nt">&gt;
      &lt;items&gt;
        &lt;menuItem</span> <span class="na">title=</span><span class="s">&quot;Othello&quot;</span> <span class="na">id=</span><span class="s">&quot;6&quot;</span><span class="nt">&gt;
          &lt;modifierMask</span> <span class="na">key=</span><span class="s">&quot;keyEquivalentModifierMask&quot;</span><span class="nt">/&gt;
          &lt;menu</span> <span class="na">key=</span><span class="s">&quot;submenu&quot;</span> <span class="na">title=</span><span class="s">&quot;Othello&quot;</span> <span class="na">systemMenu=</span><span class="s">&quot;apple&quot;</span> <span class="na">autoenablesItems=</span><span class="s">&quot;NO&quot;</span>
          <span class="na">id=</span><span class="s">&quot;7&quot;</span><span class="nt">&gt;
            &lt;items&gt;
              &lt;menuItem</span> <span class="na">title=</span><span class="s">&quot;New Game&quot;</span> <span class="na">keyEquivalent=</span><span class="s">&quot;n&quot;</span> <span class="na">id=</span><span class="s">&quot;2&quot;</span><span class="nt">&gt;
                &lt;connections&gt;
                  &lt;action</span> <span class="na">selector=</span><span class="s">&quot;newGame:&quot;</span> <span class="na">target=</span><span class="s">&quot;1&quot;</span> <span class="na">id=</span><span class="s">&quot;8&quot;</span><span class="nt">/&gt;
                &lt;/connections&gt;
              &lt;/menuItem&gt;
              &lt;menuItem</span> <span class="na">isSeparatorItem=</span><span class="s">&quot;YES&quot;</span> <span class="na">id=</span><span class="s">&quot;9&quot;</span><span class="nt">/&gt;
              &lt;menuItem</span> <span class="na">title=</span><span class="s">&quot;Quit Othello&quot;</span> <span class="na">keyEquivalent=</span><span class="s">&quot;q&quot;</span> <span class="na">id=</span><span class="s">&quot;10&quot;</span><span class="nt">&gt;
                &lt;connections&gt;
                  &lt;action</span> <span class="na">selector=</span><span class="s">&quot;terminate:&quot;</span> <span class="na">target=</span><span class="s">&quot;-1&quot;</span> <span class="na">id=</span><span class="s">&quot;11&quot;</span><span class="nt">/&gt;
                &lt;/connections&gt;
              &lt;/menuItem&gt;
            &lt;/items&gt;
          &lt;/menu&gt;
        &lt;/menuItem&gt;
      &lt;/items&gt;
    &lt;/menu&gt;
    &lt;window</span> <span class="na">title=</span><span class="s">&quot;Othello&quot;</span> <span class="na">allowsToolTipsWhenApplicationIsInactive=</span><span class="s">&quot;NO&quot;</span>
    <span class="na">autorecalculatesKeyViewLoop=</span><span class="s">&quot;NO&quot;</span> <span class="na">releasedWhenClosed=</span><span class="s">&quot;NO&quot;</span>
    <span class="na">animationBehavior=</span><span class="s">&quot;default&quot;</span> <span class="na">id=</span><span class="s">&quot;4&quot;</span><span class="nt">&gt;
      &lt;windowStyleMask</span> <span class="na">key=</span><span class="s">&quot;styleMask&quot;</span> <span class="na">titled=</span><span class="s">&quot;YES&quot;</span> <span class="na">closable=</span><span class="s">&quot;YES&quot;</span>
      <span class="na">miniaturizable=</span><span class="s">&quot;YES&quot;</span> <span class="na">resizable=</span><span class="s">&quot;YES&quot;</span><span class="nt">/&gt;
      &lt;windowPositionMask</span> <span class="na">key=</span><span class="s">&quot;initialPositionMask&quot;</span> <span class="na">leftStrut=</span><span class="s">&quot;YES&quot;</span>
      <span class="na">rightStrut=</span><span class="s">&quot;YES&quot;</span> <span class="na">topStrut=</span><span class="s">&quot;YES&quot;</span> <span class="na">bottomStrut=</span><span class="s">&quot;YES&quot;</span><span class="nt">/&gt;
      &lt;rect</span> <span class="na">key=</span><span class="s">&quot;contentRect&quot;</span> <span class="na">x=</span><span class="s">&quot;335&quot;</span> <span class="na">y=</span><span class="s">&quot;390&quot;</span> <span class="na">width=</span><span class="s">&quot;360&quot;</span> <span class="na">height=</span><span class="s">&quot;360&quot;</span><span class="nt">/&gt;
      &lt;rect</span> <span class="na">key=</span><span class="s">&quot;screenRect&quot;</span> <span class="na">x=</span><span class="s">&quot;0.0&quot;</span> <span class="na">y=</span><span class="s">&quot;0.0&quot;</span> <span class="na">width=</span><span class="s">&quot;1920&quot;</span> <span class="na">height=</span><span class="s">&quot;1177&quot;</span><span class="nt">/&gt;
      &lt;view</span> <span class="na">key=</span><span class="s">&quot;contentView&quot;</span> <span class="na">id=</span><span class="s">&quot;17&quot;</span><span class="nt">&gt;
        &lt;rect</span> <span class="na">key=</span><span class="s">&quot;frame&quot;</span> <span class="na">x=</span><span class="s">&quot;0.0&quot;</span> <span class="na">y=</span><span class="s">&quot;0.0&quot;</span> <span class="na">width=</span><span class="s">&quot;360&quot;</span> <span class="na">height=</span><span class="s">&quot;360&quot;</span><span class="nt">/&gt;
        &lt;autoresizingMask</span> <span class="na">key=</span><span class="s">&quot;autoresizingMask&quot;</span><span class="nt">/&gt;
        &lt;subviews&gt;
          &lt;customView</span> <span class="na">fixedFrame=</span><span class="s">&quot;YES&quot;</span> <span class="na">translatesAutoresizingMaskIntoConstraints=</span><span class="s">&quot;NO&quot;</span>
          <span class="na">id=</span><span class="s">&quot;3&quot;</span> <span class="na">customClass=</span><span class="s">&quot;OthelloView&quot;</span><span class="nt">&gt;
            &lt;rect</span> <span class="na">key=</span><span class="s">&quot;frame&quot;</span> <span class="na">x=</span><span class="s">&quot;20&quot;</span> <span class="na">y=</span><span class="s">&quot;20&quot;</span> <span class="na">width=</span><span class="s">&quot;320&quot;</span> <span class="na">height=</span><span class="s">&quot;320&quot;</span><span class="nt">/&gt;
            &lt;autoresizingMask</span> <span class="na">key=</span><span class="s">&quot;autoresizingMask&quot;</span> <span class="na">widthSizable=</span><span class="s">&quot;YES&quot;</span>
            <span class="na">heightSizable=</span><span class="s">&quot;YES&quot;</span><span class="nt">/&gt;
            &lt;connections&gt;
              &lt;outlet</span> <span class="na">property=</span><span class="s">&quot;delegate&quot;</span> <span class="na">destination=</span><span class="s">&quot;1&quot;</span> <span class="na">id=</span><span class="s">&quot;18&quot;</span><span class="nt">/&gt;
            &lt;/connections&gt;
          &lt;/customView&gt;
        &lt;/subviews&gt;
      &lt;/view&gt;
    &lt;/window&gt;
  &lt;/objects&gt;
&lt;/document&gt;</span>
</pre></div>


<p>The <span class="code">connections</span> element for the <span class="code">AppDelegate</span> shows how it's connected to the "New Game" menu item, the <span class="code">OthelloView</span> and the window. That means that when the nib is loaded, <span class="code">AppDelegate</span> will be able to access those objects through its instance variables.</p>

<p>The file also defines <em>actions</em>. For example, when the user clicks the "New Game" menu item, a <span class="code">newGame:</span> message will be sent to (Objective-C lingo for invoking a method) the <span class="code">AppDelegate</span>.</p>

<p>There are some objects in the nib that were not defined by us. The "File's Owner" object (id -2) is the object that is loading the nib, in our case an instance of <span class="code">NSApplication</span> whose actions were set in motion by the call to <span class="code">NSApplicationMain</span> in the <span class="code">main</span> function of our program. This is a big difference from Linux and Windows where we did a lot of the low-level work ourselves: here, <span class="code">NSApplication</span> is running the show, and we cater to it with nibs and delegate classes.</p>

<p>Another special object is the "First Responder" (id -1). In the nib file, this isn't a specific object, but a place-holder to allow binding actions to the object that's currently chosen to receive keyboard events. That object is known as the <em>first responder</em> because it comes first in the chain of objects that respond to events. In our case, the "Quit Othello" menu item's action is set up to send a <span class="code">terminate:</span> message to the first responder when invoked. The first responder for our program will be the <span class="code">OthelloView</span>, but since it doesn't handle <span class="code">terminate:</span> messages, they will get passed up the chain until they reach <span class="code">NSApplication</span>, whose <span class="code">terminate:</span> method terminates the application.</p>

<p>(It is <a href="https://www.cocoawithlove.com/2010/09/minimalist-cocoa-programming.html">possible</a> to build Cocoa applications without nibs, which is appealing in some ways. However, certain things, such as <a href="http://lapcatsoftware.com/blog/2007/05/16/working-without-a-nib-part-1/">defining</a> <a href="http://lapcatsoftware.com/blog/2007/06/17/working-without-a-nib-part-4-setapplemenu/">menus</a>, are tricky without using nibs.)</p>


<a name="mac_controller"></a>
<h4>The Controller</h4>

<p>Compared to the X and Windows ports, because we're using an object-oriented programming language and working with the Cocoa framework, the Model-View-Controller organization of our program becomes more explicit. The game is still modelled by the Othello engine we wrote above, the view will be implemented further below, and the controller is implemented here in the <span class="code">AppDelegate</span> class. Perhaps it's not the best of names, but it is what Xcode gave me.</p>

<p>This is its header file, <a href="files/othello/mac/AppDelegate.h"><span class="code">AppDelegate.h</span></a>:</p>

<div class="highlight"><pre><span></span><span class="cp">#import &lt;Cocoa/Cocoa.h&gt;
#include</span> <span class="cpf">&quot;../othello.h&quot;</span><span class="cp"></span>

<span class="k">enum</span> <span class="n">State</span> <span class="p">{</span> <span class="n">BLACKS_MOVE</span><span class="p">,</span> <span class="n">WHITES_MOVE</span><span class="p">,</span> <span class="n">GAME_OVER</span> <span class="p">};</span>

<span class="k">@interface</span> <span class="nc">AppDelegate</span> : <span class="bp">NSObject</span> <span class="o">&lt;</span><span class="n">NSApplicationDelegate</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">othello_t board</span><span class="p">;</span>
    <span class="k">enum</span> <span class="n">State state</span><span class="p">;
}</span>

<span class="c1">// Get a pointer to the Othello board.</span>
<span class="o">-</span> <span class="p">(</span><span class="k">const</span> <span class="n">othello_t</span><span class="o">*</span><span class="p">)</span><span class="n">board</span><span class="p">;</span>

<span class="c1">// Get the current state.</span>
<span class="p">- (</span><span class="k">enum</span> <span class="n">State</span><span class="p">)</span><span class="nf">state</span><span class="p">;</span>

<span class="c1">// To be called when a cell on the board is clicked by the user.</span>
<span class="p">- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">boardWasClickedAtRow:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nv">row</span> <span class="nf">Column:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nv">col</span><span class="p">;</span>

<span class="c1">// Reset the game state.</span>
<span class="p">- (</span><span class="kt">IBAction</span><span class="p">)</span><span class="nf">newGame:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">sender</span><span class="p">;</span>

<span class="k">@end</span>
</pre></div>


<p>We recognize some of this as ordinary C code: the <span class="code">#include</span> of our <span class="code">othello.h</span> header and the declaration of the enumeration. Being able to interoperate easily with C is a key strength of Objective-C. Through the backwards compatibility with C, it lowers the threshold for adoption, as programmers can easily reuse their existing code. In our case, it means the Othello engine can be used seamlessly.</p>

<p>The block starting with <span class="code">@interface</span> and ending with <span class="code">@end</span> declares a <em>class interface</em>. Here we declare the <span class="code">AppDelegate</span> class, which inherits from <a href="https://developer.apple.com/reference/objectivec/nsobject?language=objc"><span class="code">NSObject</span></a> (all classes usually do), and <em>conforms</em> to the <a href="https://developer.apple.com/reference/appkit/nsapplicationdelegate?language=objc"><span class="code">NSApplicationDelegate</span></a> <em>protocol</em>.</p>

<p>A protocol is like an interface in Java: a set of methods, some of which may be optional, that a class can declare that it implements. A class can only have one superclass, but may conform to multiple protocols.</p>

<p>The declarations of <span class="code">board</span> and <span class="code">state</span> within the curly braces are <em>instance variable declarations</em> for the class. These variables are private to the implementation of the class.</p>

<p>Following the closing curly brace are <em>method declarations</em>. The return type is provided in parenthesis, followed by the name of the method with method arguments and their types separated by colons. The colon syntax comes from Smalltalk and aims to make method invocations more explicative. For example, when cell (1,2) is clicked on the board, we will send a <span class="code">boardWasClickedAtRow:1 Column:2</span> message. Apple's documentation provides some <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/CodingGuidelines/Articles/NamingMethods.html">naming guidelines.</a></p>

<p>Method declarations are prefixed with either <span class="code">+</span> or <span class="code">-</span> signs. A plus sign signifies a <em>class method</em>, which is a method that can be invoked directly on the class, similar to a static method in Java and C++. One common use is the <span class="code">alloc</span> method (typically inherited from <span class="code">NSObject</span>) and other methods which create instances of a class. Method declarations prefixed by a minus sign are <em>instance methods</em>: they can only be invoked on instances of the class, not on the class itself.</p>

<p><span class="code">IBAction</span> is a macro that expands to <span class="code">void</span>, but signals to Interface Builder that this method should be exposed as an action which other objects can invoke. In our case, we have connected the "New Game" menu option to this method.</p>

<p>The definition of our class is provided in <a href="files/othello/mac/AppDelegate.m"><span class="code">AppDelegate.m</span></a>, which begins like this:</p>

<div class="highlight"><pre><span></span><span class="cp">#import &quot;AppDelegate.h&quot;
#import &quot;OthelloView.h&quot;</span>

<span class="k">@interface</span> <span class="nc">AppDelegate</span> <span class="p">()</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">makeMoveAtRow</span><span class="p">:(</span><span class="kt">int</span><span class="p">)</span><span class="n">row</span> <span class="nl">Column</span><span class="p">:(</span><span class="kt">int</span><span class="p">)</span><span class="n">col</span><span class="p">;</span>

<span class="k">@property</span> <span class="p">(</span><span class="k">weak</span><span class="p">)</span> <span class="kt">IBOutlet</span> <span class="n">NSWindow</span> <span class="o">*</span><span class="n">window</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">weak</span><span class="p">)</span> <span class="kt">IBOutlet</span> <span class="n">OthelloView</span> <span class="o">*</span><span class="n">othelloView</span><span class="p">;</span>
<span class="k">@property</span> <span class="p">(</span><span class="k">weak</span><span class="p">)</span> <span class="kt">IBOutlet</span> <span class="n">NSMenuItem</span> <span class="o">*</span><span class="n">newgameMenu</span><span class="p">;</span>
<span class="k">@end</span>
</pre></div>


<p>This <span class="code">@interface</span> declaration is a <em><a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/CustomizingExistingClasses/CustomizingExistingClasses.html#//apple_ref/doc/uid/TP40011210-CH6-SW3">class extension</a></em> of <span class="code">AppDelegate</span>. The methods declared in the header file are all public. (Unlike C++ and Java, Objective-C does not have access modifiers such as <span class="code">public:</span> and <span class="code">private:</span>). Using a class extension allows us to add a private method <span class="code">makeMoveAtRow:Column:</span> which is only available for internal use.</p>

<p>We also add <em>properties</em>, which are instance variables synthesized by the compiler. For each property, the compiler will generate <em>getter</em> and <em>setter</em> methods (for example, <span class="code">window</span> and <span class="code">setWindow</span>) to access the instance variable. Since we don't want the setters and getters to be public, the properties are declared in this class extension, rather than the public interface. The properties are marked <span class="code">IBOutlet</span>, which means they will show up as outlets in Interface Builder, where we connected them to other objects. When our nib file is loaded, these properties will be set to reference the objects they're connected to.</p>

<p>Objective-C uses <a href="https://en.wikipedia.org/wiki/Reference_counting">reference counting</a> for memory management. The <span class="code">weak</span> attribute on our properties mean that they are weak references, that is, they don't contribute to the reference count of the objects they refer to. Strong references would increment the reference count in the property's setter.</p>

<p>After the class extension, we begin the method definitions:</p>

<div class="highlight"><pre><span></span><span class="k">@implementation</span> <span class="nc">AppDelegate</span>

<span class="p">- (</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span> <span class="p">{</span>
    <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">) {
        [</span><span class="nb">self</span> <span class="nl">newGame</span><span class="p">:</span><span class="nb">nil</span><span class="p">];
    }</span>
    <span class="k">return</span> <span class="nb">self</span><span class="p">;
}

- (</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">applicationShouldTerminateAfterLastWindowClosed:</span><span class="p">(</span><span class="n">NSApplication</span><span class="o">*</span><span class="p">)</span><span class="nv">app</span> <span class="p">{
    (</span><span class="kt">void</span><span class="p">)</span><span class="n">app</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">YES</span><span class="p">;
}</span>
</pre></div>


<p>The syntax of a method definition matches that of a method declaration (prefixed by <span class="code">+</span> or <span class="code">-</span> followed by return type in parenthesis, etc), except that it includes the method body surrounded by curly braces.</p>

<p>The <span class="code">init</span> method initializes our object. It is important to call the initializer of the superclass first (and abort if that returns <span class="code">nil</span>). <span class="code">[super init]</span> is a <em>message expression</em>. It sends an <span class="code">init</span> message to the <span class="code">super</span> object (<span class="code">super</span> refers to the instance of our object's parent class). The message terminology comes from Smalltalk, and is similar to a method invocation in other languages. If initialization of the parent succeeded, we initialize ourselves with the <span class="code">newGame:</span> method, by sending a message to ourselves (<span class="code">self</span> is similar to <span class="code">this</span> in Java and C++).</p>

<p>The <span class="code">applicationShouldTerminateAfterLastWindowClosed:</span> method is part of the <span class="code">NSApplicationDelegate</span> protocol which our class conforms to. It gets called by <span class="code">NSApplication</span> to ask if we would like the application to terminate after the last window closed, to which the answer is yes. (<span class="code">YES</span> and <span class="code">NO</span>, of type <span class="code">BOOL</span> correspond to <span class="code">true</span> and <span class="code">false</span> in other languages.) The <span class="code">app</span> argument is cast to void to suppress compiler warnings about unused variables.</p>

<p>The following method definitions are straight-forward, mixing regular C code with a few message expressions:</p>

<div class="highlight"><pre><span></span><span class="p">- (</span><span class="k">const</span> <span class="n">othello_t</span><span class="o">*</span><span class="p">)</span><span class="nf">board</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">board</span><span class="p">;
}

- (</span><span class="k">enum</span> <span class="n">State</span><span class="p">)</span><span class="nf">state</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">state</span><span class="p">;
}

- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">boardWasClickedAtRow:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nv">row</span> <span class="nf">Column:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nv">col</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">BLACKS_MOVE</span><span class="p">) {
        [</span><span class="nb">self</span> <span class="nl">makeMoveAtRow</span><span class="p">:</span><span class="n">row</span> <span class="nl">Column</span><span class="p">:</span><span class="n">col</span><span class="p">];
    }
}

- (</span><span class="kt">IBAction</span><span class="p">)</span><span class="nf">newGame:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">sender</span> <span class="p">{
    (</span><span class="kt">void</span><span class="p">)</span><span class="n">sender</span><span class="p">;</span>
    <span class="n">othello_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">);</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">BLACKS_MOVE</span><span class="p">;
    [</span><span class="nb">self</span><span class="p">.</span><span class="n">newgameMenu</span> <span class="nl">setEnabled</span><span class="p">:</span><span class="nb">YES</span><span class="p">];
    [</span><span class="nb">self</span><span class="p">.</span><span class="n">othelloView</span> <span class="nl">setNeedsDisplay</span><span class="p">:</span><span class="nb">YES</span><span class="p">];
}</span>
</pre></div>


<p>Note the <span class="code">self.othelloView</span> syntax which is shorthand for accessing a property. It is equivalent to invoking the getter method with <span class="code">[self othelloView]</span>, but cuts down on the use of angle brackets.</p>

<p><span class="code">makeMoveAtRow:Column:</span>, the final method, is similar to <span class="code">make_move</span> in the Windows and X11 versions, making a move for the current player and transitioning to the next game state:</p>

<div class="highlight"><pre><span></span><span class="p">- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">makeMoveAtRow:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nv">row</span> <span class="nf">Column:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nv">col</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">BLACKS_MOVE</span> <span class="o">||</span> <span class="n">state</span> <span class="o">==</span> <span class="n">WHITES_MOVE</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">BLACKS_MOVE</span><span class="p">) {</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">othello_is_valid_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_BLACK</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)) {</span>
            <span class="c1">// Illegal move; ignored.</span>
            <span class="k">return</span><span class="p">;
        }</span>

        <span class="n">othello_make_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_BLACK</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">);</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">WHITES_MOVE</span><span class="p">;
    }</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">othello_make_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_WHITE</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">);</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">BLACKS_MOVE</span><span class="p">;
    }</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">othello_has_valid_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_BLACK</span><span class="p">)</span> <span class="o">&amp;&amp;
        !</span><span class="n">othello_has_valid_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_WHITE</span><span class="p">)) {</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">GAME_OVER</span><span class="p">;
    }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">BLACKS_MOVE</span> <span class="o">&amp;&amp;
               !</span><span class="n">othello_has_valid_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_BLACK</span><span class="p">)) {</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">WHITES_MOVE</span><span class="p">;
    }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">WHITES_MOVE</span> <span class="o">&amp;&amp;
               !</span><span class="n">othello_has_valid_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_WHITE</span><span class="p">)) {</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">BLACKS_MOVE</span><span class="p">;
    }</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">WHITES_MOVE</span><span class="p">) {</span>
        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span>
                    <span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
            <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">;</span>
            <span class="n">othello_compute_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_WHITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">row</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">col</span><span class="p">);</span>

            <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{
                [</span><span class="nb">self</span> <span class="nl">makeMoveAtRow</span><span class="p">:</span><span class="n">row</span> <span class="nl">Column</span><span class="p">:</span><span class="n">col</span><span class="p">];
            });
        });
    }

    [</span><span class="nb">self</span><span class="p">.</span><span class="n">newgameMenu</span> <span class="nl">setEnabled</span><span class="p">:(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">WHITES_MOVE</span><span class="p">)];
    [</span><span class="nb">self</span><span class="p">.</span><span class="n">othelloView</span> <span class="nl">setNeedsDisplay</span><span class="p">:</span><span class="nb">YES</span><span class="p">];
}</span>

<span class="k">@end</span>
</pre></div>


<p>As in the other versions, it is important that <span class="code">othello_compute_move</span> is called on a background thread. To accomplish this, we use <span class="code">dispatch_async</span> which takes a dispatch queue argument (<span class="code">dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0)</span> gets us a background thread) and an Objective-C <em>block</em>, a form of <a href="https://en.wikipedia.org/wiki/Anonymous_function">anonymous function</a> created with the <span class="code">^{ ... }</span> syntax. After the move is computed, we use the same technique to call back to <span class="code">makeMoveAtRow:Column:</span> with the result.</p>

<p>Similarly to the Windows version, we need to be careful not to change the game state on the main thread while a move is being computed on another thread. For that reason, we disable the "New Game" menu item while it's white's turn.</p>

<a name="mac_view"></a>
<h4>The View</h4>

<p>The <span class="code">OthelloView</span> class is responsible for displaying the game state and letting the <span class="code">AppDelegate</span> know when the user clicks on or selects a cell using the keyboard.</p>

<p>The class declaration, in <a href="files/othello/mac/OthelloView.h"><span class="code">OthelloView.h</span></a> is very simple:</p>

<div class="highlight"><pre><span></span><span class="cp">#import &lt;Cocoa/Cocoa.h&gt;</span>

<span class="k">@interface</span> <span class="nc">OthelloView</span> : <span class="nc">NSView</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">selCol</span><span class="p">,</span> <span class="n">selRow</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cellSize</span><span class="p">,</span> <span class="n">xOffset</span><span class="p">,</span> <span class="n">yOffset</span><span class="p">,</span> <span class="n">size</span><span class="p">;
}</span>
<span class="k">@end</span>
</pre></div>


<p>All it does is declare a few instance variables to keep track of which cell is currently selected, and the position that the board is drawn at. It doesn't declare any methods in addition to those it inherits from <span class="code">NSView</span>.</p>

<p>As with <span class="code">AppDelegate</span>, we use a class extension to declare a few private methods and a property which we connected in Interface Builder. In <a href="files/othello/mac/OthelloView.m"><span class="code">OthelloView.m</span></a>:</p>

<div class="highlight"><pre><span></span><span class="cp">#import &quot;OthelloView.h&quot;
#import &quot;AppDelegate.h&quot;
#include</span> <span class="cpf">&quot;../othello.h&quot;</span><span class="cp"></span>

<span class="k">@interface</span> <span class="nc">OthelloView</span> <span class="p">()</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">drawChar</span><span class="p">:(</span><span class="kt">char</span><span class="p">)</span><span class="n">c</span> <span class="nl">atPoint</span><span class="p">:(</span><span class="n">NSPoint</span><span class="p">)</span><span class="n">p</span><span class="p">;
- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">drawString:</span><span class="p">(</span><span class="bp">NSString</span><span class="o">*</span><span class="p">)</span><span class="nv">s</span> <span class="nf">atPoint:</span><span class="p">(</span><span class="n">NSPoint</span><span class="p">)</span><span class="nv">p</span><span class="p">;
- (</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">hitTest:</span><span class="p">(</span><span class="n">NSPoint</span><span class="p">)</span><span class="nv">p</span> <span class="nf">withHitRow:</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="nv">row</span> <span class="nf">hitCol:</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="nv">col</span><span class="p">;</span>

<span class="k">@property</span> <span class="p">(</span><span class="k">weak</span><span class="p">)</span> <span class="kt">IBOutlet</span> <span class="n">AppDelegate</span> <span class="o">*</span><span class="n">delegate</span><span class="p">;</span>
<span class="k">@end

static const</span> <span class="kt">int</span> <span class="n">CELL_GAP</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
</pre></div>


<p>The <span class="code">delegate</span> property will be used to get the game state, and for sending notifications when the user clicks a cell.</p>

<p>First we define a few methods inherited from <span class="code">NSView</span>:</p>

<div class="highlight"><pre><span></span><span class="k">@implementation</span> <span class="nc">OthelloView</span>

<span class="p">- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">awakeFromNib</span> <span class="p">{
    [</span><span class="nb">super</span> <span class="n">awakeFromNib</span><span class="p">];</span>

    <span class="n">selRow</span> <span class="o">= -</span><span class="mi">1</span><span class="p">;</span>
    <span class="n">selCol</span> <span class="o">= -</span><span class="mi">1</span><span class="p">;

    [</span><span class="nb">self</span><span class="p">.</span><span class="n">window</span> <span class="nl">setAcceptsMouseMovedEvents</span><span class="p">:</span><span class="nb">YES</span><span class="p">];
    [</span><span class="nb">self</span> <span class="nl">setNeedsDisplay</span><span class="p">:</span><span class="nb">YES</span><span class="p">];
}

- (</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">acceptsFirstResponder</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">YES</span><span class="p">;
}

- (</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">isFlipped</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">YES</span><span class="p">;
}</span>
</pre></div>


<p><span class="code">awakeFromNib</span> gets called after our object is loaded from the nib file. We initialize the selected cell variables, let the window (<span class="code">NSView</span> has a <span class="code">window</span> getter) know that we would like to receive mouse-motion events, and then call <span class="code">setNeedsDisplay:</span> to let the framework know that we'd like to be painted.</p>

<p>Returning <span class="code">YES</span> from <span class="code">acceptsFirstResponder</span> allows our view to receive keyboard events.</p>

<p>Returning <span class="code">YES</span> from <span class="code">isFlipped</span> means our view will draw in a "flipped" coordinate system, that is, the origin will be in the upper-left corner instead of the default which is lower-left. This is useful because it gives us the same coordinate system that we used for X11 and Windows, so we can reuse our calculations in the drawing code.</p>

<p>The drawing is performed by <span class="code">drawRect:</span> which gets called when the framework wants to draw the view:</p>

<div class="highlight"><pre><span></span><span class="p">- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">drawRect:</span><span class="p">(</span><span class="n">NSRect</span><span class="p">)</span><span class="nv">dirtyRect</span> <span class="p">{
    [</span><span class="nb">super</span> <span class="nl">drawRect</span><span class="p">:</span><span class="n">dirtyRect</span><span class="p">];</span>

    <span class="c1">// Compute size and position of the 10x10 grid.</span>
    <span class="n">NSRect bounds</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="n">bounds</span><span class="p">];</span>
    <span class="kt">float</span> <span class="n">viewSize</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">);</span>
    <span class="n">cellSize</span> <span class="o">=</span> <span class="p">(</span><span class="n">viewSize</span> <span class="o">-</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">CELL_GAP</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">cellSize</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">CELL_GAP</span><span class="p">;</span>
    <span class="n">xOffset</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">yOffset</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

    <span class="c1">// Draw a background square around the 8x8 centre cells.</span>
    <span class="p">[[</span><span class="n">NSColor blackColor</span><span class="p">]</span> <span class="n">set</span><span class="p">];</span>
    <span class="n">NSRect backgroundRect</span> <span class="o">=</span>
        <span class="n">NSMakeRect</span><span class="p">(</span><span class="n">xOffset</span> <span class="o">+</span> <span class="n">cellSize</span><span class="p">,</span> <span class="n">yOffset</span> <span class="o">+</span> <span class="n">cellSize</span><span class="p">,</span>
                   <span class="mi">8</span> <span class="o">*</span> <span class="n">cellSize</span> <span class="o">+</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">CELL_GAP</span><span class="p">,</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">cellSize</span> <span class="o">+</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">CELL_GAP</span><span class="p">);
    [</span><span class="n">NSBezierPath</span> <span class="nl">fillRect</span><span class="p">:</span><span class="n">backgroundRect</span><span class="p">];</span>

    <span class="c1">// Draw labels.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">) {</span>
        <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="n">xOffset</span> <span class="o">+</span> <span class="n">cellSize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="n">yOffset</span> <span class="o">+</span> <span class="p">(</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">cellSize</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="p">)</span> <span class="o">+</span> <span class="n">cellSize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;
        [</span><span class="nb">self</span> <span class="nl">drawChar</span><span class="p">:(</span><span class="sc">&#39;1&#39;</span> <span class="o">+</span> <span class="n">row</span><span class="p">)</span> <span class="nl">atPoint</span><span class="p">:</span><span class="n">NSMakePoint</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)];
    }</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">col</span><span class="o">++</span><span class="p">) {</span>
        <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="n">xOffset</span> <span class="o">+</span> <span class="p">(</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">cellSize</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="p">)</span> <span class="o">+</span> <span class="n">cellSize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="n">yOffset</span> <span class="o">+</span> <span class="n">cellSize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;
        [</span><span class="nb">self</span> <span class="nl">drawChar</span><span class="p">:(</span><span class="sc">&#39;A&#39;</span> <span class="o">+</span> <span class="n">col</span><span class="p">)</span> <span class="nl">atPoint</span><span class="p">:</span><span class="n">NSMakePoint</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)];
    }</span>

    <span class="k">const</span> <span class="n">othello_t</span> <span class="o">*</span><span class="n">board</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">delegate board</span><span class="p">];</span>

    <span class="c1">// Draw status text.</span>
    <span class="bp">NSString</span> <span class="o">*</span><span class="n">statusText</span><span class="p">;</span>
    <span class="k">switch</span> <span class="p">([</span><span class="nb">self</span><span class="p">.</span><span class="n">delegate state</span><span class="p">]) {</span>
    <span class="k">case</span> <span class="nl">BLACKS_MOVE</span><span class="p">:</span>
        <span class="n">statusText</span> <span class="o">=</span> <span class="s">@&quot;Human&#39;s move.&quot;</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">WHITES_MOVE</span><span class="p">:</span>
        <span class="n">statusText</span> <span class="o">=</span> <span class="s">@&quot;Computer&#39;s move...&quot;</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">GAME_OVER</span><span class="p">: {</span>
        <span class="kt">int</span> <span class="n">blackScore</span> <span class="o">=</span> <span class="n">othello_score</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_BLACK</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">whiteScore</span> <span class="o">=</span> <span class="n">othello_score</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_WHITE</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">blackScore</span> <span class="o">&gt;</span> <span class="n">whiteScore</span><span class="p">) {</span>
            <span class="n">statusText</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;Human wins %d-%d!&quot;</span><span class="p">,</span>
                                   <span class="n">blackScore</span><span class="p">,</span> <span class="n">whiteScore</span><span class="p">];
        }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">whiteScore</span> <span class="o">&gt;</span> <span class="n">blackScore</span><span class="p">) {</span>
            <span class="n">statusText</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;Computer wins %d-%d!&quot;</span><span class="p">,</span>
                                   <span class="n">whiteScore</span><span class="p">,</span> <span class="n">blackScore</span><span class="p">];
        }</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">statusText</span> <span class="o">=</span> <span class="s">@&quot;Draw!&quot;</span><span class="p">;
        }</span>
        <span class="k">break</span><span class="p">;
        }
    }
    [</span><span class="nb">self</span> <span class="nl">drawString</span><span class="p">:</span><span class="n">statusText</span> <span class="nl">atPoint</span><span class="p">:</span><span class="n">NSMakePoint</span><span class="p">(</span><span class="n">xOffset</span> <span class="o">+</span> <span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
            <span class="n">yOffset</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="n">cellSize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)];</span>

    <span class="c1">// Draw the cells.</span>
    <span class="n">NSColor</span> <span class="o">*</span><span class="n">boardColor</span> <span class="o">=</span>
        <span class="p">[</span><span class="n">NSColor</span> <span class="nl">colorWithCalibratedRed</span><span class="p">:</span><span class="mi">0</span> <span class="nl">green</span><span class="p">:(</span><span class="mh">0x80</span> <span class="o">/</span> <span class="mf">256.0</span><span class="p">)</span> <span class="nl">blue</span><span class="p">:</span><span class="mi">0</span> <span class="nl">alpha</span><span class="p">:</span><span class="mi">1</span><span class="p">];</span>
    <span class="n">NSColor</span> <span class="o">*</span><span class="n">highlightColor</span> <span class="o">=</span>
        <span class="p">[</span><span class="n">NSColor</span> <span class="nl">colorWithCalibratedRed</span><span class="p">:</span><span class="mi">0</span> <span class="nl">green</span><span class="p">:(</span><span class="mh">0xAA</span> <span class="o">/</span> <span class="mf">256.0</span><span class="p">)</span> <span class="nl">blue</span><span class="p">:</span><span class="mi">0</span> <span class="nl">alpha</span><span class="p">:</span><span class="mi">1</span><span class="p">];</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">) {</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">col</span><span class="o">++</span><span class="p">) {</span>
            <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="n">xOffset</span> <span class="o">+</span> <span class="p">(</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">cellSize</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="p">);</span>
            <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="n">yOffset</span> <span class="o">+</span> <span class="p">(</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">cellSize</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="p">);</span>
            <span class="kt">bool</span> <span class="n">highlight</span> <span class="o">=</span> <span class="p">(</span><span class="n">row</span> <span class="o">==</span> <span class="n">selRow</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">==</span> <span class="n">selCol</span> <span class="o">&amp;&amp;</span>
                              <span class="p">[</span><span class="nb">self</span><span class="p">.</span><span class="n">delegate state</span><span class="p">]</span> <span class="o">==</span> <span class="n">BLACKS_MOVE</span><span class="p">);</span>

            <span class="c1">// Draw the cell background.</span>
            <span class="p">[(</span><span class="n">highlight</span> <span class="o">?</span> <span class="nl">highlightColor</span> <span class="p">:</span> <span class="n">boardColor</span><span class="p">)</span> <span class="n">set</span><span class="p">];</span>
            <span class="n">NSRect cellRect</span> <span class="o">=</span> <span class="n">NSMakeRect</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">);
            [</span><span class="n">NSBezierPath</span> <span class="nl">fillRect</span><span class="p">:</span><span class="n">cellRect</span><span class="p">];</span>

            <span class="c1">// Draw the disk, if any.</span>
            <span class="n">NSBezierPath</span> <span class="o">*</span><span class="n">diskPath</span> <span class="o">=</span>
                <span class="p">[</span><span class="n">NSBezierPath</span> <span class="nl">bezierPathWithOvalInRect</span><span class="p">:</span><span class="n">cellRect</span><span class="p">];</span>
            <span class="k">switch</span> <span class="p">(</span><span class="n">othello_cell_state</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)) {</span>
            <span class="k">case</span> <span class="nl">CELL_BLACK</span><span class="p">:
                [[</span><span class="n">NSColor blackColor</span><span class="p">]</span> <span class="n">set</span><span class="p">];
                [</span><span class="n">diskPath fill</span><span class="p">];</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="nl">CELL_WHITE</span><span class="p">:
                [[</span><span class="n">NSColor whiteColor</span><span class="p">]</span> <span class="n">set</span><span class="p">];
                [</span><span class="n">diskPath fill</span><span class="p">];</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">default</span><span class="o">:</span>
                <span class="k">break</span><span class="p">;
            }
        }
    }
}</span>
</pre></div>


<p>The drawing strategy is exactly the same as for X11 and Windows: the drawing area is divided into a square 10-by-10 grid, of which the centre 8-by-8 cells are the othello board, the top and left columns are used for labels, and the bottom row for status text.</p>

<p>When drawing the status text we use the <span class="code">@"foo"</span> syntax, which is a shorthand for creating <span class="code">NSString</span> objects, the string class used in Objective-C.</p>

<p>These are the auxiliary methods used for drawing characters and strings:</p>

<div class="highlight"><pre><span></span><span class="p">- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">drawChar:</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="nv">c</span> <span class="nf">atPoint:</span><span class="p">(</span><span class="n">NSPoint</span><span class="p">)</span><span class="nv">p</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="n">s</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">};
    [</span><span class="nb">self</span> <span class="nl">drawString</span><span class="p">:[</span><span class="bp">NSString</span> <span class="nl">stringWithUTF8String</span><span class="p">:</span><span class="n">s</span><span class="p">]</span> <span class="nl">atPoint</span><span class="p">:</span><span class="n">p</span><span class="p">];
}

- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">drawString:</span><span class="p">(</span><span class="bp">NSString</span><span class="o">*</span><span class="p">)</span><span class="nv">s</span> <span class="nf">atPoint:</span><span class="p">(</span><span class="n">NSPoint</span><span class="p">)</span><span class="nv">p</span> <span class="p">{</span>
    <span class="n">NSFont</span> <span class="o">*</span><span class="n">font</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSFont</span> <span class="nl">boldSystemFontOfSize</span><span class="p">:[</span><span class="n">NSFont systemFontSize</span><span class="p">]];</span>
    <span class="bp">NSAttributedString</span> <span class="o">*</span><span class="n">as</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSAttributedString</span> <span class="n">alloc</span><span class="p">]</span>
        <span class="nl">initWithString</span><span class="p">:</span><span class="n">s</span> <span class="nl">attributes</span><span class="p">:</span><span class="l">@{</span> <span class="nl">NSFontAttributeName</span><span class="p">:</span> <span class="n">font</span> <span class="l">}</span><span class="p">];</span>
    <span class="n">NSSize stringSize</span> <span class="o">=</span> <span class="p">[</span><span class="n">as size</span><span class="p">];
    [</span><span class="n">as</span> <span class="nl">drawAtPoint</span><span class="p">:</span><span class="n">NSMakePoint</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">stringSize</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                                <span class="n">p</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">stringSize</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)];
}</span>
</pre></div>


<p>The <span class="code">@{ ... }</span> expression is a <a href="https://clang.llvm.org/docs/ObjectiveCLiterals.html#container-literals">dictionary literal</a>, shorthand for creating an immutable <span class="code">NSDictionary</span>.</p>

<p>Traditionally, Objective-C programmers had to deal with managing the reference counts of objects allocated on the heap. Manually allocated or copied objects (such as the <span class="code">NSAttributedString</span> above) would have to be dealt with manually, whereas objects created by the framework (for example, the <span class="code">NSFont</span>) would be added automatically to an <em>autorelease pool</em> and released on the next iteration of the event loop. See the <a href="https://developer.apple.com/library/content/documentation/Cocoa/Conceptual/MemoryMgmt/Articles/MemoryMgmt.html">documentation about memory management</a>. More recently, a system called <a href="https://developer.apple.com/library/content/releasenotes/ObjectiveC/RN-TransitioningToARC/Introduction/Introduction.html">Automatic Reference Counting</a> (ARC) was introduced, which makes the compiler insert the necessary code for retaining and releasing objects, so for example we don't worry about the reference count on the <span class="code">NSAttributedString</span> even though we allocated it manually.</p>

<p>Handling mouse events is similar to the other ports as well: we perform a hit test to check if the mouse is over a cell on the Othello board, update the selected cell so it is drawn highlighted, and notify the delegate if a cell is clicked:</p>

<div class="highlight"><pre><span></span><span class="p">- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">mouseDown:</span><span class="p">(</span><span class="bp">NSEvent</span><span class="o">*</span><span class="p">)</span><span class="nv">event</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">([</span><span class="nb">self</span> <span class="nl">hitTest</span><span class="p">:[</span><span class="n">event locationInWindow</span><span class="p">]</span> <span class="nl">withHitRow</span><span class="p">:</span><span class="o">&amp;</span><span class="n">row</span> <span class="nl">hitCol</span><span class="p">:</span><span class="o">&amp;</span><span class="n">col</span><span class="p">]) {
        [</span><span class="nb">self</span><span class="p">.</span><span class="n">delegate</span> <span class="nl">boardWasClickedAtRow</span><span class="p">:</span><span class="n">row</span> <span class="nl">Column</span><span class="p">:</span><span class="n">col</span><span class="p">];
    }
}

- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">mouseMoved:</span><span class="p">(</span><span class="bp">NSEvent</span><span class="o">*</span><span class="p">)</span><span class="nv">event</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">[</span><span class="nb">self</span> <span class="nl">hitTest</span><span class="p">:[</span><span class="n">event locationInWindow</span><span class="p">]</span> <span class="nl">withHitRow</span><span class="p">:</span><span class="o">&amp;</span><span class="n">row</span> <span class="nl">hitCol</span><span class="p">:</span><span class="o">&amp;</span><span class="n">col</span><span class="p">]) {</span>
        <span class="n">row</span> <span class="o">= -</span><span class="mi">1</span><span class="p">;</span>
        <span class="n">col</span> <span class="o">= -</span><span class="mi">1</span><span class="p">;
    }</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">!=</span> <span class="n">selRow</span> <span class="o">||</span> <span class="n">col</span> <span class="o">!=</span> <span class="n">selCol</span><span class="p">) {</span>
        <span class="n">selRow</span> <span class="o">=</span> <span class="n">row</span><span class="p">;</span>
        <span class="n">selCol</span> <span class="o">=</span> <span class="n">col</span><span class="p">;
        [</span><span class="nb">self</span> <span class="nl">setNeedsDisplay</span><span class="p">:</span><span class="nb">YES</span><span class="p">];
    }
}

- (</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">hitTest:</span><span class="p">(</span><span class="n">NSPoint</span><span class="p">)</span><span class="nv">p</span> <span class="nf">withHitRow:</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="nv">row</span> <span class="nf">hitCol:</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="nv">col</span> <span class="p">{</span>
    <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">convertPoint</span><span class="p">:</span><span class="n">p</span> <span class="nl">fromView</span><span class="p">:</span><span class="nb">nil</span><span class="p">];</span>
    <span class="o">*</span><span class="n">row</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">p</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">yOffset</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">cellSize</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="o">*</span><span class="n">col</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">p</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">xOffset</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">cellSize</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp; *</span><span class="n">row</span> <span class="o">&lt;</span> <span class="mi">8</span> <span class="o">&amp;&amp; *</span><span class="n">col</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp; *</span><span class="n">col</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">) {</span>
        <span class="k">return</span> <span class="nb">YES</span><span class="p">;
    }</span>

    <span class="k">return</span> <span class="nb">NO</span><span class="p">;
}</span>
</pre></div>


<p>Note that because our view uses the "flipped" coordinate system, we have to convert the coordinates from the event to our own coordinate system when performing the hit test.</p>

<p>Finally, we also handle keyboard events to select a cell or make a move:</p>

<div class="highlight"><pre><span></span><span class="p">- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">keyDown:</span><span class="p">(</span><span class="bp">NSEvent</span><span class="o">*</span><span class="p">)</span><span class="nv">event</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="n">selRow</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="n">selCol</span><span class="p">;</span>
    <span class="kt">unichar</span> <span class="n">c</span> <span class="o">=</span> <span class="p">[[</span><span class="n">event charactersIgnoringModifiers</span><span class="p">]</span> <span class="nl">characterAtIndex</span><span class="p">:</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">switch</span> <span class="p">(</span><span class="n">c</span><span class="p">) {</span>
    <span class="k">default</span><span class="o">:</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="k">case</span> <span class="sc">&#39; &#39;</span><span class="o">:</span>
    <span class="k">case</span> <span class="nl">NSCarriageReturnCharacter</span><span class="p">:</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">selRow</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">) {
            [</span><span class="nb">self</span><span class="p">.</span><span class="n">delegate</span> <span class="nl">boardWasClickedAtRow</span><span class="p">:</span><span class="n">selRow</span> <span class="nl">Column</span><span class="p">:</span><span class="n">selCol</span><span class="p">];
        }</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="k">case</span> <span class="nl">NSRightArrowFunctionKey</span><span class="p">:</span> <span class="n">col</span><span class="o">++</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">NSLeftArrowFunctionKey</span><span class="p">:</span>  <span class="n">col</span><span class="o">--</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">NSDownArrowFunctionKey</span><span class="p">:</span>  <span class="n">row</span><span class="o">++</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">NSUpArrowFunctionKey</span><span class="p">:</span>    <span class="n">row</span><span class="o">--</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="sc">&#39;a&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;b&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;c&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;d&#39;</span><span class="o">:</span>
    <span class="k">case</span> <span class="sc">&#39;e&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;f&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;g&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;h&#39;</span><span class="o">:</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="sc">&#39;1&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;2&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;3&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;4&#39;</span><span class="o">:</span>
    <span class="k">case</span> <span class="sc">&#39;5&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;6&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;7&#39;</span><span class="o">:</span> <span class="k">case</span> <span class="sc">&#39;8&#39;</span><span class="o">:</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">c</span> <span class="o">-</span> <span class="sc">&#39;1&#39;</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;
    }</span>

    <span class="n">selRow</span> <span class="o">=</span> <span class="n">MAX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">MIN</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="mi">7</span><span class="p">));</span>
    <span class="n">selCol</span> <span class="o">=</span> <span class="n">MAX</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">MIN</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="mi">7</span><span class="p">));
    [</span><span class="nb">self</span> <span class="nl">setNeedsDisplay</span><span class="p">:</span><span class="nb">YES</span><span class="p">];
}</span>

<span class="k">@end</span>
</pre></div>



<a name="mac_build"></a>
<h4>Building</h4>

<p>The program can of course be built from the Xcode IDE, but Xcode also provides a way to build the project from the command line:</p>

<div class="highlight"><pre><span></span><span class="gp">$</span> xcodebuild -project Othello.xcodeproj -configuration Release
</pre></div>


<p>From the output of that, we can learn how to build the program ourselves. First we create the output folder:</p>

<div class="highlight"><pre><span></span><span class="gp">$</span> mkdir -p Othello.app/Contents/MacOS Othello.app/Contents/Resources
</pre></div>


<p>Then we build the executable. We just have to invoke Clang with some extra flags to link against the Cocoa framework, enable ARC, and such:</p>

<div class="highlight"><pre><span></span><span class="gp">$</span> clang -Wextra -O3 -DNDEBUG main.m AppDelegate.m OthelloView.m ../othello.c <span class="se">\</span>
	-mmacosx-version-min<span class="o">=</span><span class="m">10</span>.7 -fobjc-arc -fobjc-link-runtime <span class="se">\</span>
	-lobjc -framework Cocoa -o Othello.app/Contents/MacOS/Othello
</pre></div>


<p>The <span class="code">.xib</span> file is converted to a <span class="code">.nib</span> file using <span class="code">ibtool</span>:</p>

<div class="highlight"><pre><span></span><span class="gp">$</span> ibtool --output-format human-readable-text --errors --warnings --notices <span class="se">\</span>
	--module Othello --target-device mac --minimum-deployment-target <span class="m">10</span>.7 <span class="se">\</span>
	--compile Othello.app/Contents/Resources/MainMenu.nib MainMenu.xib
</pre></div>


<p>We use <span class="code">iconutil</span> to create a <span class="code">.icns</span> file from the <span class="code">mac.iconset</span> dir, which contains PNG images in <a href="https://developer.apple.com/library/content/documentation/GraphicsAnimation/Conceptual/HighResolutionOSX/Optimizing/Optimizing.html#//apple_ref/doc/uid/TP40012302-CH7-SW3">certain specific sizes</a>:</p>

<div class="highlight"><pre><span></span><span class="gp">$</span> iconutil -c icns -o Othello.app/Contents/Resources/Othello.icns ../icons/mac.iconset
</pre></div>


<p>Finally, we copy the information property list into the bundle:</p>

<div class="highlight"><pre><span></span><span class="gp">$</span> cp Info.plist Othello.app/Contents/
</pre></div>


<p>The picture below shows the resulting application running on Mac:</p>

<div style="text-align: center">
<img src="gfx/mac_othello.png" alt="Screenshot of the Othello program on Mac.">
</div>


<a name="ios"></a>
<h3>iOS</h3>

<p>On 9 January 2007, Apple <a href="https://www.youtube.com/watch?v=vN4U5FqrOdQ&amp;t=32s">announced the iPhone</a> and changed the world of mobile computing. Smart-phones already existed, and before that there were pocket computers like Palm Pilot and even Apple's own <a href="https://en.wikipedia.org/wiki/Apple_Newton">Newton</a> &mdash; but in that presentation in 2007, Steve Jobs showed what smart-phones would look like going forward, both from Apple and from other manufacturers.</p>

<p>The operating system, iOS (originally iPhone OS), is a mobile version of macOS, and applications are developed similarly to the Mac: with Objective-C or Swift using a mobile version of the Cocoa libraries called Cocoa Touch. This similarity between mobile and desktop made it easy for existing Mac developers to start writing apps for the iPhone.</p>

<p>The Othello program for iOS is very similar to the Mac version. It's written in Objective-C and much of the code is virtually identical. I used the fourth edition (the last one using Objective-C) of Keur, Hillegass &amp; Conway "iOS Programming: The Big Nerd Ranch Guide" as a tutorial to iOS programming.</p>

<a name="ios_launchscreen"></a>
<h4>Launch Screen</h4>

<p>iOS programs can use nib files for interfaces just as Mac applications do, but in the case of the Othello program, there was no reason to since all we need is a single view that covers the whole screen.</p>

<p>However, iOS introduces a new kind of xml blobs: <em>storyboards</em>. A <a href="https://developer.apple.com/library/content/documentation/General/Conceptual/Devpedia-CocoaApp/Storyboard.html">storyboard</a> is a way of organizing multiple application screens and the transitions between them. The Othello program has no need for that since it uses a single screen, however storyboards can also be used for the application launch screen.</p>

<p>Since it can take a little while to load an application, the operating system displays the application's <em>launch screen</em> while it's loading, similarly to a <a href="https://en.wikipedia.org/wiki/Splash_screen">splash screen</a>. The launch screen is static, and can either be an image file or a storyboard file. Using a static image requires having an image file that matches the resolution of the screen being used, and since there are so many devices running iOS (all the iPhones, iPads, iPod touches, etc.), it requires quite a collection of images. A storyboard solves that problem as it can be configured to scale to any size, and it has therefore become the preferred launch screen method.</p>

<p>Here is <a href="files/othello/ios/LaunchScreen.storyboard"><span class="code">LaunchScreen.storyboard</span></a> for our Othello program (again, apologies for the ugly blob of XML):</p>

<div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span>
<span class="nt">&lt;document</span> <span class="na">type=</span><span class="s">&quot;com.apple.InterfaceBuilder3.CocoaTouch.Storyboard.XIB&quot;</span> <span class="na">version=</span><span class="s">&quot;3.0&quot;</span>
<span class="na">toolsVersion=</span><span class="s">&quot;11762&quot;</span> <span class="na">systemVersion=</span><span class="s">&quot;16D32&quot;</span> <span class="na">targetRuntime=</span><span class="s">&quot;iOS.CocoaTouch&quot;</span>
<span class="na">propertyAccessControl=</span><span class="s">&quot;none&quot;</span> <span class="na">useAutolayout=</span><span class="s">&quot;YES&quot;</span> <span class="na">launchScreen=</span><span class="s">&quot;YES&quot;</span>
<span class="na">useTraitCollections=</span><span class="s">&quot;YES&quot;</span> <span class="na">colorMatched=</span><span class="s">&quot;YES&quot;</span> <span class="na">initialViewController=</span><span class="s">&quot;01J-lp-oVM&quot;</span><span class="nt">&gt;
  &lt;device</span> <span class="na">id=</span><span class="s">&quot;retina4_7&quot;</span> <span class="na">orientation=</span><span class="s">&quot;portrait&quot;</span><span class="nt">&gt;
    &lt;adaptation</span> <span class="na">id=</span><span class="s">&quot;fullscreen&quot;</span><span class="nt">/&gt;
  &lt;/device&gt;
  &lt;dependencies&gt;
    &lt;plugIn</span> <span class="na">identifier=</span><span class="s">&quot;com.apple.InterfaceBuilder.IBCocoaTouchPlugin&quot;</span> <span class="na">version=</span><span class="s">&quot;11757&quot;</span><span class="nt">/&gt;
    &lt;capability</span> <span class="na">name=</span><span class="s">&quot;documents saved in the Xcode 8 format&quot;</span> <span class="na">minToolsVersion=</span><span class="s">&quot;8.0&quot;</span><span class="nt">/&gt;
  &lt;/dependencies&gt;
  &lt;scenes&gt;</span>
    <span class="c">&lt;!--View Controller--&gt;</span>
    <span class="nt">&lt;scene</span> <span class="na">sceneID=</span><span class="s">&quot;EHf-IW-A2E&quot;</span><span class="nt">&gt;
      &lt;objects&gt;
        &lt;viewController</span> <span class="na">id=</span><span class="s">&quot;01J-lp-oVM&quot;</span> <span class="na">sceneMemberID=</span><span class="s">&quot;viewController&quot;</span><span class="nt">&gt;
          &lt;layoutGuides&gt;
            &lt;viewControllerLayoutGuide</span> <span class="na">type=</span><span class="s">&quot;top&quot;</span> <span class="na">id=</span><span class="s">&quot;Llm-lL-Icb&quot;</span><span class="nt">/&gt;
            &lt;viewControllerLayoutGuide</span> <span class="na">type=</span><span class="s">&quot;bottom&quot;</span> <span class="na">id=</span><span class="s">&quot;xb3-aO-Qok&quot;</span><span class="nt">/&gt;
          &lt;/layoutGuides&gt;
          &lt;view</span> <span class="na">key=</span><span class="s">&quot;view&quot;</span> <span class="na">contentMode=</span><span class="s">&quot;scaleToFill&quot;</span> <span class="na">id=</span><span class="s">&quot;Ze5-6b-2t3&quot;</span><span class="nt">&gt;
            &lt;rect</span> <span class="na">key=</span><span class="s">&quot;frame&quot;</span> <span class="na">x=</span><span class="s">&quot;0.0&quot;</span> <span class="na">y=</span><span class="s">&quot;0.0&quot;</span> <span class="na">width=</span><span class="s">&quot;375&quot;</span> <span class="na">height=</span><span class="s">&quot;667&quot;</span><span class="nt">/&gt;
            &lt;autoresizingMask</span> <span class="na">key=</span><span class="s">&quot;autoresizingMask&quot;</span> <span class="na">widthSizable=</span><span class="s">&quot;YES&quot;</span>
            <span class="na">heightSizable=</span><span class="s">&quot;YES&quot;</span><span class="nt">/&gt;
            &lt;subviews&gt;
              &lt;label</span> <span class="na">opaque=</span><span class="s">&quot;NO&quot;</span> <span class="na">userInteractionEnabled=</span><span class="s">&quot;NO&quot;</span> <span class="na">contentMode=</span><span class="s">&quot;left&quot;</span>
              <span class="na">horizontalHuggingPriority=</span><span class="s">&quot;251&quot;</span> <span class="na">verticalHuggingPriority=</span><span class="s">&quot;251&quot;</span>
              <span class="na">text=</span><span class="s">&quot;Othello by hanshq.net&quot;</span> <span class="na">textAlignment=</span><span class="s">&quot;natural&quot;</span>
              <span class="na">lineBreakMode=</span><span class="s">&quot;tailTruncation&quot;</span> <span class="na">baselineAdjustment=</span><span class="s">&quot;alignBaselines&quot;</span>
              <span class="na">adjustsFontSizeToFit=</span><span class="s">&quot;NO&quot;</span> <span class="na">translatesAutoresizingMaskIntoConstraints=</span><span class="s">&quot;NO&quot;</span>
              <span class="na">id=</span><span class="s">&quot;gDH-hN-GzD&quot;</span><span class="nt">&gt;
                &lt;rect</span> <span class="na">key=</span><span class="s">&quot;frame&quot;</span> <span class="na">x=</span><span class="s">&quot;103&quot;</span> <span class="na">y=</span><span class="s">&quot;323&quot;</span> <span class="na">width=</span><span class="s">&quot;169&quot;</span> <span class="na">height=</span><span class="s">&quot;21&quot;</span><span class="nt">/&gt;
                &lt;fontDescription</span> <span class="na">key=</span><span class="s">&quot;fontDescription&quot;</span> <span class="na">type=</span><span class="s">&quot;system&quot;</span> <span class="na">pointSize=</span><span class="s">&quot;17&quot;</span><span class="nt">/&gt;
                &lt;nil</span> <span class="na">key=</span><span class="s">&quot;textColor&quot;</span><span class="nt">/&gt;
                &lt;nil</span> <span class="na">key=</span><span class="s">&quot;highlightedColor&quot;</span><span class="nt">/&gt;
              &lt;/label&gt;
            &lt;/subviews&gt;
            &lt;color</span> <span class="na">key=</span><span class="s">&quot;backgroundColor&quot;</span>
            <span class="na">xcode11CocoaTouchSystemColor=</span><span class="s">&quot;systemBackgroundColor&quot;</span>
            <span class="na">cocoaTouchSystemColor=</span><span class="s">&quot;whiteColor&quot;</span><span class="nt">/&gt;
            &lt;constraints&gt;
              &lt;constraint</span> <span class="na">firstItem=</span><span class="s">&quot;gDH-hN-GzD&quot;</span> <span class="na">firstAttribute=</span><span class="s">&quot;centerY&quot;</span>
              <span class="na">secondItem=</span><span class="s">&quot;Ze5-6b-2t3&quot;</span> <span class="na">secondAttribute=</span><span class="s">&quot;centerY&quot;</span> <span class="na">id=</span><span class="s">&quot;lK5-06-eby&quot;</span><span class="nt">/&gt;
              &lt;constraint</span> <span class="na">firstItem=</span><span class="s">&quot;gDH-hN-GzD&quot;</span> <span class="na">firstAttribute=</span><span class="s">&quot;centerX&quot;</span>
              <span class="na">secondItem=</span><span class="s">&quot;Ze5-6b-2t3&quot;</span> <span class="na">secondAttribute=</span><span class="s">&quot;centerX&quot;</span> <span class="na">id=</span><span class="s">&quot;zhh-XG-Z3H&quot;</span><span class="nt">/&gt;
            &lt;/constraints&gt;
          &lt;/view&gt;
        &lt;/viewController&gt;
        &lt;placeholder</span> <span class="na">placeholderIdentifier=</span><span class="s">&quot;IBFirstResponder&quot;</span> <span class="na">id=</span><span class="s">&quot;iYj-Kq-Ea1&quot;</span>
        <span class="na">userLabel=</span><span class="s">&quot;First Responder&quot;</span> <span class="na">sceneMemberID=</span><span class="s">&quot;firstResponder&quot;</span><span class="nt">/&gt;
      &lt;/objects&gt;
      &lt;point</span> <span class="na">key=</span><span class="s">&quot;canvasLocation&quot;</span> <span class="na">x=</span><span class="s">&quot;52&quot;</span> <span class="na">y=</span><span class="s">&quot;374.66266866566718&quot;</span><span class="nt">/&gt;
    &lt;/scene&gt;
  &lt;/scenes&gt;
&lt;/document&gt;</span>
</pre></div>


<p>The storyboard was created in Xcode. All it does is display the text "Othello by hanshq.net" centered on the screen.</p>

<a name="ios_main"></a>
<h4>Main and AppDelegate</h4>

<p>The main method looks similar to that of the Mac version, except that we call <span class="code">UIApplicationMain</span> instead of <span class="code">NSApplicationMain</span>. In <a href="files/othello/ios/main.m"><span class="code">main.m</span></a>:</p>

<div class="highlight"><pre><span></span><span class="cp">#import &lt;UIKit/UIKit.h&gt;
#import &quot;AppDelegate.h&quot;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">) {</span>
    <span class="k">@autoreleasepool</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">UIApplicationMain</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="nb">nil</span><span class="p">,</span>
            <span class="n">NSStringFromClass</span><span class="p">([</span><span class="n">AppDelegate</span> <span class="k">class</span><span class="p">]));
    }
}</span>
</pre></div>


<p>The UI prefix refers to classes in the <em>UIKit</em> framework, which is the Cocoa Touch version of <em>AppKit</em> that is used on desktop. The classes in the <em>Foundation</em> framework are the same and still have their <span class="code">NS</span> prefix, such as <span class="code">NSString</span>, etc.</p>

<p>One difference from the desktop version is that we need to pass in the name of our application delegate to <span class="code">UIApplicationMain</span>. This is also why the code is put in an autorelese pool block: because of the heap-allocated <span class="code">NSString</span>.</p>

<p>Similarly to the desktop version, the purpose of the <span class="code">AppDelegate</span> is to receive calls from the framework's application class, <span class="code">UIApplication</span>. Those calls are part of the <span class="code">UIApplicationDelegate</span> procol. In addition to that, on iOS the <span class="code">AppDelegate</span> usually owns the main window, and inherits from <span class="code">UIResponder</span> which means it can take part of the responder chain and handle application-level events (the Othello program doesn't make use of this). In <a href="files/othello/ios/AppDelegate.h"><span class="code">AppDelegate.h</span></a>:</p>

<div class="highlight"><pre><span></span><span class="cp">#import &lt;UIKit/UIKit.h&gt;</span>

<span class="k">@interface</span> <span class="nc">AppDelegate</span> : <span class="bp">UIResponder</span> <span class="o">&lt;</span><span class="bp">UIApplicationDelegate</span><span class="o">&gt;</span>

<span class="k">@property</span> <span class="p">(</span><span class="k">strong</span><span class="p">,</span> <span class="k">nonatomic</span><span class="p">)</span> <span class="bp">UIWindow</span> <span class="o">*</span><span class="n">window</span><span class="p">;</span>

<span class="k">@end</span>
</pre></div>


<p>In <a href="files/othello/ios/AppDelegate.m"><span class="code">AppDelegate.m</span></a>, we implement four methods of the <span class="code">UIApplicationDelegate</span> protocol in our <span class="code">AppDelegate</span> class:</p>

<div class="highlight"><pre><span></span><span class="cp">#import &quot;AppDelegate.h&quot;
#import &quot;OthelloViewController.h&quot;</span>

<span class="k">@implementation</span> <span class="nc">AppDelegate</span>

<span class="p">- (</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">application:</span><span class="p">(</span><span class="bp">UIApplication</span><span class="o">*</span><span class="p">)</span><span class="nv">application</span>
        <span class="nf">willFinishLaunchingWithOptions:</span><span class="p">(</span><span class="n">nullable</span> <span class="bp">NSDictionary</span><span class="o">*</span><span class="p">)</span><span class="nv">launchOptions</span> <span class="p">{</span>
    <span class="nb">self</span><span class="p">.</span><span class="n">window</span> <span class="o">=</span>
        <span class="p">[[</span><span class="bp">UIWindow</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithFrame</span><span class="p">:[[</span><span class="bp">UIScreen</span> <span class="n">mainScreen</span><span class="p">]</span> <span class="n">bounds</span><span class="p">]];</span>
    <span class="k">return</span> <span class="nb">YES</span><span class="p">;
}

- (</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">application:</span><span class="p">(</span><span class="bp">UIApplication</span><span class="o">*</span><span class="p">)</span><span class="nv">application</span>
        <span class="nf">didFinishLaunchingWithOptions:</span><span class="p">(</span><span class="bp">NSDictionary</span><span class="o">*</span><span class="p">)</span><span class="nv">launchOptions</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">self</span><span class="p">.</span><span class="n">window</span><span class="p">.</span><span class="n">rootViewController</span><span class="p">) {</span>
        <span class="nb">self</span><span class="p">.</span><span class="n">window</span><span class="p">.</span><span class="n">rootViewController</span> <span class="o">=</span> <span class="p">[[</span><span class="n">OthelloViewController alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];
    }

    [</span><span class="nb">self</span><span class="p">.</span><span class="n">window makeKeyAndVisible</span><span class="p">];</span>
    <span class="k">return</span> <span class="nb">YES</span><span class="p">;
}

- (</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">application:</span><span class="p">(</span><span class="bp">UIApplication</span><span class="o">*</span><span class="p">)</span><span class="nv">application</span>
        <span class="nf">shouldSaveApplicationState:</span><span class="p">(</span><span class="n">nonnull</span> <span class="bp">NSCoder</span><span class="o">*</span><span class="p">)</span><span class="nv">coder</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">YES</span><span class="p">;
}

- (</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">application:</span><span class="p">(</span><span class="bp">UIApplication</span> <span class="o">*</span><span class="p">)</span><span class="nv">application</span>
        <span class="nf">shouldRestoreApplicationState:</span><span class="p">(</span><span class="n">nonnull</span> <span class="bp">NSCoder</span><span class="o">*</span><span class="p">)</span><span class="nv">coder</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">YES</span><span class="p">;
}</span>

<span class="k">@end</span>
</pre></div>


<p>These methods are all concerned with the life-cycle of the application. <span class="code">application:willFinishLaunchingWithOptions:</span> gets called at the beginning of the launch process. It is responsible for setting up the root window of the application.</p>

<p><span class="code">application:didFinishLaunchingWithOptions:</span> gets called at the end of the launch process, when the program is ready to be displayed. If our view controller (further below) wasn't restored from a previous session, it's created here, and the window is then made visible.</p>

<p><span class="code">application:shouldSaveApplicationState:</span> and <span class="code">application:shouldRestoreApplicationState:</span> get called to check whether the application state should be saved and restored when the program gets shut down and started. We will deal with this in the view controller below.</p>


<a name="ios_viewcontroller"></a>
<h4>The View Controller</h4>

<p>In the desktop version I was perhaps a little bit sloppy and used the <span class="code">AppDelegate</span> as controller for everything, rather than having a specific controller class for the <span class="code">OthelloView</span>. On iOS however, each view needs to be managed by a <span class="code">ViewController</span> class. There can be hierarchies of view controllers and views, but in our case it's simple: there will be an <span class="code">OthelloViewController</span> which owns the Othello board and controls the <span class="code">OthelloView</span> that displays it.</p>

<p>This is the class declaration, in <a href="files/othello/ios/OthelloViewController.h"><span class="code">OthelloViewController.h</span></a>:</p>

<div class="highlight"><pre><span></span><span class="cp">#import &lt;UIKit/UIKit.h&gt;
#include</span> <span class="cpf">&quot;../othello.h&quot;</span><span class="cp"></span>

<span class="k">enum</span> <span class="n">State</span> <span class="p">{</span> <span class="n">BLACKS_MOVE</span><span class="p">,</span> <span class="n">WHITES_MOVE</span><span class="p">,</span> <span class="n">GAME_OVER</span> <span class="p">};</span>

<span class="k">@interface</span> <span class="nc">OthelloViewController</span>
    : <span class="bp">UIViewController</span> <span class="o">&lt;</span><span class="bp">UIViewControllerRestoration</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">othello_t board</span><span class="p">;</span>
    <span class="k">enum</span> <span class="n">State state</span><span class="p">;
}</span>

<span class="k">@end</span>
</pre></div>


<p>It inherits from <span class="code">UIViewController</span>, and also conforms to the <span class="code">UIViewControllerRestoration</span> protocol, which is used to save and restore the controller's state.</p>

<p>We begin the implementation in <a href="files/othello/ios/OthelloViewController.m"><span class="code">OthelloViewController.m</span></a> by adding a few private methods, and also by adding another protocol that it conforms to: <span class="code">OthelloViewDelegate</span>. This is a protocol defined by the <span class="code">OthelloView</span>, which contains methods (<span class="code">boardWasTappedAtRow:col:</span> and <span class="code">newGame</span>) that the view will invoke when the user taps on a cell or requests a new game.</p>

<div class="highlight"><pre><span></span><span class="cp">#import &quot;OthelloViewController.h&quot;
#import &quot;OthelloView.h&quot;</span>

<span class="k">@interface</span> <span class="nc">OthelloViewController</span> <span class="p">()</span> <span class="o">&lt;</span><span class="n">OthelloViewDelegate</span><span class="o">&gt;
-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">makeMoveAtRow</span><span class="p">:(</span><span class="kt">int</span><span class="p">)</span><span class="n">row</span> <span class="nl">Column</span><span class="p">:(</span><span class="kt">int</span><span class="p">)</span><span class="n">col</span><span class="p">;
- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">computeWhiteMove</span><span class="p">;</span>
<span class="k">@end</span>
</pre></div>


<p>The initialization method starts a new game and sets two properties used by UIKit's <a href="https://developer.apple.com/library/content/featuredarticles/ViewControllerPGforiPhoneOS/PreservingandRestoringState.html">state preservation mechanism</a> to identify the class:</p>

<div class="highlight"><pre><span></span><span class="k">@implementation</span> <span class="nc">OthelloViewController</span>

<span class="p">- (</span><span class="kt">id</span><span class="p">)</span><span class="nf">init</span> <span class="p">{</span>
    <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">) {
        [</span><span class="nb">self</span> <span class="n">newGame</span><span class="p">];</span>
        <span class="nb">self</span><span class="p">.</span><span class="n">restorationClass</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="k">class</span><span class="p">;</span>
        <span class="nb">self</span><span class="p">.</span><span class="n">restorationIdentifier</span> <span class="o">=</span> <span class="n">NSStringFromClass</span><span class="p">(</span><span class="nb">self</span><span class="p">.</span><span class="k">class</span><span class="p">);
    }</span>
    <span class="k">return</span> <span class="nb">self</span><span class="p">;
}</span>
</pre></div>


<p>To save our state, we implement the <span class="code">encodeRestorableStateWithCoder:</span> method, by using the <span class="code">NSCoder</span> to encode the Othello board and game state, which the framework then stores somewhere:</p>

<div class="highlight"><pre><span></span><span class="p">- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">encodeRestorableStateWithCoder:</span><span class="p">(</span><span class="bp">NSCoder</span><span class="o">*</span><span class="p">)</span><span class="nv">coder</span> <span class="p">{</span>
    <span class="kt">uint8_t</span> <span class="n">boardBytes</span><span class="p">[</span><span class="mi">64</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">) {</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">col</span><span class="o">++</span><span class="p">) {</span>
            <span class="n">boardBytes</span><span class="p">[</span><span class="n">row</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">col</span><span class="p">]</span> <span class="o">=</span> <span class="n">othello_cell_state</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">);
        }
    }
    [</span><span class="n">coder</span> <span class="nl">encodeBytes</span><span class="p">:</span><span class="n">boardBytes</span> <span class="nl">length</span><span class="p">:</span><span class="k">sizeof</span><span class="p">(</span><span class="n">boardBytes</span><span class="p">)</span> <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;board&quot;</span><span class="p">];
    [</span><span class="n">coder</span> <span class="nl">encodeInt</span><span class="p">:(</span><span class="kt">int</span><span class="p">)</span><span class="n">state</span> <span class="nl">forKey</span><span class="p">:</span><span class="s">@&quot;state&quot;</span><span class="p">];

    [</span><span class="nb">super</span> <span class="nl">encodeRestorableStateWithCoder</span><span class="p">:</span><span class="n">coder</span><span class="p">];
}</span>
</pre></div>


<p>For state restoration, we implement the class method (note the <span class="code">+</span> prefix) <span class="code">viewControllerWithRestorationIdentifierPath:coder:</span> which creates an instance of our class and installs it as the root controller, and <span class="code">decodeRestorableStateWithCoder:</span> which deserializes the Othello board and game state from an <span class="code">NSCoder</span>:

<div class="highlight"><pre><span></span><span class="p">+ (</span><span class="bp">UIViewController</span><span class="o">*</span><span class="p">)</span>
<span class="nf">viewControllerWithRestorationIdentifierPath:</span><span class="p">(</span><span class="bp">NSArray</span><span class="o">*</span><span class="p">)</span><span class="nv">identifierComponents</span>
                                      <span class="nf">coder:</span><span class="p">(</span><span class="bp">NSCoder</span><span class="o">*</span><span class="p">)</span><span class="nv">coder</span> <span class="p">{</span>
    <span class="n">OthelloViewController</span> <span class="o">*</span><span class="n">ovc</span> <span class="o">=</span> <span class="p">[[</span><span class="nb">self</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">init</span><span class="p">];
    [</span><span class="bp">UIApplication</span> <span class="n">sharedApplication</span><span class="p">].</span><span class="n">delegate</span><span class="p">.</span><span class="n">window</span><span class="p">.</span><span class="n">rootViewController</span> <span class="o">=</span> <span class="n">ovc</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">ovc</span><span class="p">;
}

- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">decodeRestorableStateWithCoder:</span><span class="p">(</span><span class="bp">NSCoder</span><span class="o">*</span><span class="p">)</span><span class="nv">coder</span> <span class="p">{</span>
    <span class="n">NSUInteger length</span><span class="p">;</span>
    <span class="k">const</span> <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">boardBytes</span> <span class="o">=</span> <span class="p">[</span><span class="n">coder</span> <span class="nl">decodeBytesForKey</span><span class="p">:</span><span class="s">@&quot;board&quot;</span>
            <span class="nl">returnedLength</span><span class="p">:</span><span class="o">&amp;</span><span class="n">length</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">length</span> <span class="o">!=</span> <span class="mi">64</span><span class="p">) {</span>
        <span class="k">return</span><span class="p">;
    }</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">) {</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">col</span><span class="o">++</span><span class="p">) {</span>
            <span class="n">othello_set_cell_state</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">boardBytes</span><span class="p">[</span><span class="n">row</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">col</span><span class="p">]);
        }
    }</span>

    <span class="n">state</span> <span class="o">=</span> <span class="p">[</span><span class="n">coder</span> <span class="nl">decodeIntForKey</span><span class="p">:</span><span class="s">@&quot;state&quot;</span><span class="p">];

    [</span><span class="nb">super</span> <span class="nl">decodeRestorableStateWithCoder</span><span class="p">:</span><span class="n">coder</span><span class="p">];</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">WHITES_MOVE</span><span class="p">) {
        [</span><span class="nb">self</span> <span class="n">computeWhiteMove</span><span class="p">];
    }
}</span>
</pre></div>


<p><span class="code">loadView</span> gets called by the framework when it wants to paint the view, but no view has been loaded yet:</p>

<div class="highlight"><pre><span></span><span class="p">- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">loadView</span> <span class="p">{</span>
    <span class="nb">self</span><span class="p">.</span><span class="n">view</span> <span class="o">=</span> <span class="p">[[</span><span class="n">OthelloView alloc</span><span class="p">]</span> <span class="nl">initWithBoard</span><span class="p">:</span><span class="o">&amp;</span><span class="n">board</span> <span class="nl">state</span><span class="p">:</span><span class="n">state</span>
        <span class="nl">delegate</span><span class="p">:</span><span class="nb">self</span><span class="p">];
}</span>
</pre></div>


<p>We implement the two functions that the view can invoke:</p>

<div class="highlight"><pre><span></span><span class="p">- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">boardWasTappedAtRow:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nv">row</span> <span class="nf">col:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nv">col</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">BLACKS_MOVE</span><span class="p">) {
        [</span><span class="nb">self</span> <span class="nl">makeMoveAtRow</span><span class="p">:</span><span class="n">row</span> <span class="nl">Column</span><span class="p">:</span><span class="n">col</span><span class="p">];
    }
}

- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">newGame</span> <span class="p">{</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">BLACKS_MOVE</span><span class="p">;</span>
    <span class="n">othello_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">);
    [(</span><span class="n">OthelloView</span><span class="o">*</span><span class="p">)</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span> <span class="nl">updateWithState</span><span class="p">:</span><span class="n">state</span><span class="p">];
}</span>
</pre></div>


<p>And the code to update the state and compute new moves, which is basically the same as for the Mac version:</p>

<div class="highlight"><pre><span></span><span class="p">- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">makeMoveAtRow:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nv">row</span> <span class="nf">Column:</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="nv">col</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">BLACKS_MOVE</span> <span class="o">||</span> <span class="n">state</span> <span class="o">==</span> <span class="n">WHITES_MOVE</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">BLACKS_MOVE</span><span class="p">) {</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">othello_is_valid_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_BLACK</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)) {</span>
            <span class="c1">// Illegal move; ignored.</span>
            <span class="k">return</span><span class="p">;
        }</span>

        <span class="n">othello_make_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_BLACK</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">);</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">WHITES_MOVE</span><span class="p">;
    }</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">othello_make_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_WHITE</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">);</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">BLACKS_MOVE</span><span class="p">;
    }</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">othello_has_valid_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_BLACK</span><span class="p">)</span> <span class="o">&amp;&amp;
        !</span><span class="n">othello_has_valid_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_WHITE</span><span class="p">)) {</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">GAME_OVER</span><span class="p">;
    }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">BLACKS_MOVE</span> <span class="o">&amp;&amp;
               !</span><span class="n">othello_has_valid_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_BLACK</span><span class="p">)) {</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">WHITES_MOVE</span><span class="p">;
    }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">WHITES_MOVE</span> <span class="o">&amp;&amp;
               !</span><span class="n">othello_has_valid_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_WHITE</span><span class="p">)) {</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">BLACKS_MOVE</span><span class="p">;
    }</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">WHITES_MOVE</span><span class="p">) {
        [</span><span class="nb">self</span> <span class="n">computeWhiteMove</span><span class="p">];
    }

    [(</span><span class="n">OthelloView</span> <span class="o">*</span><span class="p">)</span><span class="nb">self</span><span class="p">.</span><span class="n">view</span> <span class="nl">updateWithState</span><span class="p">:</span><span class="n">state</span><span class="p">];
}

- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">computeWhiteMove</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">WHITES_MOVE</span><span class="p">);</span>

    <span class="n">dispatch_async</span><span class="p">(</span>
        <span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="o">^</span><span class="p">(</span><span class="kt">void</span><span class="p">) {</span>
          <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">;</span>
          <span class="n">othello_compute_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_WHITE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">row</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">col</span><span class="p">);</span>

          <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">(</span><span class="kt">void</span><span class="p">) {
            [</span><span class="nb">self</span> <span class="nl">makeMoveAtRow</span><span class="p">:</span><span class="n">row</span> <span class="nl">Column</span><span class="p">:</span><span class="n">col</span><span class="p">];
          });
        });
}</span>

<span class="k">@end</span>
</pre></div>



<a name="ios_view"></a>
<h4>The View</h4>

<p>The iOS <span class="code">OthelloView</span> is very similar to the Mac version: the drawing strategy is the same, and the APIs are almost identical. Instead of mouse events, it handles touch events, and it doesn't deal with keyboard events, which means there is no code for highlighting cells.</p>

<p>The declaration in <a href="files/othello/ios/OthelloView.h"><span class="code">OthelloView.h</span></a>:

<div class="highlight"><pre><span></span><span class="cp">#import &lt;UIKit/UIKit.h&gt;
#import &quot;OthelloViewController.h&quot;
#include</span> <span class="cpf">&quot;../othello.h&quot;</span><span class="cp"></span>

<span class="k">@protocol</span> <span class="nc">OthelloViewDelegate</span> <span class="o">&lt;</span><span class="bp">NSObject</span><span class="o">&gt;
-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">boardWasTappedAtRow</span><span class="p">:(</span><span class="kt">int</span><span class="p">)</span><span class="n">row</span> <span class="nl">col</span><span class="p">:(</span><span class="kt">int</span><span class="p">)</span><span class="n">col</span><span class="p">;
- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">newGame</span><span class="p">;</span>
<span class="k">@end

@interface</span> <span class="nc">OthelloView</span> : <span class="bp">UIView</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">othello_t</span> <span class="o">*</span><span class="n">board</span><span class="p">;</span>
    <span class="k">enum</span> <span class="n">State state</span><span class="p">;</span>
    <span class="k">__weak</span> <span class="kt">id</span><span class="o">&lt;</span><span class="n">OthelloViewDelegate</span><span class="o">&gt;</span> <span class="n">delegate</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">cellSize</span><span class="p">,</span> <span class="n">xOffset</span><span class="p">,</span> <span class="n">yOffset</span><span class="p">,</span> <span class="n">size</span><span class="p">;
}

- (</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithBoard:</span><span class="p">(</span><span class="k">const</span> <span class="n">othello_t</span><span class="o">*</span><span class="p">)</span><span class="nv">b</span> <span class="nf">state:</span><span class="p">(</span><span class="k">enum</span> <span class="n">State</span><span class="p">)</span><span class="nv">s</span>
           <span class="nf">delegate:</span><span class="p">(</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">OthelloViewDelegate</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">d</span><span class="p">;

- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">updateWithState:</span><span class="p">(</span><span class="k">enum</span> <span class="n">State</span><span class="p">)</span><span class="nv">state</span><span class="p">;</span>

<span class="k">@end</span>
</pre></div>


<p>On the Mac, we connected OthelloView explicitly to the AppDelegate, the controller, to notify it of user actions, etc. For the iOS version, we instead define the <span class="code">OthelloViewDelegate</span> protocol. The view gets initialized with a reference to a class conforming to the protocol, and beyond that it doesn't need to know what class it's talking to. This makes the view a bit more independent.</p>

<p>Note also that the iOS view receives updates via its <span class="code">updateWithState:</span> method whenever the game state changes. That way it doesn't need to "poll" the controller to ask about the state each time it needs to draw something. It's a little unfortunate that the game state is now kept in two places, but this seems nicer overall.</p>

<p>The <span class="code">__weak</span> attribute on the <span class="code">delegate</span> instance variable is necessary to indicate that the view doesn't take ownership of the delegate; it expects someone else to own it. (In this case it avoids a reference cycle between the view controller and the view.) The <span class="code">id&lt;Foo&gt;</span> syntax means it's a reference to a class (<span class="code">id</span> means any class) that conforms to the <span class="code">Foo</span> protocol.</p>

<p>We begin the implementation by defining a few private methods. In <a href="files/othello/ios/OthelloView.m"><span class="code">OthelloView.m</span></a>:</p>

<div class="highlight"><pre><span></span><span class="cp">#import &quot;OthelloView.h&quot;
#include</span> <span class="cpf">&quot;../othello.h&quot;</span><span class="cp"></span>

<span class="k">@interface</span> <span class="nc">OthelloView</span> <span class="p">()</span>
<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">onTap</span><span class="p">:(</span><span class="bp">UIGestureRecognizer</span><span class="o">*</span><span class="p">)</span><span class="n">gr</span><span class="p">;
- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">onLongPress:</span><span class="p">(</span><span class="bp">UIGestureRecognizer</span><span class="o">*</span><span class="p">)</span><span class="nv">gr</span><span class="p">;
- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">showMenuAtPoint:</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="nv">p</span><span class="p">;
- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">onNewGameMenu:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">sender</span><span class="p">;
- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">drawChar:</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="nv">c</span> <span class="nf">atPoint:</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="nv">p</span><span class="p">;
- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">drawString:</span><span class="p">(</span><span class="bp">NSString</span><span class="o">*</span><span class="p">)</span><span class="nv">s</span> <span class="nf">atPoint:</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="nv">p</span><span class="p">;
- (</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">hitTest:</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="nv">p</span> <span class="nf">withHitRow:</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="nv">row</span> <span class="nf">hitCol:</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="nv">col</span><span class="p">;</span>
<span class="k">@end</span>
</pre></div>


<p>In the initialization method, we set up two tap gesture recognizers: one that invokes <span class="code">onTap:</span> for regular taps, and one that invokes <span class="code">onLongPress:</span>. We also say yes to becoming first responder, which is necessary for showing a menu, which we'll do later.</p>

<p>(There is no need for <span class="code">isFlipped</span> that we implemented on the Mac version. On iOS, the coordinate system has its origin in the upper-left corner, just as our application likes it.)</p>

<div class="highlight"><pre><span></span><span class="k">@implementation</span> <span class="nc">OthelloView</span>

<span class="p">- (</span><span class="kt">id</span><span class="p">)</span><span class="nf">initWithBoard:</span><span class="p">(</span><span class="k">const</span> <span class="n">othello_t</span><span class="o">*</span><span class="p">)</span><span class="nv">b</span> <span class="nf">state:</span><span class="p">(</span><span class="k">enum</span> <span class="n">State</span><span class="p">)</span><span class="nv">s</span>
           <span class="nf">delegate:</span><span class="p">(</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">OthelloViewDelegate</span><span class="o">&gt;</span><span class="p">)</span><span class="nv">d</span> <span class="p">{</span>
    <span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="n">init</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">self</span><span class="p">) {</span>
        <span class="n">board</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
        <span class="n">delegate</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(@</span><span class="n">available</span><span class="p">(</span><span class="n">iOS</span> <span class="mf">13.0</span><span class="p">,</span> <span class="o">*</span><span class="p">)) {
            [</span><span class="nb">self</span> <span class="nl">setBackgroundColor</span><span class="p">:[</span><span class="bp">UIColor</span> <span class="n">systemBackgroundColor</span><span class="p">]];
        }</span> <span class="k">else</span> <span class="p">{
            [</span><span class="nb">self</span> <span class="nl">setBackgroundColor</span><span class="p">:[</span><span class="bp">UIColor</span> <span class="n">whiteColor</span><span class="p">]];
        }</span>

        <span class="bp">UITapGestureRecognizer</span> <span class="o">*</span><span class="n">tr</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UITapGestureRecognizer</span> <span class="n">alloc</span><span class="p">]</span>
            <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">action</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">onTap</span><span class="p">:)];</span>
        <span class="n">tr</span><span class="p">.</span><span class="n">numberOfTapsRequired</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;
        [</span><span class="nb">self</span> <span class="nl">addGestureRecognizer</span><span class="p">:</span><span class="n">tr</span><span class="p">];</span>

        <span class="bp">UILongPressGestureRecognizer</span> <span class="o">*</span><span class="n">lr</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">UILongPressGestureRecognizer</span> <span class="n">alloc</span><span class="p">]</span>
            <span class="nl">initWithTarget</span><span class="p">:</span><span class="nb">self</span> <span class="nl">action</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">onLongPress</span><span class="p">:)];
        [</span><span class="nb">self</span> <span class="nl">addGestureRecognizer</span><span class="p">:</span><span class="n">lr</span><span class="p">];
    }</span>
    <span class="k">return</span> <span class="nb">self</span><span class="p">;
}

- (</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">canBecomeFirstResponder</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">YES</span><span class="p">;
}</span>
</pre></div>


<p>(<span class="code">@selector</span> is used to get a reference to a method, like getting a pointer to member function in C++.)</p>

<p>When the user taps the view, we perform hit testing and notify the delegate if an Othello cell was tapped. For long taps (or any taps in the game over state) we bring up a menu to allow the user to start a new game:</p>

<div class="highlight"><pre><span></span><span class="p">- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">onTap:</span><span class="p">(</span><span class="bp">UIGestureRecognizer</span><span class="o">*</span><span class="p">)</span><span class="nv">gr</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">gr</span><span class="p">.</span><span class="n">state</span> <span class="o">!=</span> <span class="n">UIGestureRecognizerStateEnded</span><span class="p">) {</span>
        <span class="k">return</span><span class="p">;
    }</span>
    <span class="bp">CGPoint</span> <span class="n">p</span> <span class="o">=</span> <span class="p">[</span><span class="n">gr</span> <span class="nl">locationInView</span><span class="p">:</span><span class="nb">self</span><span class="p">];</span>

    <span class="c1">// Close the menu if it&#39;s currently open.</span>
    <span class="bp">UIMenuController</span> <span class="o">*</span><span class="n">menu</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIMenuController</span> <span class="n">sharedMenuController</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">([</span><span class="n">menu isMenuVisible</span><span class="p">]) {
        [</span><span class="n">menu</span> <span class="nl">setMenuVisible</span><span class="p">:</span><span class="nb">NO</span> <span class="nl">animated</span><span class="p">:</span><span class="nb">YES</span><span class="p">];
        [</span><span class="nb">self</span> <span class="n">setNeedsDisplay</span><span class="p">];</span>
        <span class="k">return</span><span class="p">;
    }</span>

    <span class="c1">// In the game over state, bring up the menu for any kind of tap.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">==</span> <span class="n">GAME_OVER</span><span class="p">) {
        [</span><span class="nb">self</span> <span class="nl">showMenuAtPoint</span><span class="p">:</span><span class="n">p</span><span class="p">];</span>
        <span class="k">return</span><span class="p">;
    }</span>

    <span class="kt">int</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">([</span><span class="nb">self</span> <span class="nl">hitTest</span><span class="p">:</span><span class="n">p</span> <span class="nl">withHitRow</span><span class="p">:</span><span class="o">&amp;</span><span class="n">row</span> <span class="nl">hitCol</span><span class="p">:</span><span class="o">&amp;</span><span class="n">col</span><span class="p">]) {
        [</span><span class="n">delegate</span> <span class="nl">boardWasTappedAtRow</span><span class="p">:</span><span class="n">row</span> <span class="nl">col</span><span class="p">:</span><span class="n">col</span><span class="p">];
    }
}

- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">onLongPress:</span><span class="p">(</span><span class="bp">UIGestureRecognizer</span><span class="o">*</span><span class="p">)</span><span class="nv">gr</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">gr</span><span class="p">.</span><span class="n">state</span> <span class="o">!=</span> <span class="n">UIGestureRecognizerStateBegan</span> <span class="o">||</span> <span class="n">state</span> <span class="o">==</span> <span class="n">WHITES_MOVE</span><span class="p">) {</span>
        <span class="k">return</span><span class="p">;
    }

    [</span><span class="nb">self</span> <span class="nl">showMenuAtPoint</span><span class="p">:[</span><span class="n">gr</span> <span class="nl">locationInView</span><span class="p">:</span><span class="nb">self</span><span class="p">]];
}

- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">showMenuAtPoint:</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="nv">p</span> <span class="p">{
    [</span><span class="nb">self</span> <span class="n">becomeFirstResponder</span><span class="p">];</span>
    <span class="bp">UIMenuController</span> <span class="o">*</span><span class="n">menu</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIMenuController</span> <span class="n">sharedMenuController</span><span class="p">];</span>
    <span class="bp">UIMenuItem</span> <span class="o">*</span><span class="n">newGameItem</span> <span class="o">=</span>
            <span class="p">[[</span><span class="bp">UIMenuItem</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithTitle</span><span class="p">:</span><span class="s">@&quot;New Game&quot;</span>
                                       <span class="nl">action</span><span class="p">:</span><span class="k">@selector</span><span class="p">(</span><span class="nl">onNewGameMenu</span><span class="p">:)];</span>
    <span class="n">menu</span><span class="p">.</span><span class="n">menuItems</span> <span class="o">=</span> <span class="l">@[</span> <span class="n">newGameItem</span> <span class="l">]</span><span class="p">;
    [</span><span class="n">menu</span> <span class="nl">setTargetRect</span><span class="p">:</span><span class="n">CGRectMake</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="nl">inView</span><span class="p">:</span><span class="nb">self</span><span class="p">];
    [</span><span class="n">menu</span> <span class="nl">setMenuVisible</span><span class="p">:</span><span class="nb">YES</span> <span class="nl">animated</span><span class="p">:</span><span class="nb">YES</span><span class="p">];

    [</span><span class="nb">self</span> <span class="n">setNeedsDisplay</span><span class="p">];
}

- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">onNewGameMenu:</span><span class="p">(</span><span class="kt">id</span><span class="p">)</span><span class="nv">sender</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">WHITES_MOVE</span><span class="p">);
    [</span><span class="n">delegate newGame</span><span class="p">];
}</span>
</pre></div>


<p>(The <span class="code">@[ foo ]</span> syntax is short-hand for creating an <span class="code">NSArray</span>.)</p>

<p>When we're notified that the game state has changed, we note the new state and request re-drawing:</p>

<div class="highlight"><pre><span></span><span class="p">- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">updateWithState:</span><span class="p">(</span><span class="k">enum</span> <span class="n">State</span><span class="p">)</span><span class="nv">s</span> <span class="p">{</span>
    <span class="n">state</span> <span class="o">=</span> <span class="n">s</span><span class="p">;
    [</span><span class="nb">self</span> <span class="n">setNeedsDisplay</span><span class="p">];
}</span>
</pre></div>


<p>That drawing is done by the code below which, as well as the hit testing, is the same as in the Mac version except for a few names being slightly different:</p>

<div class="highlight"><pre><span></span><span class="k">static const</span> <span class="kt">int</span> <span class="n">CELL_GAP</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;

- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">drawRect:</span><span class="p">(</span><span class="bp">CGRect</span><span class="p">)</span><span class="nv">rect</span> <span class="p">{</span>
    <span class="c1">// Compute size and position of the 10x10 grid.</span>
    <span class="bp">CGRect</span> <span class="n">bounds</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="n">bounds</span><span class="p">];</span>
    <span class="kt">float</span> <span class="n">viewSize</span> <span class="o">=</span> <span class="n">MIN</span><span class="p">(</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span><span class="p">);</span>
    <span class="n">cellSize</span> <span class="o">=</span> <span class="p">(</span><span class="n">viewSize</span> <span class="o">-</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">CELL_GAP</span><span class="p">)</span> <span class="o">/</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">size</span> <span class="o">=</span> <span class="n">cellSize</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">CELL_GAP</span><span class="p">;</span>
    <span class="n">xOffset</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">yOffset</span> <span class="o">=</span> <span class="n">bounds</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

    <span class="c1">// Draw a background square around the 8x8 cells.</span>
    <span class="p">[[</span><span class="bp">UIColor</span> <span class="n">blackColor</span><span class="p">]</span> <span class="n">set</span><span class="p">];</span>
    <span class="bp">CGRect</span> <span class="n">backgroundRect</span> <span class="o">=</span>
        <span class="n">CGRectMake</span><span class="p">(</span><span class="n">xOffset</span> <span class="o">+</span> <span class="n">cellSize</span><span class="p">,</span> <span class="n">yOffset</span> <span class="o">+</span> <span class="n">cellSize</span><span class="p">,</span>
                   <span class="mi">8</span> <span class="o">*</span> <span class="n">cellSize</span> <span class="o">+</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">CELL_GAP</span><span class="p">,</span> <span class="mi">8</span> <span class="o">*</span> <span class="n">cellSize</span> <span class="o">+</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">CELL_GAP</span><span class="p">);
    [[</span><span class="bp">UIBezierPath</span> <span class="nl">bezierPathWithRect</span><span class="p">:</span><span class="n">backgroundRect</span><span class="p">]</span> <span class="n">fill</span><span class="p">];</span>

    <span class="c1">// Draw labels.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">) {</span>
        <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="n">xOffset</span> <span class="o">+</span> <span class="n">cellSize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="n">yOffset</span> <span class="o">+</span> <span class="p">(</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">cellSize</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="p">)</span> <span class="o">+</span> <span class="n">cellSize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;
        [</span><span class="nb">self</span> <span class="nl">drawChar</span><span class="p">:(</span><span class="sc">&#39;1&#39;</span> <span class="o">+</span> <span class="n">row</span><span class="p">)</span> <span class="nl">atPoint</span><span class="p">:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)];
    }</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">col</span><span class="o">++</span><span class="p">) {</span>
        <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="n">xOffset</span> <span class="o">+</span> <span class="p">(</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">cellSize</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="p">)</span> <span class="o">+</span> <span class="n">cellSize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="n">yOffset</span> <span class="o">+</span> <span class="n">cellSize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;
        [</span><span class="nb">self</span> <span class="nl">drawChar</span><span class="p">:(</span><span class="sc">&#39;A&#39;</span> <span class="o">+</span> <span class="n">col</span><span class="p">)</span> <span class="nl">atPoint</span><span class="p">:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)];
    }</span>

    <span class="c1">// Draw status text.</span>
    <span class="bp">NSString</span> <span class="o">*</span><span class="n">statusText</span><span class="p">;</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">) {</span>
    <span class="k">case</span> <span class="nl">BLACKS_MOVE</span><span class="p">:</span>
        <span class="n">statusText</span> <span class="o">=</span> <span class="s">@&quot;Human&#39;s move.&quot;</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">WHITES_MOVE</span><span class="p">:</span>
        <span class="n">statusText</span> <span class="o">=</span> <span class="s">@&quot;Computer&#39;s move...&quot;</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="nl">GAME_OVER</span><span class="p">: {</span>
        <span class="kt">int</span> <span class="n">blackScore</span> <span class="o">=</span> <span class="n">othello_score</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_BLACK</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">whiteScore</span> <span class="o">=</span> <span class="n">othello_score</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">PLAYER_WHITE</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">blackScore</span> <span class="o">&gt;</span> <span class="n">whiteScore</span><span class="p">) {</span>
            <span class="n">statusText</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;Human wins %d-%d!&quot;</span><span class="p">,</span>
                                                    <span class="n">blackScore</span><span class="p">,</span> <span class="n">whiteScore</span><span class="p">];
        }</span> <span class="k">else if</span> <span class="p">(</span><span class="n">whiteScore</span> <span class="o">&gt;</span> <span class="n">blackScore</span><span class="p">) {</span>
            <span class="n">statusText</span> <span class="o">=</span> <span class="p">[</span><span class="bp">NSString</span> <span class="nl">stringWithFormat</span><span class="p">:</span><span class="s">@&quot;Computer wins %d-%d!&quot;</span><span class="p">,</span>
                                                    <span class="n">whiteScore</span><span class="p">,</span> <span class="n">blackScore</span><span class="p">];
        }</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">statusText</span> <span class="o">=</span> <span class="s">@&quot;Draw!&quot;</span><span class="p">;
        }</span>
        <span class="k">break</span><span class="p">;
        }
    }
    [</span><span class="nb">self</span> <span class="nl">drawString</span><span class="p">:</span><span class="n">statusText</span> <span class="nl">atPoint</span><span class="p">:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="n">xOffset</span> <span class="o">+</span> <span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
            <span class="n">yOffset</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="n">cellSize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)];</span>

    <span class="c1">// Draw the cells.</span>
    <span class="bp">UIColor</span> <span class="o">*</span><span class="n">boardColor</span> <span class="o">=</span>
        <span class="p">[</span><span class="bp">UIColor</span> <span class="nl">colorWithRed</span><span class="p">:</span><span class="mi">0</span> <span class="nl">green</span><span class="p">:(</span><span class="mh">0x80</span> <span class="o">/</span> <span class="mf">256.0</span><span class="p">)</span> <span class="nl">blue</span><span class="p">:</span><span class="mi">0</span> <span class="nl">alpha</span><span class="p">:</span><span class="mf">1.0</span><span class="p">];</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">row</span><span class="o">++</span><span class="p">) {</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">col</span><span class="o">++</span><span class="p">) {</span>
            <span class="kt">float</span> <span class="n">x</span> <span class="o">=</span> <span class="n">xOffset</span> <span class="o">+</span> <span class="p">(</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">cellSize</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="p">);</span>
            <span class="kt">float</span> <span class="n">y</span> <span class="o">=</span> <span class="n">yOffset</span> <span class="o">+</span> <span class="p">(</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">cellSize</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="p">);</span>

            <span class="c1">// Draw the cell background.</span>
            <span class="p">[</span><span class="n">boardColor set</span><span class="p">];</span>
            <span class="bp">CGRect</span> <span class="n">cellRect</span> <span class="o">=</span> <span class="n">CGRectMake</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">,</span> <span class="n">cellSize</span><span class="p">);
            [[</span><span class="bp">UIBezierPath</span> <span class="nl">bezierPathWithRect</span><span class="p">:</span><span class="n">cellRect</span><span class="p">]</span> <span class="n">fill</span><span class="p">];</span>

            <span class="c1">// Draw the disk, if any.</span>
            <span class="bp">UIBezierPath</span> <span class="o">*</span><span class="n">diskPath</span> <span class="o">=</span>
                <span class="p">[</span><span class="bp">UIBezierPath</span> <span class="nl">bezierPathWithOvalInRect</span><span class="p">:</span><span class="n">cellRect</span><span class="p">];</span>
            <span class="k">switch</span> <span class="p">(</span><span class="n">othello_cell_state</span><span class="p">(</span><span class="n">board</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)) {</span>
            <span class="k">case</span> <span class="nl">CELL_BLACK</span><span class="p">:
                [[</span><span class="bp">UIColor</span> <span class="n">blackColor</span><span class="p">]</span> <span class="n">set</span><span class="p">];
                [</span><span class="n">diskPath fill</span><span class="p">];</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="nl">CELL_WHITE</span><span class="p">:
                [[</span><span class="bp">UIColor</span> <span class="n">whiteColor</span><span class="p">]</span> <span class="n">set</span><span class="p">];
                [</span><span class="n">diskPath fill</span><span class="p">];</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="k">default</span><span class="o">:</span>
                <span class="k">break</span><span class="p">;
            }
        }
    }
}

- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">drawChar:</span><span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="nv">c</span> <span class="nf">atPoint:</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="nv">p</span> <span class="p">{</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="n">s</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">};
    [</span><span class="nb">self</span> <span class="nl">drawString</span><span class="p">:[</span><span class="bp">NSString</span> <span class="nl">stringWithUTF8String</span><span class="p">:</span><span class="n">s</span><span class="p">]</span> <span class="nl">atPoint</span><span class="p">:</span><span class="n">p</span><span class="p">];
}

- (</span><span class="kt">void</span><span class="p">)</span><span class="nf">drawString:</span><span class="p">(</span><span class="bp">NSString</span><span class="o">*</span><span class="p">)</span><span class="nv">s</span> <span class="nf">atPoint:</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="nv">p</span> <span class="p">{</span>
    <span class="bp">UIColor</span> <span class="o">*</span><span class="n">color</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIColor</span> <span class="n">blackColor</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(@</span><span class="n">available</span><span class="p">(</span><span class="n">iOS</span> <span class="mf">13.0</span><span class="p">,</span> <span class="o">*</span><span class="p">)) {</span>
        <span class="n">color</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIColor</span> <span class="n">labelColor</span><span class="p">];
    }</span>
    <span class="bp">UIFont</span> <span class="o">*</span><span class="n">font</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIFont</span> <span class="nl">preferredFontForTextStyle</span><span class="p">:</span><span class="n">UIFontTextStyleBody</span><span class="p">];</span>
    <span class="bp">NSAttributedString</span> <span class="o">*</span><span class="n">as</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">NSAttributedString</span> <span class="n">alloc</span><span class="p">]</span>
        <span class="nl">initWithString</span><span class="p">:</span><span class="n">s</span> <span class="nl">attributes</span><span class="p">:</span><span class="l">@{</span><span class="nl">NSFontAttributeName</span><span class="p">:</span> <span class="n">font</span><span class="p">,</span>
                                      <span class="nl">NSForegroundColorAttributeName</span><span class="p">:</span> <span class="n">color</span>
        <span class="l">}</span><span class="p">];</span>
    <span class="bp">CGSize</span> <span class="n">stringSize</span> <span class="o">=</span> <span class="p">[</span><span class="n">as size</span><span class="p">];
    [</span><span class="n">as</span> <span class="nl">drawAtPoint</span><span class="p">:</span><span class="n">CGPointMake</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">stringSize</span><span class="p">.</span><span class="n">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
                                <span class="n">p</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">stringSize</span><span class="p">.</span><span class="n">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)];
}

- (</span><span class="kt">BOOL</span><span class="p">)</span><span class="nf">hitTest:</span><span class="p">(</span><span class="bp">CGPoint</span><span class="p">)</span><span class="nv">p</span> <span class="nf">withHitRow:</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="nv">row</span> <span class="nf">hitCol:</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="nv">col</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">row</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">p</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">yOffset</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">cellSize</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="o">*</span><span class="n">col</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">p</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">xOffset</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">cellSize</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp; *</span><span class="n">row</span> <span class="o">&lt;</span> <span class="mi">8</span> <span class="o">&amp;&amp; *</span><span class="n">col</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp; *</span><span class="n">col</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">) {</span>
        <span class="k">return</span> <span class="nb">YES</span><span class="p">;
    }</span>

    <span class="k">return</span> <span class="nb">NO</span><span class="p">;
}</span>

<span class="k">@end</span>
</pre></div>


<a name="ios_build"></a>
<h4>Building</h4>

<p>The process of building, and in particular dealing with signing and getting applications onto a hardware device, is complicated. It's easy from within Xcode, but although it should of course be technically possible, I haven't figured out how to do it from the command line.</p>

<p>This is what the program looks like on an iPhone SE:</p>

<div style="text-align: center">
<img src="gfx/ios_othello.jpg" alt="Photo of the Othello program on iPhone SE.">
</div>


<a name="android"></a>
<h3>Android</h3>

<p>Android is Google's open-source mobile operating system. The first Android phone, the G1, was <a href="https://techcrunch.com/2008/09/23/t-mobile-officially-announces-the-g1-android-phone/">announced</a> in September 2008. Today, the system is used by most phone manufacturers besides Apple, and has become the most popular operating system on mobile with more than <a href="https://www.youtube.com/watch?v=Y2VF8tmLFHw&amp;t=6m21s">two billion</a> active devices.</p>

<p>Applications on Android are typically written in the Java language using custom libraries, and compiled to bytecode run by a custom virtual machine (originally <a href="https://en.wikipedia.org/wiki/Dalvik_%28software%29">Dalvik</a>, later <a href="https://en.wikipedia.org/wiki/Android_Runtime">ART</a>). This programming model means we have to work a little harder to reuse the C code for our Othello engine.</p>

<p>To learn about Android programming, I read Phillips, Stewart, Hardy &amp; Marsicano "Android Programming: The Big Nerd Ranch Guide" (2nd edition). In the process of figuring things out, I wrote a separate post about <a href="command-line-android.html">building Android apps from the command-line</a>.</p>


<a name="android_main"></a>
<h4>Manifest, Resources, and Main Activity</h4>

<p>In the app manifest, <a href="files/othello/android/AndroidManifest.xml"><span class="code">AndroidManifest.xml</span></a> shown below, we specify the application name, version, icon, and most importantly the entry point, which in our case is <span class="code">OthelloActivity</span>. We also specify the minimum API version our application targets, which affects what library functions we can use. Since we don't need anything fancy, our app will target API version 16, which according to <a href="https://developer.android.com/about/dashboards/index.html#Platform">this dashboard</a>, is supported by 98% of all active Android devices.</p>

<div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
<span class="nt">&lt;manifest</span> <span class="na">xmlns:android=</span><span class="s">&quot;http://schemas.android.com/apk/res/android&quot;</span>
          <span class="na">package=</span><span class="s">&quot;net.hanshq.othello&quot;</span>
          <span class="na">android:versionCode=</span><span class="s">&quot;1&quot;</span>
          <span class="na">android:versionName=</span><span class="s">&quot;1.0&quot;</span><span class="nt">&gt;
    &lt;uses-sdk</span> <span class="na">android:minSdkVersion=</span><span class="s">&quot;16&quot;</span><span class="nt">/&gt;
    &lt;application</span> <span class="na">android:label=</span><span class="s">&quot;Othello&quot;</span> <span class="na">android:icon=</span><span class="s">&quot;@drawable/icon&quot;</span><span class="nt">&gt;
        &lt;activity</span> <span class="na">android:name=</span><span class="s">&quot;.OthelloActivity&quot;</span><span class="nt">&gt;
            &lt;intent-filter&gt;
                &lt;action</span> <span class="na">android:name=</span><span class="s">&quot;android.intent.action.MAIN&quot;</span><span class="nt">/&gt;
                &lt;category</span> <span class="na">android:name=</span><span class="s">&quot;android.intent.category.LAUNCHER&quot;</span><span class="nt">/&gt;
            &lt;/intent-filter&gt;
        &lt;/activity&gt;
    &lt;/application&gt;
&lt;/manifest&gt;</span>
</pre></div>


<p>Besides the icon referred to in the manifest, our application includes a few other resources. Below is <a href="files/othello/android/res/menu/menu_othello.xml"><span class="code">menu_othello.xml</span></a>, which defines the menu (the reverse name seems to be an Android convenition). The <span class="code">@+id</span> syntax in the menu item defines a new resource id, which we will use to refer to that menu item in the code.</p>

<div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
<span class="nt">&lt;menu</span> <span class="na">xmlns:android=</span><span class="s">&quot;http://schemas.android.com/apk/res/android&quot;</span><span class="nt">&gt;
    &lt;item</span>
        <span class="na">android:id=</span><span class="s">&quot;@+id/menu_item_new_game&quot;</span>
        <span class="na">android:title=</span><span class="s">&quot;New Game&quot;</span><span class="nt">/&gt;
&lt;/menu&gt;</span>
</pre></div>


<p>We also have a resource file that defines the <em>layout</em> of our main and only screen: <a href="files/othello/android/res/layout/activity_othello.xml"><span class="code">activity_othello.xml</span></a> below. Layouts are usually created in Android Studio, but the format is not too verbose, so I wrote this one by hand. It simply specifies that we'd like an <span class="code">OthelloView</span> to cover the whole layout area with a small margin. As with the menu, we use <span class="code">@+id</span> to create an identifier for the view:</p>

<div class="highlight"><pre><span></span><span class="cp">&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;</span>
<span class="nt">&lt;LinearLayout</span>
    <span class="na">xmlns:android=</span><span class="s">&quot;http://schemas.android.com/apk/res/android&quot;</span>
    <span class="na">android:layout_width=</span><span class="s">&quot;match_parent&quot;</span>
    <span class="na">android:layout_height=</span><span class="s">&quot;match_parent&quot;</span>
    <span class="na">android:gravity=</span><span class="s">&quot;center&quot;</span>
    <span class="na">android:orientation=</span><span class="s">&quot;vertical&quot;</span>
    <span class="na">android:background=</span><span class="s">&quot;#000000&quot;</span><span class="nt">&gt;

    &lt;net.hanshq.othello.OthelloView</span>
        <span class="na">android:id=</span><span class="s">&quot;@+id/othello_view&quot;</span>
        <span class="na">android:layout_width=</span><span class="s">&quot;match_parent&quot;</span>
        <span class="na">android:layout_height=</span><span class="s">&quot;match_parent&quot;</span>
        <span class="na">android:layout_margin=</span><span class="s">&quot;4dp&quot;</span><span class="nt">/&gt;
&lt;/LinearLayout&gt;</span>
</pre></div>


<p>Android applications are organized around <em>activities</em>, which represent screens with user interfaces. Our Othello application only has a single screen, and it is implemented in <a href="files/othello/android/java/net/hanshq/reversi/OthelloActivity.java"><span class="code">OthelloActivity.java</span></a> below.

<p>We use this class to act as the controller: it owns the model of the game (the state enum, and the <span class="code">OthelloBoard</span> implemented in the next section), updates the game state in response to user actions, and controls the view of the game:</p>

<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">net.hanshq.othello</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">android.app.Activity</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">android.os.AsyncTask</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">android.os.Bundle</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">android.view.Menu</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">android.view.MenuItem</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">android.widget.TextView</span><span class="o">;</span>

<span class="kd">public class</span> <span class="nc">OthelloActivity</span> <span class="kd">extends</span> <span class="n">Activity</span>
        <span class="kd">implements</span> <span class="n">OthelloView</span><span class="o">.</span><span class="na">TouchHandler</span> <span class="o">{</span>
    <span class="kd">private static final</span> <span class="n">String BOARD_KEY</span> <span class="o">=</span> <span class="s">&quot;board&quot;</span><span class="o">;</span>
    <span class="kd">private static final</span> <span class="n">String STATE_KEY</span> <span class="o">=</span> <span class="s">&quot;state&quot;</span><span class="o">;</span>

    <span class="kd">public enum</span> <span class="n">State</span> <span class="o">{</span> <span class="n">BLACKS_MOVE</span><span class="o">,</span> <span class="n">WHITES_MOVE</span><span class="o">,</span> <span class="n">GAME_OVER</span> <span class="o">}</span>

    <span class="kd">private</span> <span class="n">State mState</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">OthelloView mView</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">OthelloBoard mBoard</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">ComputeWhiteMoveTask mWhiteMoveTask</span><span class="o">;</span>
</pre></div>


<p>When the application starts, we set the view of the screen to the layout defined in the resource file above. The special <span class="code">R</span> class is used to access resources in the application. Our <span class="code">OthelloView</span> (which will be implemented further below) is instantiated by the layout, and we get a reference to it via the <span class="code">R</span> class using the resource id we defined.</p>

<p>As on iOS, it's important to save and restore the game state in case the application gets killed by the operating system while the user is doing something else. On Android, this is done by storing the data in a <span class="code">Bundle</span>.</p>

<div class="highlight"><pre><span></span>    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onCreate</span><span class="o">(</span><span class="n">Bundle savedInstanceState</span><span class="o">) {</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onCreate</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>
        <span class="n">setContentView</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">layout</span><span class="o">.</span><span class="na">activity_othello</span><span class="o">);</span>

        <span class="n">mBoard</span> <span class="o">=</span> <span class="k">new</span> <span class="n">OthelloBoard</span><span class="o">();</span>
        <span class="n">mView</span> <span class="o">= (</span><span class="n">OthelloView</span><span class="o">)</span><span class="n">findViewById</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">othello_view</span><span class="o">);</span>
        <span class="n">mView</span><span class="o">.</span><span class="na">setBoard</span><span class="o">(</span><span class="n">mBoard</span><span class="o">);</span>
        <span class="n">mView</span><span class="o">.</span><span class="na">setTouchHandler</span><span class="o">(</span><span class="k">this</span><span class="o">);</span>
        <span class="n">newGame</span><span class="o">();</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">savedInstanceState</span> <span class="o">!=</span> <span class="kc">null</span><span class="o">) {</span>
            <span class="kt">byte</span><span class="o">[]</span> <span class="n">boardBytes</span> <span class="o">=</span> <span class="n">savedInstanceState</span><span class="o">.</span><span class="na">getByteArray</span><span class="o">(</span><span class="n">BOARD_KEY</span><span class="o">);</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="o">;</span> <span class="n">row</span><span class="o">++) {</span>
                <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="o">;</span> <span class="n">col</span><span class="o">++) {</span>
                    <span class="n">mBoard</span><span class="o">.</span><span class="na">setCellState</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">col</span><span class="o">,</span> <span class="n">boardBytes</span><span class="o">[</span><span class="n">row</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">col</span><span class="o">]);
                }
            }</span>

            <span class="n">mState</span> <span class="o">=</span> <span class="n">State</span><span class="o">.</span><span class="na">values</span><span class="o">()[</span><span class="n">savedInstanceState</span><span class="o">.</span><span class="na">getInt</span><span class="o">(</span><span class="n">STATE_KEY</span><span class="o">)];</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">mState</span> <span class="o">==</span> <span class="n">State</span><span class="o">.</span><span class="na">WHITES_MOVE</span><span class="o">) {</span>
                <span class="n">computeWhiteMove</span><span class="o">();
            }</span>

            <span class="n">mView</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">mState</span><span class="o">);
        }
    }</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onSaveInstanceState</span><span class="o">(</span><span class="n">Bundle savedInstanceState</span><span class="o">) {</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onSaveInstanceState</span><span class="o">(</span><span class="n">savedInstanceState</span><span class="o">);</span>

        <span class="kt">byte</span><span class="o">[]</span> <span class="n">boardBytes</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">byte</span><span class="o">[</span><span class="mi">64</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="o">;</span> <span class="n">row</span><span class="o">++) {</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="o">;</span> <span class="n">col</span><span class="o">++) {</span>
                <span class="n">boardBytes</span><span class="o">[</span><span class="n">row</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">+</span> <span class="n">col</span><span class="o">] = (</span><span class="kt">byte</span><span class="o">)</span><span class="n">mBoard</span><span class="o">.</span><span class="na">getCellState</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">col</span><span class="o">);
            }
        }</span>

        <span class="n">savedInstanceState</span><span class="o">.</span><span class="na">putByteArray</span><span class="o">(</span><span class="n">BOARD_KEY</span><span class="o">,</span> <span class="n">boardBytes</span><span class="o">);</span>
        <span class="n">savedInstanceState</span><span class="o">.</span><span class="na">putInt</span><span class="o">(</span><span class="n">STATE_KEY</span><span class="o">,</span> <span class="n">mState</span><span class="o">.</span><span class="na">ordinal</span><span class="o">());
    }</span>
</pre></div>


<p>To set up the menu, we override the <span class="code">onCreateOptionsMenu</span> method and install the menu from the resource file above. The system will then call <span class="code">onOptionsItemSelected</span> when a menu item is invoked, and we can check if it's the "new game" menu item by referencing it via the <span class="code">R</span> object:</p>

<div class="highlight"><pre><span></span>    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">onCreateOptionsMenu</span><span class="o">(</span><span class="n">Menu menu</span><span class="o">) {</span>
        <span class="n">getMenuInflater</span><span class="o">().</span><span class="na">inflate</span><span class="o">(</span><span class="n">R</span><span class="o">.</span><span class="na">menu</span><span class="o">.</span><span class="na">menu_othello</span><span class="o">,</span> <span class="n">menu</span><span class="o">);</span>
        <span class="k">return</span> <span class="kc">true</span><span class="o">;
    }</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">onOptionsItemSelected</span><span class="o">(</span><span class="n">MenuItem item</span><span class="o">) {</span>
        <span class="k">switch</span> <span class="o">(</span><span class="n">item</span><span class="o">.</span><span class="na">getItemId</span><span class="o">()) {</span>
        <span class="k">case</span> <span class="n">R</span><span class="o">.</span><span class="na">id</span><span class="o">.</span><span class="na">menu_item_new_game</span><span class="o">:</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">mState</span> <span class="o">!=</span> <span class="n">State</span><span class="o">.</span><span class="na">WHITES_MOVE</span><span class="o">) {</span>
                <span class="n">newGame</span><span class="o">();
            }</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="k">return</span> <span class="kd">super</span><span class="o">.</span><span class="na">onOptionsItemSelected</span><span class="o">(</span><span class="n">item</span><span class="o">);
        }
    }</span>
</pre></div>


<p>We implement the logic for updating the game state much the same as in the other versions:</p>

<div class="highlight"><pre><span></span>    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">newGame</span><span class="o">() {</span>
        <span class="n">mState</span> <span class="o">=</span> <span class="n">State</span><span class="o">.</span><span class="na">BLACKS_MOVE</span><span class="o">;</span>
        <span class="n">mBoard</span><span class="o">.</span><span class="na">reset</span><span class="o">();</span>
        <span class="n">mView</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">mState</span><span class="o">);
    }</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onTouch</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">) {</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">mState</span> <span class="o">==</span> <span class="n">State</span><span class="o">.</span><span class="na">BLACKS_MOVE</span><span class="o">) {</span>
            <span class="n">makeMove</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">col</span><span class="o">);
        }
    }</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">makeMove</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">) {</span>
        <span class="k">assert</span><span class="o">(</span><span class="n">mState</span> <span class="o">==</span> <span class="n">State</span><span class="o">.</span><span class="na">BLACKS_MOVE</span> <span class="o">||</span> <span class="n">mState</span> <span class="o">==</span> <span class="n">State</span><span class="o">.</span><span class="na">WHITES_MOVE</span><span class="o">);</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">mState</span> <span class="o">==</span> <span class="n">State</span><span class="o">.</span><span class="na">BLACKS_MOVE</span><span class="o">) {</span>
            <span class="k">if</span> <span class="o">(!</span><span class="n">mBoard</span><span class="o">.</span><span class="na">isValidMove</span><span class="o">(</span><span class="n">OthelloBoard</span><span class="o">.</span><span class="na">PLAYER_BLACK</span><span class="o">,</span> <span class="n">row</span><span class="o">,</span> <span class="n">col</span><span class="o">)) {</span>
                <span class="c1">// Illegal move; ignored.</span>
                <span class="k">return</span><span class="o">;
            }</span>

            <span class="n">mBoard</span><span class="o">.</span><span class="na">makeMove</span><span class="o">(</span><span class="n">OthelloBoard</span><span class="o">.</span><span class="na">PLAYER_BLACK</span><span class="o">,</span> <span class="n">row</span><span class="o">,</span> <span class="n">col</span><span class="o">);</span>
            <span class="n">mState</span> <span class="o">=</span> <span class="n">State</span><span class="o">.</span><span class="na">WHITES_MOVE</span><span class="o">;
        }</span> <span class="k">else</span> <span class="o">{</span>
            <span class="n">mBoard</span><span class="o">.</span><span class="na">makeMove</span><span class="o">(</span><span class="n">OthelloBoard</span><span class="o">.</span><span class="na">PLAYER_WHITE</span><span class="o">,</span> <span class="n">row</span><span class="o">,</span> <span class="n">col</span><span class="o">);</span>
            <span class="n">mState</span> <span class="o">=</span> <span class="n">State</span><span class="o">.</span><span class="na">BLACKS_MOVE</span><span class="o">;
        }</span>

        <span class="k">if</span> <span class="o">(!</span><span class="n">mBoard</span><span class="o">.</span><span class="na">hasValidMove</span><span class="o">(</span><span class="n">OthelloBoard</span><span class="o">.</span><span class="na">PLAYER_BLACK</span><span class="o">) &amp;&amp;
                !</span><span class="n">mBoard</span><span class="o">.</span><span class="na">hasValidMove</span><span class="o">(</span><span class="n">OthelloBoard</span><span class="o">.</span><span class="na">PLAYER_WHITE</span><span class="o">)) {</span>
            <span class="n">mState</span> <span class="o">=</span> <span class="n">State</span><span class="o">.</span><span class="na">GAME_OVER</span><span class="o">;
        }</span> <span class="k">else if</span> <span class="o">(</span><span class="n">mState</span> <span class="o">==</span> <span class="n">State</span><span class="o">.</span><span class="na">BLACKS_MOVE</span> <span class="o">&amp;&amp;
                !</span><span class="n">mBoard</span><span class="o">.</span><span class="na">hasValidMove</span><span class="o">(</span><span class="n">OthelloBoard</span><span class="o">.</span><span class="na">PLAYER_BLACK</span><span class="o">)) {</span>
            <span class="n">mState</span> <span class="o">=</span> <span class="n">State</span><span class="o">.</span><span class="na">WHITES_MOVE</span><span class="o">;
        }</span> <span class="k">else if</span> <span class="o">(</span><span class="n">mState</span> <span class="o">==</span> <span class="n">State</span><span class="o">.</span><span class="na">WHITES_MOVE</span> <span class="o">&amp;&amp;
                !</span><span class="n">mBoard</span><span class="o">.</span><span class="na">hasValidMove</span><span class="o">(</span><span class="n">OthelloBoard</span><span class="o">.</span><span class="na">PLAYER_WHITE</span><span class="o">)) {</span>
            <span class="n">mState</span> <span class="o">=</span> <span class="n">State</span><span class="o">.</span><span class="na">BLACKS_MOVE</span><span class="o">;
        }</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">mState</span> <span class="o">==</span> <span class="n">State</span><span class="o">.</span><span class="na">WHITES_MOVE</span><span class="o">) {</span>
            <span class="n">computeWhiteMove</span><span class="o">();
        }</span>

        <span class="n">mView</span><span class="o">.</span><span class="na">update</span><span class="o">(</span><span class="n">mState</span><span class="o">);
    }</span>
</pre></div>


<p>To compute white's move on a background thread, we use an <a href="https://developer.android.com/reference/android/os/AsyncTask.html">AsyncTask</a>:</p>

<div class="highlight"><pre><span></span>    <span class="kd">private class</span> <span class="nc">ComputeWhiteMoveTask</span> <span class="kd">extends</span> <span class="n">AsyncTask</span><span class="o">&lt;</span><span class="n">Void</span><span class="o">,</span> <span class="n">Void</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]&gt; {</span>
        <span class="nd">@Override</span>
        <span class="kd">protected</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">doInBackground</span><span class="o">(</span><span class="n">Void</span><span class="o">...</span> <span class="n">args</span><span class="o">) {</span>
            <span class="k">return</span> <span class="n">mBoard</span><span class="o">.</span><span class="na">computeMove</span><span class="o">(</span><span class="n">OthelloBoard</span><span class="o">.</span><span class="na">PLAYER_WHITE</span><span class="o">);
        }</span>
        <span class="nd">@Override</span>
        <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onPostExecute</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">result</span><span class="o">) {</span>
            <span class="n">makeMove</span><span class="o">(</span><span class="n">result</span><span class="o">[</span><span class="mi">0</span><span class="o">],</span> <span class="n">result</span><span class="o">[</span><span class="mi">1</span><span class="o">]);
        }
    }</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">computeWhiteMove</span><span class="o">() {</span>
        <span class="n">mWhiteMoveTask</span> <span class="o">=</span> <span class="k">new</span> <span class="n">ComputeWhiteMoveTask</span><span class="o">();</span>
        <span class="n">mWhiteMoveTask</span><span class="o">.</span><span class="na">execute</span><span class="o">();
    }</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onDestroy</span><span class="o">() {</span>
        <span class="kd">super</span><span class="o">.</span><span class="na">onDestroy</span><span class="o">();</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">mState</span> <span class="o">==</span> <span class="n">State</span><span class="o">.</span><span class="na">WHITES_MOVE</span><span class="o">) {</span>
            <span class="n">mWhiteMoveTask</span><span class="o">.</span><span class="na">cancel</span><span class="o">(</span><span class="kc">false</span><span class="o">);
        }</span>
        <span class="n">mBoard</span><span class="o">.</span><span class="na">destroy</span><span class="o">();
    }
}</span>
</pre></div>


<a name="android_jni"></a>
<h4>Accessing the Othello Engine</h4>

<p>Since our Othello engine is implemented in C, we need to use the Java Native Interface (JNI) to access it. In essence, this means we will have a class with method declarations marked <span class="code">native</span>, which we implement in C and compile into a shared library. See <a href="command-line-android.html#native">my other post</a> for more details.</p>

<p>In <a href="files/othello/android/java/net/hanshq/reversi/OthelloBoard.java"><span class="code">OthelloBoard.java</span></a>, we implement a class that "wraps" our Othello engine in an interface we can use from the rest of our Java code:</p>

<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">net.hanshq.othello</span><span class="o">;</span>

<span class="kd">public class</span> <span class="nc">OthelloBoard</span> <span class="o">{</span>
    <span class="kd">static</span> <span class="o">{</span> <span class="n">System</span><span class="o">.</span><span class="na">loadLibrary</span><span class="o">(</span><span class="s">&quot;othello&quot;</span><span class="o">); }</span>

    <span class="kd">private</span> <span class="kt">long</span> <span class="n">mNativeBoard</span><span class="o">;</span>
    <span class="kd">private native</span> <span class="kt">void</span> <span class="nf">nativeInit</span><span class="o">();</span>
    <span class="kd">private native</span> <span class="kt">void</span> <span class="nf">nativeDestroy</span><span class="o">();</span>

    <span class="c1">// These must match the native implementation&#39;s values.</span>
    <span class="kd">static final</span> <span class="kt">int</span> <span class="n">CELL_BLACK</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">static final</span> <span class="kt">int</span> <span class="n">CELL_WHITE</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="kd">static final</span> <span class="kt">int</span> <span class="n">CELL_EMPTY</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
    <span class="kd">static final</span> <span class="kt">int</span> <span class="n">PLAYER_BLACK</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kd">static final</span> <span class="kt">int</span> <span class="n">PLAYER_WHITE</span> <span class="o">=</span> <span class="mi">1</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">OthelloBoard</span><span class="o">() {</span> <span class="n">nativeInit</span><span class="o">(); }</span>
    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">destroy</span><span class="o">() {</span> <span class="n">nativeDestroy</span><span class="o">(); }</span>

    <span class="kd">public native</span> <span class="kt">void</span> <span class="nf">reset</span><span class="o">();</span>
    <span class="kd">public native</span> <span class="kt">int</span> <span class="nf">getCellState</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">);</span>
    <span class="kd">public native</span> <span class="kt">void</span> <span class="nf">setCellState</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">,</span> <span class="kt">int</span> <span class="n">state</span><span class="o">);</span>
    <span class="kd">public native</span> <span class="kt">int</span> <span class="nf">getScore</span><span class="o">(</span><span class="kt">int</span> <span class="n">player</span><span class="o">);</span>
    <span class="kd">public native</span> <span class="kt">boolean</span> <span class="nf">hasValidMove</span><span class="o">(</span><span class="kt">int</span> <span class="n">player</span><span class="o">);</span>
    <span class="kd">public native</span> <span class="kt">boolean</span> <span class="nf">isValidMove</span><span class="o">(</span><span class="kt">int</span> <span class="n">player</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">);</span>
    <span class="kd">public native</span> <span class="kt">void</span> <span class="nf">makeMove</span><span class="o">(</span><span class="kt">int</span> <span class="n">player</span><span class="o">,</span> <span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">);</span>
    <span class="kd">public native</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">computeMove</span><span class="o">(</span><span class="kt">int</span> <span class="n">player</span><span class="o">);
}</span>
</pre></div>


<p>The static initializer block is used to load the library that provides implementations of all the methods marked <span class="code">native</span>. We implement those methods in  <a href="files/othello/android/jni/othello_board.c"><span class="code">othello_board.c</span></a>, starting like this:</p>

<div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;assert.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;inttypes.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;jni.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">

#include</span> <span class="cpf">&quot;othello.h&quot;</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_ptr</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject obj</span><span class="p">,</span> <span class="n">othello_t</span> <span class="o">*</span><span class="n">ptr</span><span class="p">)
{</span>
        <span class="n">jclass class</span><span class="p">;</span>
        <span class="n">jfieldID field</span><span class="p">;</span>

        <span class="n">class</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">GetObjectClass</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>
        <span class="n">field</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">GetFieldID</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">class</span><span class="p">,</span> <span class="s">&quot;mNativeBoard&quot;</span><span class="p">,</span> <span class="s">&quot;J&quot;</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">jlong</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">intptr_t</span><span class="p">));
        (</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">SetLongField</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">field</span><span class="p">, (</span><span class="n">jlong</span><span class="p">)(</span><span class="kt">intptr_t</span><span class="p">)</span><span class="n">ptr</span><span class="p">);
}</span>

<span class="k">static</span> <span class="n">othello_t</span> <span class="o">*</span><span class="nf">get_ptr</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject obj</span><span class="p">)
{</span>
        <span class="n">jclass class</span><span class="p">;</span>
        <span class="n">jfieldID field</span><span class="p">;</span>

        <span class="n">class</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">GetObjectClass</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>
        <span class="n">field</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">GetFieldID</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">class</span><span class="p">,</span> <span class="s">&quot;mNativeBoard&quot;</span><span class="p">,</span> <span class="s">&quot;J&quot;</span><span class="p">);</span>
        <span class="n">assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">jlong</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">intptr_t</span><span class="p">));</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">othello_t</span><span class="o">*</span><span class="p">)(</span><span class="kt">intptr_t</span><span class="p">)(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">GetLongField</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">field</span><span class="p">);
}</span>

<span class="n">JNIEXPORT</span> <span class="kt">void</span> <span class="n">JNICALL</span>
<span class="nf">Java_net_hanshq_othello_OthelloBoard_nativeInit</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject obj</span><span class="p">)
{</span>
        <span class="n">othello_t</span> <span class="o">*</span><span class="n">o</span><span class="p">;</span>

        <span class="n">o</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">o</span><span class="p">));</span>
        <span class="n">othello_init</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
        <span class="n">set_ptr</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">o</span><span class="p">);
}</span>

<span class="n">JNIEXPORT</span> <span class="kt">void</span> <span class="n">JNICALL</span>
<span class="nf">Java_net_hanshq_othello_OthelloBoard_nativeDestroy</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject obj</span><span class="p">)
{</span>
        <span class="n">free</span><span class="p">(</span><span class="n">get_ptr</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">obj</span><span class="p">));</span>
        <span class="n">set_ptr</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);
}</span>
</pre></div>


<p>The <span class="code">JNIEnv</span> pointer provides access to functions for dealing with the Java environment, and we use those to access the <span class="code">mNativeBoard</span> field of the <span class="code">OthelloBoard</span> class. We use that field to store a pointer to the <span class="code">othello_t</span> object. Storing a native pointer in a Java class like this is a common technique for wrapping code.</p>

<p>Using the <span class="code">get_ptr</span> helper method above to access the <span class="code">othello_t</span> pointer, we implement the rest of the native methods by simply forwarding to the Othello functions:</p>

<div class="highlight"><pre><span></span><span class="n">JNIEXPORT</span> <span class="kt">void</span> <span class="n">JNICALL</span>
<span class="nf">Java_net_hanshq_othello_OthelloBoard_reset</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject obj</span><span class="p">)
{</span>
        <span class="n">othello_init</span><span class="p">(</span><span class="n">get_ptr</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">obj</span><span class="p">));
}</span>

<span class="n">JNIEXPORT jint JNICALL</span>
<span class="nf">Java_net_hanshq_othello_OthelloBoard_getCellState</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject obj</span><span class="p">,</span>
                                                  <span class="n">jint row</span><span class="p">,</span> <span class="n">jint col</span><span class="p">){</span>
        <span class="k">return</span> <span class="n">othello_cell_state</span><span class="p">(</span><span class="n">get_ptr</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">obj</span><span class="p">),</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">);
}</span>

<span class="n">JNIEXPORT</span> <span class="kt">void</span> <span class="n">JNICALL</span>
<span class="nf">Java_net_hanshq_othello_OthelloBoard_setCellState</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject obj</span><span class="p">,</span>
                                                  <span class="n">jint row</span><span class="p">,</span> <span class="n">jint col</span><span class="p">,</span>
                                                  <span class="n">jint state</span><span class="p">)
{</span>
        <span class="n">othello_set_cell_state</span><span class="p">(</span><span class="n">get_ptr</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">obj</span><span class="p">),</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">state</span><span class="p">);
}</span>

<span class="n">JNIEXPORT jint JNICALL</span>
<span class="nf">Java_net_hanshq_othello_OthelloBoard_getScore</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject obj</span><span class="p">,</span>
                                              <span class="n">jint player</span><span class="p">)
{</span>
        <span class="k">return</span> <span class="n">othello_score</span><span class="p">(</span><span class="n">get_ptr</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">obj</span><span class="p">),</span> <span class="n">player</span><span class="p">);
}</span>

<span class="n">JNIEXPORT jboolean JNICALL</span>
<span class="nf">Java_net_hanshq_othello_OthelloBoard_hasValidMove</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject obj</span><span class="p">,</span>
                                                  <span class="n">jint player</span><span class="p">)
{</span>
        <span class="k">return</span> <span class="n">othello_has_valid_move</span><span class="p">(</span><span class="n">get_ptr</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">obj</span><span class="p">),</span> <span class="n">player</span><span class="p">);
}</span>

<span class="n">JNIEXPORT jboolean JNICALL</span>
<span class="nf">Java_net_hanshq_othello_OthelloBoard_isValidMove</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject obj</span><span class="p">,</span>
                                                 <span class="n">jint player</span><span class="p">,</span>
                                                 <span class="n">jint row</span><span class="p">,</span> <span class="n">jint col</span><span class="p">)
{</span>
        <span class="k">return</span> <span class="n">othello_is_valid_move</span><span class="p">(</span><span class="n">get_ptr</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">obj</span><span class="p">),</span> <span class="n">player</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">);
}</span>

<span class="n">JNIEXPORT</span> <span class="kt">void</span> <span class="n">JNICALL</span>
<span class="nf">Java_net_hanshq_othello_OthelloBoard_makeMove</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject obj</span><span class="p">,</span>
                                              <span class="n">jint player</span><span class="p">,</span> <span class="n">jint row</span><span class="p">,</span> <span class="n">jint col</span><span class="p">)
{</span>
        <span class="n">othello_make_move</span><span class="p">(</span><span class="n">get_ptr</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">obj</span><span class="p">),</span> <span class="n">player</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">);
}</span>

<span class="n">JNIEXPORT jintArray JNICALL</span>
<span class="nf">Java_net_hanshq_othello_OthelloBoard_computeMove</span><span class="p">(</span><span class="n">JNIEnv</span> <span class="o">*</span><span class="n">env</span><span class="p">,</span> <span class="n">jobject obj</span><span class="p">,</span>
                                                 <span class="n">jint player</span><span class="p">)
{</span>
        <span class="n">jintArray res</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

        <span class="n">res</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">NewIntArray</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
        <span class="n">othello_compute_move</span><span class="p">(</span><span class="n">get_ptr</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">obj</span><span class="p">),</span> <span class="n">player</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]);
        (</span><span class="o">*</span><span class="n">env</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">SetIntArrayRegion</span><span class="p">(</span><span class="n">env</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">arr</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">;
}</span>
</pre></div>


<a name="android_view"></a>
<h4>The View</h4>

<p>We implement the view in <a href="files/othello/android/java/net/hanshq/reversi/OthelloView.java"><span class="code">OthelloView.java</span></a>, very similarly to the other ports. It has a reference to the <span class="code">OthelloBoard</span>, receives <span class="code">update</span> calls when the state changes, and when the user taps on a cell we notify a class implementing the <span class="code">TouchHandler</span> interface (it's the <span class="code">OthelloActivity</span> class that implements this, but the view doesn't need to know that).</p>

<div class="highlight"><pre><span></span><span class="kn">package</span> <span class="nn">net.hanshq.othello</span><span class="o">;</span>

<span class="kn">import</span> <span class="nn">android.content.Context</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">android.graphics.Canvas</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">android.graphics.Color</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">android.graphics.Paint</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">android.graphics.Rect</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">android.util.AttributeSet</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">android.view.MotionEvent</span><span class="o">;</span>
<span class="kn">import</span> <span class="nn">android.view.View</span><span class="o">;</span>

<span class="kd">public class</span> <span class="nc">OthelloView</span> <span class="kd">extends</span> <span class="n">View</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="n">String mStatus</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">OthelloBoard mBoard</span><span class="o">;</span>
    <span class="kd">private</span> <span class="n">TouchHandler mTouchHandler</span><span class="o">;</span>

    <span class="kd">private final</span> <span class="kt">int</span> <span class="n">CELL_GAP</span> <span class="o">=</span> <span class="mi">2</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">cellSize</span><span class="o">,</span> <span class="n">xOffset</span><span class="o">,</span> <span class="n">yOffset</span><span class="o">,</span> <span class="n">size</span><span class="o">;</span>

    <span class="kd">public interface</span> <span class="nc">TouchHandler</span> <span class="o">{</span>
        <span class="kd">public</span> <span class="kt">void</span> <span class="nf">onTouch</span><span class="o">(</span><span class="kt">int</span> <span class="n">row</span><span class="o">,</span> <span class="kt">int</span> <span class="n">col</span><span class="o">);
    }</span>

    <span class="kd">public</span> <span class="nf">OthelloView</span><span class="o">(</span><span class="n">Context context</span><span class="o">,</span> <span class="n">AttributeSet attrs</span><span class="o">) {</span>
        <span class="kd">super</span><span class="o">(</span><span class="n">context</span><span class="o">,</span> <span class="n">attrs</span><span class="o">);
    }</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setBoard</span><span class="o">(</span><span class="n">OthelloBoard board</span><span class="o">) {</span>
        <span class="n">mBoard</span> <span class="o">=</span> <span class="n">board</span><span class="o">;
    }</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">setTouchHandler</span><span class="o">(</span><span class="n">TouchHandler handler</span><span class="o">) {</span>
        <span class="n">mTouchHandler</span> <span class="o">=</span> <span class="n">handler</span><span class="o">;
    }</span>

    <span class="kd">public</span> <span class="kt">void</span> <span class="nf">update</span><span class="o">(</span><span class="n">OthelloActivity</span><span class="o">.</span><span class="na">State</span> <span class="n">state</span><span class="o">) {</span>
        <span class="k">switch</span> <span class="o">(</span><span class="n">state</span><span class="o">) {</span>
        <span class="k">case</span> <span class="n">BLACKS_MOVE</span><span class="o">:</span>
            <span class="n">mStatus</span> <span class="o">=</span> <span class="s">&quot;Human&#39;s move.&quot;</span><span class="o">;</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="n">WHITES_MOVE</span><span class="o">:</span>
            <span class="n">mStatus</span> <span class="o">=</span> <span class="s">&quot;Computer&#39;s move...&quot;</span><span class="o">;</span>
            <span class="k">break</span><span class="o">;</span>
        <span class="k">case</span> <span class="n">GAME_OVER</span><span class="o">:</span>
            <span class="kt">int</span> <span class="n">bs</span> <span class="o">=</span> <span class="n">mBoard</span><span class="o">.</span><span class="na">getScore</span><span class="o">(</span><span class="n">OthelloBoard</span><span class="o">.</span><span class="na">PLAYER_BLACK</span><span class="o">);</span>
            <span class="kt">int</span> <span class="n">ws</span> <span class="o">=</span> <span class="n">mBoard</span><span class="o">.</span><span class="na">getScore</span><span class="o">(</span><span class="n">OthelloBoard</span><span class="o">.</span><span class="na">PLAYER_WHITE</span><span class="o">);</span>

            <span class="k">if</span> <span class="o">(</span><span class="n">bs</span> <span class="o">&gt;</span> <span class="n">ws</span><span class="o">) {</span>
                <span class="n">mStatus</span> <span class="o">=</span> <span class="s">&quot;Human wins &quot;</span> <span class="o">+</span> <span class="n">bs</span> <span class="o">+</span> <span class="s">&quot;-&quot;</span> <span class="o">+</span> <span class="n">ws</span> <span class="o">+</span> <span class="s">&quot;!&quot;</span><span class="o">;
            }</span> <span class="k">else if</span> <span class="o">(</span><span class="n">ws</span> <span class="o">&gt;</span> <span class="n">bs</span><span class="o">) {</span>
                <span class="n">mStatus</span> <span class="o">=</span> <span class="s">&quot;Computer wins &quot;</span> <span class="o">+</span> <span class="n">ws</span> <span class="o">+</span> <span class="s">&quot;-&quot;</span> <span class="o">+</span> <span class="n">bs</span> <span class="o">+</span> <span class="s">&quot;!&quot;</span><span class="o">;
            }</span> <span class="k">else</span> <span class="o">{</span>
                <span class="n">mStatus</span> <span class="o">=</span> <span class="s">&quot;Draw!&quot;</span><span class="o">;
            }
        }</span>

        <span class="n">invalidate</span><span class="o">();
    }</span>

    <span class="nd">@Override</span>
    <span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">onTouchEvent</span><span class="o">(</span><span class="n">MotionEvent e</span><span class="o">) {</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">e</span><span class="o">.</span><span class="na">getAction</span><span class="o">() !=</span> <span class="n">MotionEvent</span><span class="o">.</span><span class="na">ACTION_DOWN</span><span class="o">) {</span>
            <span class="k">return</span> <span class="kc">false</span><span class="o">;
        }</span>

        <span class="kt">int</span> <span class="n">row</span> <span class="o">= (</span><span class="kt">int</span><span class="o">)(</span><span class="n">e</span><span class="o">.</span><span class="na">getY</span><span class="o">() -</span> <span class="n">yOffset</span><span class="o">) / (</span><span class="n">cellSize</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="o">) -</span> <span class="mi">1</span><span class="o">;</span>
        <span class="kt">int</span> <span class="n">col</span> <span class="o">= (</span><span class="kt">int</span><span class="o">)(</span><span class="n">e</span><span class="o">.</span><span class="na">getX</span><span class="o">() -</span> <span class="n">xOffset</span><span class="o">) / (</span><span class="n">cellSize</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="o">) -</span> <span class="mi">1</span><span class="o">;</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="mi">8</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="o">) {</span>
            <span class="n">mTouchHandler</span><span class="o">.</span><span class="na">onTouch</span><span class="o">((</span><span class="kt">int</span><span class="o">)</span><span class="n">row</span><span class="o">, (</span><span class="kt">int</span><span class="o">)</span><span class="n">col</span><span class="o">);
        }</span>

        <span class="k">return</span> <span class="kc">true</span><span class="o">;
    }</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="kt">void</span> <span class="nf">onDraw</span><span class="o">(</span><span class="n">Canvas canvas</span><span class="o">) {</span>
        <span class="c1">// Compute size and position of the 10x10 grid.</span>
        <span class="kt">int</span> <span class="n">viewSize</span> <span class="o">=</span> <span class="n">Math</span><span class="o">.</span><span class="na">min</span><span class="o">(</span><span class="n">canvas</span><span class="o">.</span><span class="na">getWidth</span><span class="o">(),</span> <span class="n">canvas</span><span class="o">.</span><span class="na">getHeight</span><span class="o">());</span>
        <span class="n">cellSize</span> <span class="o">= (</span><span class="n">viewSize</span> <span class="o">-</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">CELL_GAP</span><span class="o">) /</span> <span class="mi">10</span><span class="o">;</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">cellSize</span> <span class="o">*</span> <span class="mi">10</span> <span class="o">+</span> <span class="mi">9</span> <span class="o">*</span> <span class="n">CELL_GAP</span><span class="o">;</span>
        <span class="n">xOffset</span> <span class="o">=</span> <span class="n">canvas</span><span class="o">.</span><span class="na">getWidth</span><span class="o">() /</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="n">yOffset</span> <span class="o">=</span> <span class="n">canvas</span><span class="o">.</span><span class="na">getHeight</span><span class="o">() /</span> <span class="mi">2</span> <span class="o">-</span> <span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

        <span class="c1">// Draw labels.</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="o">;</span> <span class="n">row</span><span class="o">++) {</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">xOffset</span> <span class="o">+</span> <span class="n">cellSize</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">yOffset</span> <span class="o">+ (</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="o">) * (</span><span class="n">cellSize</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="o">) +</span> <span class="n">cellSize</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
            <span class="n">drawChar</span><span class="o">((</span><span class="kt">char</span><span class="o">)(</span><span class="sc">&#39;1&#39;</span> <span class="o">+</span> <span class="n">row</span><span class="o">),</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">canvas</span><span class="o">);
        }</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="o">;</span> <span class="n">col</span><span class="o">++) {</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">xOffset</span> <span class="o">+ (</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="o">) * (</span><span class="n">cellSize</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="o">) +</span> <span class="n">cellSize</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
            <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">yOffset</span> <span class="o">+</span> <span class="n">cellSize</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
            <span class="n">drawChar</span><span class="o">((</span><span class="kt">char</span><span class="o">)(</span><span class="sc">&#39;A&#39;</span> <span class="o">+</span> <span class="n">col</span><span class="o">),</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">canvas</span><span class="o">);
        }</span>

        <span class="c1">// Draw status text.</span>
        <span class="n">drawString</span><span class="o">(</span><span class="n">mStatus</span><span class="o">,</span> <span class="n">xOffset</span> <span class="o">+</span> <span class="n">size</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span> <span class="n">yOffset</span> <span class="o">+</span> <span class="n">size</span> <span class="o">-</span> <span class="n">cellSize</span> <span class="o">/</span> <span class="mi">2</span><span class="o">,</span>
                <span class="n">canvas</span><span class="o">);</span>

        <span class="c1">// Draw the cells.</span>
        <span class="n">Paint cellPaint</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Paint</span><span class="o">();</span>
        <span class="n">cellPaint</span><span class="o">.</span><span class="na">setColor</span><span class="o">(</span><span class="n">Color</span><span class="o">.</span><span class="na">rgb</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mh">0x80</span><span class="o">,</span> <span class="mi">0</span><span class="o">));</span>
        <span class="n">Paint whiteDiskPaint</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Paint</span><span class="o">();</span>
        <span class="n">whiteDiskPaint</span><span class="o">.</span><span class="na">setColor</span><span class="o">(</span><span class="n">Color</span><span class="o">.</span><span class="na">WHITE</span><span class="o">);</span>
        <span class="n">Paint blackDiskPaint</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Paint</span><span class="o">();</span>
        <span class="n">blackDiskPaint</span><span class="o">.</span><span class="na">setColor</span><span class="o">(</span><span class="n">Color</span><span class="o">.</span><span class="na">BLACK</span><span class="o">);</span>

        <span class="n">Rect cellRect</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Rect</span><span class="o">(</span><span class="mi">0</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">cellSize</span><span class="o">,</span> <span class="n">cellSize</span><span class="o">);</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="o">;</span> <span class="n">row</span><span class="o">++) {</span>
            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="o">;</span> <span class="n">col</span><span class="o">++) {</span>
                <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">xOffset</span> <span class="o">+ (</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="o">) * (</span><span class="n">cellSize</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="o">);</span>
                <span class="kt">int</span> <span class="n">y</span> <span class="o">=</span> <span class="n">yOffset</span> <span class="o">+ (</span><span class="n">row</span> <span class="o">+</span> <span class="mi">1</span><span class="o">) * (</span><span class="n">cellSize</span> <span class="o">+</span> <span class="n">CELL_GAP</span><span class="o">);</span>

                <span class="c1">// Draw the cell background.</span>
                <span class="n">cellRect</span><span class="o">.</span><span class="na">offsetTo</span><span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">);</span>
                <span class="n">canvas</span><span class="o">.</span><span class="na">drawRect</span><span class="o">(</span><span class="n">cellRect</span><span class="o">,</span> <span class="n">cellPaint</span><span class="o">);</span>

                <span class="c1">// Draw the disk, if any.</span>
                <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">cellSize</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
                <span class="k">switch</span> <span class="o">(</span><span class="n">mBoard</span><span class="o">.</span><span class="na">getCellState</span><span class="o">(</span><span class="n">row</span><span class="o">,</span> <span class="n">col</span><span class="o">)) {</span>
                <span class="k">case</span> <span class="n">OthelloBoard</span><span class="o">.</span><span class="na">CELL_BLACK</span><span class="o">:</span>
                    <span class="n">canvas</span><span class="o">.</span><span class="na">drawCircle</span><span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">r</span><span class="o">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">r</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="n">blackDiskPaint</span><span class="o">);</span>
                    <span class="k">break</span><span class="o">;</span>
                <span class="k">case</span> <span class="n">OthelloBoard</span><span class="o">.</span><span class="na">CELL_WHITE</span><span class="o">:</span>
                    <span class="n">canvas</span><span class="o">.</span><span class="na">drawCircle</span><span class="o">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">r</span><span class="o">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">r</span><span class="o">,</span> <span class="n">r</span><span class="o">,</span> <span class="n">whiteDiskPaint</span><span class="o">);</span>
                    <span class="k">break</span><span class="o">;
                }
            }
        }
    }</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">drawChar</span><span class="o">(</span><span class="kt">char</span> <span class="n">c</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="n">Canvas canvas</span><span class="o">) {</span>
        <span class="n">drawString</span><span class="o">(</span><span class="n">String</span><span class="o">.</span><span class="na">valueOf</span><span class="o">(</span><span class="n">c</span><span class="o">),</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">canvas</span><span class="o">);
    }</span>

    <span class="kd">private</span> <span class="kt">void</span> <span class="nf">drawString</span><span class="o">(</span><span class="n">String s</span><span class="o">,</span> <span class="kt">int</span> <span class="n">x</span><span class="o">,</span> <span class="kt">int</span> <span class="n">y</span><span class="o">,</span> <span class="n">Canvas c</span><span class="o">) {</span>
        <span class="n">Paint textPaint</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Paint</span><span class="o">();</span>
        <span class="n">textPaint</span><span class="o">.</span><span class="na">setColor</span><span class="o">(</span><span class="n">Color</span><span class="o">.</span><span class="na">WHITE</span><span class="o">);</span>
        <span class="n">textPaint</span><span class="o">.</span><span class="na">setTextSize</span><span class="o">(</span><span class="n">cellSize</span> <span class="o">/</span> <span class="mi">2</span><span class="o">);</span>
        <span class="n">textPaint</span><span class="o">.</span><span class="na">setTextAlign</span><span class="o">(</span><span class="n">Paint</span><span class="o">.</span><span class="na">Align</span><span class="o">.</span><span class="na">CENTER</span><span class="o">);</span>
        <span class="n">Rect bounds</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Rect</span><span class="o">();</span>
        <span class="n">textPaint</span><span class="o">.</span><span class="na">getTextBounds</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">bounds</span><span class="o">);</span>
        <span class="n">c</span><span class="o">.</span><span class="na">drawText</span><span class="o">(</span><span class="n">s</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">s</span><span class="o">.</span><span class="na">length</span><span class="o">(),</span> <span class="n">x</span><span class="o">,</span> <span class="n">y</span> <span class="o">+</span> <span class="n">bounds</span><span class="o">.</span><span class="na">height</span><span class="o">() /</span> <span class="mi">2</span><span class="o">,</span> <span class="n">textPaint</span><span class="o">);
    }
}</span>
</pre></div>


<a name="android_build"></a>
<h4>Building</h4>

<p>Building Android programs is a little bit involved. Android Studio provides some way to do it, but for those of us who like more control, it's also possible to do by hand. The process is described in <a href="command-line-android.html#native">Building an Android App from the Command Line</a>. For the Othello program, I've put it in a build script, <a href="files/othello/android/build.sh"><span class="code">build.sh</span></a>.</p>

<p>The picture below shows the program running on a Nexus 5.</p>

<div style="text-align: center">
<img src="gfx/android_othello.jpg" alt="Photo of the Othello program on Nexus 5.">
</div>


<a name="web"></a>
<h3>The Web</h3>

<p>On 25 December 1990, <a href="https://en.wikipedia.org/wiki/Tim_Berners-Lee">Tim Berners-Lee</a>, then a contractor at CERN, released a program (written on his NeXT workstation) for displaying, editing, and navigating hyper-text documents across the internet; this was the birth of the world wide web.</p>

<p>A few years later, in 1993, <a href="https://en.wikipedia.org/wiki/Marc_Andreessen">Marc Andreesen</a> and <a href="https://en.wikipedia.org/wiki/Eric_Bina">Eric Bina</a> at the University of Illinois Urbana Champaign created <a href="https://en.wikipedia.org/wiki/Mosaic_%28web_browser%29">Mosaic</a>, the first web browser to become popular. They moved on to start a web browser company in Mountain View, CA, called <a href="https://en.wikipedia.org/wiki/Netscape">Netscape</a>. This was the beginning of the dot-com era.</p>

<p><a href="https://en.wikipedia.org/wiki/Brendan_Eich">Brendan Eich</a> was hired by Netscape in 1995 to <a href="https://brendaneich.com/2008/04/popularity/">create a scripting language</a> for the browser. The idea was to have a light-weight alternative to Java, which was also being added to the browser at the time. According to legend, Eich created JavaScript in ten days, which perhaps explains some of its <a href="https://www.destroyallsoftware.com/talks/wat">quirks</a>.</p>

<p>Java in the browser is now dead, but JavaScript flourishes, and the web has become an extremely powerful way of publishing applications. Early on, it also became popular to embed web content in desktop applications due to the convenience of using HTML for layout. More recently this has been taken to the point where programs are written with web technologies, and then shipped baked into a browser, using for example <a href="https://electron.atom.io/">Electron</a>.</p>

<p>The web version of our Othello game is written in HTML, CSS, and JavaScript, and uses WebAssembly or asm.js for the actual game engine.</p>

<p>(I briefly considered using this as an opportunity to learn about the <a href="https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f?gi=d919b54f0a04">world of JavaScript frameworks and tools</a>, which I know nothing about. However, in keeping with this post's theme of native development, I ended up writing plain old code by hand except for the asm.js/wasm part.)</p>

<p>I learned about JavaScript from Marijn Haverbeke's excellent <a href="http://eloquentjavascript.net/">Eloquent JavaScript</a> (2nd edition), which is freely available online, and also in print.</p>

<a name="web_presentation"></a>
<h4>Presentation</h4>

<p>The Othello game user interface is presented by an HTML document. The board is created with a <span class="code">table</span> element (using <span class="code">border="1"</span> for that classic feel), and a CSS trick is used for the disks:</p>

<div class="highlight"><pre><span></span><span class="cp">&lt;!doctype html&gt;</span>
<span class="p">&lt;</span><span class="nt">html</span><span class="p">&gt;
  &lt;</span><span class="nt">head</span><span class="p">&gt;
    &lt;</span><span class="nt">title</span><span class="p">&gt;</span>Othello<span class="p">&lt;/</span><span class="nt">title</span><span class="p">&gt;
    &lt;</span><span class="nt">meta</span> <span class="na">name</span><span class="o">=</span><span class="s">&quot;viewport&quot;</span> <span class="na">content</span><span class="o">=</span><span class="s">&quot;width=device-width, initial-scale=1&quot;</span><span class="p">&gt;
    &lt;</span><span class="nt">style</span><span class="p">&gt;</span>
      <span class="nt">body</span> <span class="p">{</span> <span class="k">text-align</span><span class="p">:</span> <span class="kc">center</span><span class="p">; }</span>
      <span class="nt">table</span> <span class="p">{</span>
        <span class="k">margin-left</span><span class="p">:</span> <span class="kc">auto</span><span class="p">;</span>
        <span class="k">margin-right</span><span class="p">:</span> <span class="kc">auto</span><span class="p">;</span>
        <span class="n">color-adjust</span><span class="p">:</span> <span class="n">exact</span><span class="p">;</span>
        <span class="kp">-webkit-</span><span class="n">print-color-adjust</span><span class="p">:</span> <span class="n">exact</span><span class="p">;
      }</span>
      <span class="nt">td</span> <span class="p">{</span> <span class="k">background</span><span class="p">:</span> <span class="mh">#008000</span><span class="p">; }</span>
      <span class="nt">td</span><span class="p">.</span><span class="nc">selected</span> <span class="p">{</span> <span class="k">background</span><span class="p">:</span> <span class="mh">#00AA00</span><span class="p">; }</span>
      <span class="nt">td div</span> <span class="p">{</span>
        <span class="k">width</span><span class="p">:</span> <span class="mi">30</span><span class="kt">px</span><span class="p">;</span>
        <span class="k">height</span><span class="p">:</span> <span class="mi">30</span><span class="kt">px</span><span class="p">;</span>
        <span class="k">border-radius</span><span class="p">:</span> <span class="mi">15</span><span class="kt">px</span><span class="p">;</span>
        <span class="k">background</span><span class="p">:</span> <span class="kc">transparent</span><span class="p">;</span>  <span class="c">/* Disk colour. */</span>
      <span class="p">}
    &lt;/</span><span class="nt">style</span><span class="p">&gt;
  &lt;/</span><span class="nt">head</span><span class="p">&gt;
  &lt;</span><span class="nt">body</span><span class="p">&gt;
    &lt;</span><span class="nt">h1</span><span class="p">&gt;</span>Othello<span class="p">&lt;/</span><span class="nt">h1</span><span class="p">&gt;
    &lt;</span><span class="nt">table</span> <span class="na">border</span><span class="o">=</span><span class="s">&quot;1&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">table</span><span class="p">&gt;
    &lt;</span><span class="nt">p</span> <span class="na">id</span><span class="o">=</span><span class="s">&quot;status&quot;</span><span class="p">&gt;&lt;</span><span class="nt">noscript</span><span class="p">&gt;</span>Error: Javascript required.<span class="p">&lt;/</span><span class="nt">noscript</span><span class="p">&gt;&lt;/</span><span class="nt">p</span><span class="p">&gt;
    &lt;</span><span class="nt">button</span> <span class="na">disabled</span><span class="p">&gt;</span>New Game<span class="p">&lt;/</span><span class="nt">button</span><span class="p">&gt;
    &lt;</span><span class="nt">p</span><span class="p">&gt;</span>By <span class="p">&lt;</span><span class="nt">a</span> <span class="na">href</span><span class="o">=</span><span class="s">&quot;http://www.hanshq.net/othello.html&quot;</span><span class="p">&gt;</span>hanshq.net<span class="p">&lt;/</span><span class="nt">a</span><span class="p">&gt;</span>.<span class="p">&lt;/</span><span class="nt">p</span><span class="p">&gt;
    &lt;</span><span class="nt">script</span> <span class="na">src</span><span class="o">=</span><span class="s">&quot;web_othello.js&quot;</span><span class="p">&gt;&lt;/</span><span class="nt">script</span><span class="p">&gt;
  &lt;/</span><span class="nt">body</span><span class="p">&gt;
&lt;/</span><span class="nt">html</span><span class="p">&gt;</span>
</pre></div>


<p>The <span class="code">viewport</span> meta tag makes the page scale to the size of the device, which is important for making the page work on mobile phones and such.</p>

<p>To create round disks, we use CSS to set the style of any <span class="code">div</span> elements in the table (there will be one in each cell) to have rounded corners with a radius half the size of the element. By setting the background color of those elements, we can make black, white, or transparent disks appear in the table. (This might not work if someone decides to print the page, as background colours are not normally printed. The <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/color-adjust"><span class="code">color-adjust</span></a> property addresses this.)</p>

<a name="web_main"></a>
<h4>User Interface Logic</h4>

<p>The JavaScript code for the game is split into two parts: one that deals with the user interface, and one that deals with the game engine. The reason is that like in the other versions, we want to compute white's move on a background thread so as not to "hang" the user interface. On the web, this can be accomplished with <a href="https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers">Web Workers</a>. However, unlike with regular threads, state cannot be shared between web workers and the main execution context, so instead of making black's moves on one thread and white's on another against the same state, we let a web worker manage all the game engine business, and use message passing for communication with the user interface code.</p>

<p>We use the <span class="code">init()</span> function in <a href="files/othello/web/web_othello.js"><span class="code">web_othello.js</span></a> below to fill the <span class="code">table</span> with elements to represent the board. For each cell on the board, we set event handlers to handle clicks and mouseover events. We also store a reference to each cell in the <span class="code">cells</span> matrix for easy access.</p>

<div class="highlight"><pre><span></span><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">WAITING</span> <span class="o">= -</span><span class="mi">1</span><span class="p">,</span> <span class="nx">BLACKS_MOVE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">WHITES_MOVE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">GAME_OVER</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">state</span> <span class="o">=</span> <span class="nx">WAITING</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">cells</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">worker</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">selectedRow</span> <span class="o">= -</span><span class="mi">1</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">selectedCol</span> <span class="o">= -</span><span class="mi">1</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">setStatus</span><span class="p">(</span><span class="nx">text</span><span class="p">) {</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s2">&quot;#status&quot;</span><span class="p">).</span><span class="nx">innerHTML</span> <span class="o">=</span> <span class="nx">text</span><span class="p">;
}</span>

<span class="kd">function</span> <span class="nx">setCellListeners</span><span class="p">(</span><span class="nx">cell</span><span class="p">,</span> <span class="nx">row</span><span class="p">,</span> <span class="nx">col</span><span class="p">) {</span>
  <span class="nx">cell</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">&quot;click&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">() {</span> <span class="nx">onCellClick</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span> <span class="nx">col</span><span class="p">); });</span>
  <span class="nx">cell</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">&quot;mousemove&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">() {</span> <span class="nx">selectCell</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span> <span class="nx">col</span><span class="p">); });</span>
  <span class="nx">cell</span><span class="p">.</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">&quot;mouseleave&quot;</span><span class="p">,</span> <span class="kd">function</span><span class="p">() {</span> <span class="nx">selectCell</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">); });
}</span>

<span class="kd">function</span> <span class="nx">init</span><span class="p">() {</span>
  <span class="nx">setStatus</span><span class="p">(</span><span class="s2">&quot;Loading...&quot;</span><span class="p">);</span>

  <span class="c1">// Fill in the table.</span>
  <span class="kd">var</span> <span class="nx">table</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s2">&quot;table&quot;</span><span class="p">);</span>
  <span class="kd">var</span> <span class="nx">tr</span><span class="p">,</span> <span class="nx">th</span><span class="p">,</span> <span class="nx">td</span><span class="p">,</span> <span class="nx">div</span><span class="p">;</span>
  <span class="nx">cells</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="nx">table</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">tr</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s2">&quot;tr&quot;</span><span class="p">));</span>
  <span class="nx">tr</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s2">&quot;th&quot;</span><span class="p">));</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">col</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="nx">col</span><span class="o">++</span><span class="p">) {</span>
    <span class="nx">tr</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">th</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s2">&quot;th&quot;</span><span class="p">));</span>
    <span class="nx">th</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">createTextNode</span><span class="p">(</span><span class="s2">&quot;ABCDEFGH&quot;</span><span class="p">[</span><span class="nx">col</span><span class="p">]));
  }</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">row</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="nx">row</span><span class="o">++</span><span class="p">) {</span>
    <span class="nx">cells</span><span class="p">.</span><span class="nx">push</span><span class="p">([]);</span>
    <span class="nx">table</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">tr</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s2">&quot;tr&quot;</span><span class="p">));</span>
    <span class="nx">tr</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">th</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s2">&quot;th&quot;</span><span class="p">));</span>
    <span class="nx">th</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nb">document</span><span class="p">.</span><span class="nx">createTextNode</span><span class="p">(</span><span class="nx">row</span><span class="p">));</span>

    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">col</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="nx">col</span><span class="o">++</span><span class="p">) {</span>
      <span class="nx">tr</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">td</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s2">&quot;td&quot;</span><span class="p">));</span>
      <span class="nx">td</span><span class="p">.</span><span class="nx">appendChild</span><span class="p">(</span><span class="nx">div</span> <span class="o">=</span> <span class="nb">document</span><span class="p">.</span><span class="nx">createElement</span><span class="p">(</span><span class="s2">&quot;div&quot;</span><span class="p">));</span>
      <span class="nx">cells</span><span class="p">[</span><span class="nx">row</span><span class="p">][</span><span class="nx">col</span><span class="p">]</span> <span class="o">=</span> <span class="nx">td</span><span class="p">;</span>
      <span class="nx">setCellListeners</span><span class="p">(</span><span class="nx">td</span><span class="p">,</span> <span class="nx">row</span><span class="p">,</span> <span class="nx">col</span><span class="p">);
    }
  }</span>

  <span class="c1">// Start the worker.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="nb">window</span><span class="p">.</span><span class="nx">Worker</span><span class="p">) {</span>
    <span class="nx">setStatus</span><span class="p">(</span><span class="s2">&quot;Error: Web Workers not supported.&quot;</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;
  }</span>
  <span class="nx">worker</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Worker</span><span class="p">(</span><span class="s2">&quot;web_othello_worker.js&quot;</span><span class="p">);</span>

  <span class="nx">worker</span><span class="p">.</span><span class="nx">onmessage</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">) {</span> <span class="nx">onMessageReceived</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">); };</span>
  <span class="nx">addEventListener</span><span class="p">(</span><span class="s2">&quot;keydown&quot;</span><span class="p">,</span> <span class="nx">onKeyDown</span><span class="p">);</span>
  <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s2">&quot;button&quot;</span><span class="p">).</span><span class="nx">addEventListener</span><span class="p">(</span><span class="s2">&quot;click&quot;</span><span class="p">,</span> <span class="nx">newGame</span><span class="p">);
}</span>
</pre></div>


<p>We use a simple protocol to communicate between the main context and the worker. The user interface code can send two messages to the worker: either <span class="code">"new game"</span> to reset the game state, or an object with a <span class="code">row</span> and a <span class="code">col</span> property to signal a move by the user. The worker can send three types of messages back to the main context: <span class="code">"loaded"</span> when it's loaded successfully, <span class="code">"error"</span> if it fails to load for some reason, or a message with a <span class="code">state</span> and a <span class="code">board</span> property which fully describe the game state. While waiting for a response from the worker, we enter the <span class="code">WAITING</span> state, in which we don't accept any user input.</p>

<div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">newGame</span><span class="p">() {</span>
  <span class="nx">worker</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">(</span><span class="s2">&quot;new game&quot;</span><span class="p">);</span>
  <span class="nx">state</span> <span class="o">=</span> <span class="nx">WAITING</span><span class="p">;
}</span>

<span class="kd">function</span> <span class="nx">onMessageReceived</span><span class="p">(</span><span class="nx">msg</span><span class="p">) {</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">msg</span> <span class="o">===</span> <span class="s2">&quot;loaded&quot;</span><span class="p">) {</span>
    <span class="nx">newGame</span><span class="p">();</span>
    <span class="k">return</span><span class="p">;
  }</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">msg</span> <span class="o">===</span> <span class="s2">&quot;error&quot;</span><span class="p">) {</span>
    <span class="nx">setStatus</span><span class="p">(</span><span class="s2">&quot;Error :-(&quot;</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;
  }</span>

  <span class="nx">state</span> <span class="o">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">state</span><span class="p">;</span>
  <span class="k">switch</span><span class="p">(</span><span class="nx">state</span><span class="p">) {</span>
  <span class="k">case</span> <span class="nx">BLACKS_MOVE</span><span class="o">:</span>
    <span class="nx">setStatus</span><span class="p">(</span><span class="s2">&quot;Human&#39;s move.&quot;</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="nx">WHITES_MOVE</span><span class="o">:</span>
    <span class="nx">setStatus</span><span class="p">(</span><span class="s2">&quot;Computer&#39;s move..&quot;</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="nx">GAME_OVER</span><span class="o">:</span>
    <span class="kd">var</span> <span class="nx">black</span> <span class="o">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">blackScore</span><span class="p">;</span>
    <span class="kd">var</span> <span class="nx">white</span> <span class="o">=</span> <span class="nx">msg</span><span class="p">.</span><span class="nx">whiteScore</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">black</span> <span class="o">&gt;</span> <span class="nx">white</span><span class="p">) {</span>
      <span class="nx">setStatus</span><span class="p">(</span><span class="s2">&quot;Human wins &quot;</span> <span class="o">+</span> <span class="nx">black</span> <span class="o">+</span> <span class="s2">&quot;&amp;ndash;&quot;</span> <span class="o">+</span> <span class="nx">white</span> <span class="o">+</span> <span class="s2">&quot;!&quot;</span><span class="p">);
    }</span> <span class="k">else if</span> <span class="p">(</span><span class="nx">white</span> <span class="o">&gt;</span> <span class="nx">black</span><span class="p">) {</span>
      <span class="nx">setStatus</span><span class="p">(</span><span class="s2">&quot;Computer wins &quot;</span> <span class="o">+</span> <span class="nx">white</span> <span class="o">+</span> <span class="s2">&quot;&amp;ndash;&quot;</span> <span class="o">+</span> <span class="nx">black</span> <span class="o">+</span> <span class="s2">&quot;!&quot;</span><span class="p">);
    }</span> <span class="k">else</span> <span class="p">{</span>
      <span class="nx">setStatus</span><span class="p">(</span><span class="s2">&quot;Draw!&quot;</span><span class="p">);
    }</span>
    <span class="k">break</span><span class="p">;
  }</span>

  <span class="nb">document</span><span class="p">.</span><span class="nx">querySelector</span><span class="p">(</span><span class="s2">&quot;button&quot;</span><span class="p">).</span><span class="nx">disabled</span> <span class="o">=
    !</span><span class="p">(</span><span class="nx">state</span> <span class="o">==</span> <span class="nx">BLACKS_MOVE</span> <span class="o">||</span> <span class="nx">state</span> <span class="o">==</span> <span class="nx">GAME_OVER</span><span class="p">);</span>

  <span class="nx">updateDisks</span><span class="p">(</span><span class="nx">msg</span><span class="p">.</span><span class="nx">board</span><span class="p">);</span>
  <span class="nx">selectCell</span><span class="p">(</span><span class="nx">selectedRow</span><span class="p">,</span> <span class="nx">selectedCol</span><span class="p">);
}</span>

<span class="kd">function</span> <span class="nx">updateDisks</span><span class="p">(</span><span class="nx">board</span><span class="p">) {</span>
  <span class="kd">var</span> <span class="nx">CELL_BLACK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">CELL_WHITE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kd">var</span> <span class="nx">CELL_EMPTY</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">row</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="nx">row</span><span class="o">++</span><span class="p">) {</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">col</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="nx">col</span><span class="o">++</span><span class="p">) {</span>
      <span class="kd">var</span> <span class="nx">disk</span> <span class="o">=</span> <span class="nx">cells</span><span class="p">[</span><span class="nx">row</span><span class="p">][</span><span class="nx">col</span><span class="p">].</span><span class="nx">firstElementChild</span><span class="p">;</span>
      <span class="k">switch</span> <span class="p">(</span><span class="nx">board</span><span class="p">[</span><span class="nx">row</span><span class="p">][</span><span class="nx">col</span><span class="p">]) {</span>
      <span class="k">case</span> <span class="nx">CELL_BLACK</span><span class="o">:</span>
        <span class="nx">disk</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">background</span> <span class="o">=</span> <span class="s2">&quot;black&quot;</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="nx">CELL_WHITE</span><span class="o">:</span>
        <span class="nx">disk</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">background</span> <span class="o">=</span> <span class="s2">&quot;white&quot;</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="k">case</span> <span class="nx">CELL_EMPTY</span><span class="o">:</span>
        <span class="nx">disk</span><span class="p">.</span><span class="nx">style</span><span class="p">.</span><span class="nx">background</span> <span class="o">=</span> <span class="s2">&quot;transparent&quot;</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;
      }
    }
  }
}</span>

<span class="kd">function</span> <span class="nx">selectCell</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span> <span class="nx">col</span><span class="p">) {</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">selectedRow</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">selectedCol</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">) {</span>
    <span class="nx">cells</span><span class="p">[</span><span class="nx">selectedRow</span><span class="p">][</span><span class="nx">selectedCol</span><span class="p">].</span><span class="nx">className</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">;
  }</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">col</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="nx">state</span> <span class="o">==</span> <span class="nx">BLACKS_MOVE</span><span class="p">) {</span>
    <span class="nx">cells</span><span class="p">[</span><span class="nx">row</span><span class="p">][</span><span class="nx">col</span><span class="p">].</span><span class="nx">className</span> <span class="o">=</span> <span class="s2">&quot;selected&quot;</span><span class="p">;
  }</span>

  <span class="nx">selectedRow</span> <span class="o">=</span> <span class="nx">row</span><span class="p">;</span>
  <span class="nx">selectedCol</span> <span class="o">=</span> <span class="nx">col</span><span class="p">;
}</span>

<span class="kd">function</span> <span class="nx">onCellClick</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span> <span class="nx">col</span><span class="p">) {</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">state</span> <span class="o">!=</span> <span class="nx">BLACKS_MOVE</span><span class="p">) {</span>
    <span class="k">return</span><span class="p">;
  }</span>

  <span class="nx">worker</span><span class="p">.</span><span class="nx">postMessage</span><span class="p">({</span><span class="nx">row</span><span class="o">:</span> <span class="nx">row</span><span class="p">,</span> <span class="nx">col</span><span class="o">:</span> <span class="nx">col</span><span class="p">});</span>
  <span class="nx">state</span> <span class="o">=</span> <span class="nx">WAITING</span><span class="p">;
}</span>
</pre></div>


<p>Like the other desktop versions, we want the user to be able to play the game from the keyboard. This is a little bit tricky, because not all browsers implement the <a href="https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent/key"><span class="code">KeyBoardEvent.key</span></a> property the same. For example, Internet Explorer 11 doesn't support the arrow keys or space with the code below. But I think it's good enough for a best effort approach.</p>

<div class="highlight"><pre><span></span><span class="n">function</span> <span class="nf">onKeyDown</span><span class="p">(</span><span class="n">e</span><span class="p">) {</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">!=</span> <span class="n">BLACKS_MOVE</span> <span class="o">||</span>
      <span class="n">document</span><span class="p">.</span><span class="n">activeElement</span> <span class="o">==</span> <span class="n">document</span><span class="p">.</span><span class="n">querySelector</span><span class="p">(</span><span class="s">&quot;button&quot;</span><span class="p">)) {</span>
    <span class="k">return</span><span class="p">;
  }</span>

  <span class="n">var row</span> <span class="o">=</span> <span class="n">selectedRow</span><span class="p">;</span>
  <span class="n">var col</span> <span class="o">=</span> <span class="n">selectedCol</span><span class="p">;</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">key</span><span class="p">) {</span>
  <span class="k">case</span> <span class="s">&quot; &quot;</span><span class="o">:</span>
  <span class="k">case</span> <span class="s">&quot;Enter&quot;</span><span class="o">:</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">row</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">col</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">) {</span>
      <span class="n">onCellClick</span><span class="p">(</span><span class="n">selectedRow</span><span class="p">,</span> <span class="n">selectedCol</span><span class="p">);
    }</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="k">case</span> <span class="s">&quot;ArrowRight&quot;</span><span class="o">:</span> <span class="n">col</span><span class="o">++</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="s">&quot;ArrowLeft&quot;</span><span class="o">:</span>  <span class="n">col</span><span class="o">--</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="s">&quot;ArrowDown&quot;</span><span class="o">:</span>  <span class="n">row</span><span class="o">++</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="s">&quot;ArrowUp&quot;</span><span class="o">:</span>    <span class="n">row</span><span class="o">--</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>

  <span class="k">case</span> <span class="s">&quot;a&quot;</span><span class="o">:</span> <span class="k">case</span> <span class="s">&quot;b&quot;</span><span class="o">:</span> <span class="k">case</span> <span class="s">&quot;c&quot;</span><span class="o">:</span> <span class="k">case</span> <span class="s">&quot;d&quot;</span><span class="o">:</span>
  <span class="k">case</span> <span class="s">&quot;e&quot;</span><span class="o">:</span> <span class="k">case</span> <span class="s">&quot;f&quot;</span><span class="o">:</span> <span class="k">case</span> <span class="s">&quot;g&quot;</span><span class="o">:</span> <span class="k">case</span> <span class="s">&quot;h&quot;</span><span class="o">:</span>
    <span class="n">col</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">key</span><span class="p">.</span><span class="n">charCodeAt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="s">&quot;a&quot;</span><span class="p">.</span><span class="n">charCodeAt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>

  <span class="k">case</span> <span class="s">&quot;0&quot;</span><span class="o">:</span> <span class="k">case</span> <span class="s">&quot;1&quot;</span><span class="o">:</span> <span class="k">case</span> <span class="s">&quot;2&quot;</span><span class="o">:</span> <span class="k">case</span> <span class="s">&quot;3&quot;</span><span class="o">:</span>
  <span class="k">case</span> <span class="s">&quot;4&quot;</span><span class="o">:</span> <span class="k">case</span> <span class="s">&quot;5&quot;</span><span class="o">:</span> <span class="k">case</span> <span class="s">&quot;6&quot;</span><span class="o">:</span> <span class="k">case</span> <span class="s">&quot;7&quot;</span><span class="o">:</span>
    <span class="n">row</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">key</span><span class="p">.</span><span class="n">charCodeAt</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="s">&quot;0&quot;</span><span class="p">.</span><span class="n">charCodeAt</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>

  <span class="k">default</span><span class="o">:</span>
    <span class="k">return</span><span class="p">;
  }</span>

  <span class="n">selectCell</span><span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Math</span><span class="p">.</span><span class="n">min</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="mi">7</span><span class="p">)),</span> <span class="n">Math</span><span class="p">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Math</span><span class="p">.</span><span class="n">min</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="mi">7</span><span class="p">)));
}</span>
</pre></div>


<p>When the script has loaded and defined all these functions, we call <span class="code">init()</span>:</p>

<div class="highlight"><pre><span></span><span class="nx">init</span><span class="p">();</span>
</pre></div>


<a name="web_worker"></a>
<h4>Worker Code</h4>

<p><a href="http://kripken.github.io/emscripten-site/index.html">Emscripten</a> is an open-source tool, <a href="http://syntensity.blogspot.com/2011/04/emscripten-10.html">version 1.0 released</a> in 2011 by Alon Zakai at Mozilla, which compiles C and C++ code (via LLVM IR) to JavaScript. The code it generates is a subset known as <a href="https://en.wikipedia.org/wiki/Asm.js">asm.js</a>, which means it can be run by any browser that supports JavaScript, and optimized particularly well by browsers that are aware of that subset. More recently, Emscripten can also output code in <a href="http://webassembly.org/">WebAssembly</a> (or wasm), which is an efficient bytecode representation that's starting to get support in the major browsers this year.</p>

<p>What Emscripten gives us is a <span class="code">Module</span> object with functions such as <a href="https://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html#ccall"><span class="code">ccall</span></a> which allows us to call a compiled C function from JavaScript. We construct a JavaScript class called <span class="code">Board</span> that wraps our Othello game engine by accessing it through the Emscripten <span class="code">Module</span>. In <a href="files/othello/web/web_othello_worker.js"><span class="code">web_othello_worker.js</span></a>:</p>

<div class="highlight"><pre><span></span><span class="s2">&quot;use strict&quot;</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">Module</span><span class="p">;</span>

<span class="kd">var</span> <span class="nx">SIZEOF_BOARD_T</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">SIZEOF_INT</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">PLAYER_BLACK</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">PLAYER_WHITE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">Board</span><span class="p">() {</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">ptr</span> <span class="o">=</span> <span class="nx">Module</span><span class="p">.</span><span class="nx">_malloc</span><span class="p">(</span><span class="nx">SIZEOF_BOARD_T</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">outRow</span> <span class="o">=</span> <span class="nx">Module</span><span class="p">.</span><span class="nx">_malloc</span><span class="p">(</span><span class="nx">SIZEOF_INT</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">outCol</span> <span class="o">=</span> <span class="nx">Module</span><span class="p">.</span><span class="nx">_malloc</span><span class="p">(</span><span class="nx">SIZEOF_INT</span><span class="p">);</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">init</span><span class="p">();
}</span>
<span class="nx">Board</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">init</span> <span class="o">=</span> <span class="kd">function</span><span class="p">() {</span>
  <span class="nx">Module</span><span class="p">.</span><span class="nx">ccall</span><span class="p">(</span><span class="s2">&quot;othello_init&quot;</span><span class="p">,</span> <span class="kc">null</span><span class="p">,
               [</span><span class="s2">&quot;number&quot;</span><span class="p">],
               [</span><span class="k">this</span><span class="p">.</span><span class="nx">ptr</span><span class="p">]);
};</span>
<span class="nx">Board</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">cellState</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span> <span class="nx">col</span><span class="p">) {</span>
  <span class="k">return</span> <span class="nx">Module</span><span class="p">.</span><span class="nx">ccall</span><span class="p">(</span><span class="s2">&quot;othello_cell_state&quot;</span><span class="p">,</span> <span class="s2">&quot;number&quot;</span><span class="p">,
                      [</span><span class="s2">&quot;number&quot;</span><span class="p">,</span> <span class="s2">&quot;number&quot;</span><span class="p">,</span> <span class="s2">&quot;number&quot;</span><span class="p">],
                      [</span><span class="k">this</span><span class="p">.</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">row</span><span class="p">,</span> <span class="nx">col</span><span class="p">]);
};</span>
<span class="nx">Board</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">score</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">player</span><span class="p">) {</span>
  <span class="k">return</span> <span class="nx">Module</span><span class="p">.</span><span class="nx">ccall</span><span class="p">(</span><span class="s2">&quot;othello_score&quot;</span><span class="p">,</span> <span class="s2">&quot;number&quot;</span><span class="p">,
                      [</span><span class="s2">&quot;number&quot;</span><span class="p">,</span> <span class="s2">&quot;number&quot;</span><span class="p">],
                      [</span><span class="k">this</span><span class="p">.</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">player</span><span class="p">]);
};</span>
<span class="nx">Board</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">hasValidMove</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">player</span><span class="p">) {</span>
  <span class="k">return</span> <span class="nx">Module</span><span class="p">.</span><span class="nx">ccall</span><span class="p">(</span><span class="s2">&quot;othello_has_valid_move&quot;</span><span class="p">,</span> <span class="s2">&quot;number&quot;</span><span class="p">,
                      [</span><span class="s2">&quot;number&quot;</span><span class="p">,</span> <span class="s2">&quot;number&quot;</span><span class="p">],
                      [</span><span class="k">this</span><span class="p">.</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">player</span><span class="p">]);
};</span>
<span class="nx">Board</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">isValidMove</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">player</span><span class="p">,</span> <span class="nx">row</span><span class="p">,</span> <span class="nx">col</span><span class="p">) {</span>
  <span class="k">return</span> <span class="nx">Module</span><span class="p">.</span><span class="nx">ccall</span><span class="p">(</span><span class="s2">&quot;othello_is_valid_move&quot;</span><span class="p">,</span> <span class="s2">&quot;number&quot;</span><span class="p">,
                      [</span><span class="s2">&quot;number&quot;</span><span class="p">,</span> <span class="s2">&quot;number&quot;</span><span class="p">,</span> <span class="s2">&quot;number&quot;</span><span class="p">,</span> <span class="s2">&quot;number&quot;</span><span class="p">],
                      [</span><span class="k">this</span><span class="p">.</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">player</span><span class="p">,</span> <span class="nx">row</span><span class="p">,</span> <span class="nx">col</span><span class="p">]);
};</span>
<span class="nx">Board</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">makeMove</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">player</span><span class="p">,</span> <span class="nx">row</span><span class="p">,</span> <span class="nx">col</span><span class="p">) {</span>
  <span class="nx">Module</span><span class="p">.</span><span class="nx">ccall</span><span class="p">(</span><span class="s2">&quot;othello_make_move&quot;</span><span class="p">,</span> <span class="kc">null</span><span class="p">,
               [</span><span class="s2">&quot;number&quot;</span><span class="p">,</span> <span class="s2">&quot;number&quot;</span><span class="p">,</span> <span class="s2">&quot;number&quot;</span><span class="p">,</span> <span class="s2">&quot;number&quot;</span><span class="p">],
               [</span><span class="k">this</span><span class="p">.</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">player</span><span class="p">,</span> <span class="nx">row</span><span class="p">,</span> <span class="nx">col</span><span class="p">]);
};</span>
<span class="nx">Board</span><span class="p">.</span><span class="nx">prototype</span><span class="p">.</span><span class="nx">computeMove</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">player</span><span class="p">) {</span>
  <span class="nx">Module</span><span class="p">.</span><span class="nx">ccall</span><span class="p">(</span><span class="s2">&quot;othello_compute_move&quot;</span><span class="p">,</span> <span class="kc">null</span><span class="p">,
               [</span><span class="s2">&quot;number&quot;</span><span class="p">,</span> <span class="s2">&quot;number&quot;</span><span class="p">,</span> <span class="s2">&quot;number&quot;</span><span class="p">,</span> <span class="s2">&quot;number&quot;</span><span class="p">],
               [</span><span class="k">this</span><span class="p">.</span><span class="nx">ptr</span><span class="p">,</span> <span class="nx">player</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">outRow</span><span class="p">,</span> <span class="k">this</span><span class="p">.</span><span class="nx">outCol</span><span class="p">]);</span>
  <span class="k">return</span> <span class="p">[</span><span class="nx">Module</span><span class="p">.</span><span class="nx">getValue</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">outRow</span><span class="p">,</span> <span class="s2">&quot;i32&quot;</span><span class="p">),</span>
          <span class="nx">Module</span><span class="p">.</span><span class="nx">getValue</span><span class="p">(</span><span class="k">this</span><span class="p">.</span><span class="nx">outCol</span><span class="p">,</span> <span class="s2">&quot;i32&quot;</span><span class="p">)];
};</span>
</pre></div>


<p>JavaScript uses a <a href="https://en.wikipedia.org/wiki/Prototype-based_programming">prototype-based</a> object-oriented model inspired by the <a href="https://en.wikipedia.org/wiki/Self_%28programming_language%29">Self</a> programming language. Objects have a <span class="code">prototype</span> property, which is an object that can have function properties, and potentially its own <span class="code">prototype</span> (for inheritance). When a method is invoked on an object like <span class="code">foo.bar()</span>, the JavaScript interpreter will look for a <span class="code">bar</span> method in <span class="code">foo</span>'s prototype (or its prototype, and so on).</p>

<p>To set up an object's prototype, it's common to have a designated function called a <em>constructor</em> (<span class="code">Board</span> in our case). That function is invoked with a special syntax (<span class="code">new Board()</span>) which creates a new object, sets the <span class="code">prototype</span> of that object to the prototype of the constructor, and then invokes the constructor function. That way, any object created with <span class="code">new Board()</span> will have methods <span class="code">init</span>, <span class="code">cellState</span>, and so on, as well as properties <span class="code">ptr</span>, <span class="code">outRow</span> and <span class="code">outCol</span>.</p>

<p>The web worker communicates with the main execution context in a straight-forward way. In response to "new game" or move messages, it updates the board and replies with the new game state:</p>

<div class="highlight"><pre><span></span><span class="kd">var</span> <span class="nx">BLACKS_MOVE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">WHITES_MOVE</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">GAME_OVER</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">state</span><span class="p">;</span>
<span class="kd">var</span> <span class="nx">board</span><span class="p">;</span>

<span class="kd">function</span> <span class="nx">postState</span><span class="p">() {</span>
  <span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="p">[];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">row</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="nx">row</span><span class="o">++</span><span class="p">) {</span>
    <span class="nx">arr</span><span class="p">.</span><span class="nx">push</span><span class="p">([]);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">var</span> <span class="nx">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="nx">col</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="nx">col</span><span class="o">++</span><span class="p">) {</span>
      <span class="nx">arr</span><span class="p">[</span><span class="nx">row</span><span class="p">][</span><span class="nx">col</span><span class="p">]</span> <span class="o">=</span> <span class="nx">board</span><span class="p">.</span><span class="nx">cellState</span><span class="p">(</span><span class="nx">row</span><span class="p">,</span> <span class="nx">col</span><span class="p">);
    }
  }</span>

  <span class="nx">postMessage</span><span class="p">({</span><span class="nx">state</span><span class="o">:</span> <span class="nx">state</span><span class="p">,</span>
               <span class="nx">board</span><span class="o">:</span> <span class="nx">arr</span><span class="p">,</span>
               <span class="nx">blackScore</span><span class="o">:</span> <span class="nx">board</span><span class="p">.</span><span class="nx">score</span><span class="p">(</span><span class="nx">PLAYER_BLACK</span><span class="p">),</span>
               <span class="nx">whiteScore</span><span class="o">:</span> <span class="nx">board</span><span class="p">.</span><span class="nx">score</span><span class="p">(</span><span class="nx">PLAYER_WHITE</span><span class="p">)});
}</span>

<span class="nx">onmessage</span> <span class="o">=</span> <span class="kd">function</span><span class="p">(</span><span class="nx">e</span><span class="p">) {</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">data</span> <span class="o">===</span> <span class="s2">&quot;new game&quot;</span><span class="p">) {</span>
    <span class="nx">board</span><span class="p">.</span><span class="nx">init</span><span class="p">();</span>
    <span class="nx">state</span> <span class="o">=</span> <span class="nx">BLACKS_MOVE</span><span class="p">;</span>
    <span class="nx">postState</span><span class="p">();</span>
    <span class="k">return</span><span class="p">;
  }</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">state</span> <span class="o">!=</span> <span class="nx">BLACKS_MOVE</span> <span class="o">||
      !</span><span class="nx">board</span><span class="p">.</span><span class="nx">isValidMove</span><span class="p">(</span><span class="nx">PLAYER_BLACK</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">row</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">col</span><span class="p">)) {</span>
    <span class="nx">postState</span><span class="p">();</span>
    <span class="k">return</span><span class="p">;
  }</span>

  <span class="nx">board</span><span class="p">.</span><span class="nx">makeMove</span><span class="p">(</span><span class="nx">PLAYER_BLACK</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">row</span><span class="p">,</span> <span class="nx">e</span><span class="p">.</span><span class="nx">data</span><span class="p">.</span><span class="nx">col</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">board</span><span class="p">.</span><span class="nx">hasValidMove</span><span class="p">(</span><span class="nx">PLAYER_WHITE</span><span class="p">)) {</span>
    <span class="nx">state</span> <span class="o">=</span> <span class="nx">WHITES_MOVE</span><span class="p">;</span>
    <span class="k">do</span> <span class="p">{</span>
      <span class="nx">postState</span><span class="p">();</span>
      <span class="kd">var</span> <span class="nx">move</span> <span class="o">=</span> <span class="nx">board</span><span class="p">.</span><span class="nx">computeMove</span><span class="p">(</span><span class="nx">PLAYER_WHITE</span><span class="p">);</span>
      <span class="nx">board</span><span class="p">.</span><span class="nx">makeMove</span><span class="p">(</span><span class="nx">PLAYER_WHITE</span><span class="p">,</span> <span class="nx">move</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nx">move</span><span class="p">[</span><span class="mi">1</span><span class="p">]);
    }</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="nx">board</span><span class="p">.</span><span class="nx">hasValidMove</span><span class="p">(</span><span class="nx">PLAYER_BLACK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
             <span class="nx">board</span><span class="p">.</span><span class="nx">hasValidMove</span><span class="p">(</span><span class="nx">PLAYER_WHITE</span><span class="p">));
  }</span>

  <span class="k">if</span> <span class="p">(</span><span class="nx">board</span><span class="p">.</span><span class="nx">hasValidMove</span><span class="p">(</span><span class="nx">PLAYER_BLACK</span><span class="p">)) {</span>
    <span class="nx">state</span> <span class="o">=</span> <span class="nx">BLACKS_MOVE</span><span class="p">;
  }</span> <span class="k">else</span> <span class="p">{</span>
    <span class="nx">state</span> <span class="o">=</span> <span class="nx">GAME_OVER</span><span class="p">;
  }</span>

  <span class="nx">postState</span><span class="p">();
}</span>
</pre></div>


<p>To load the module generated by Emscripten, we first try using WebAssembly, and if the browser doesn't support that we fall back to the asm.js code.</p>

<p>The Emscripten code will set up the <span class="code">Module</span> object, but we prepare it first by setting the <span class="code">postRun</span> property to a function that will get run after the module is loaded, and in the case of WebAssembly, we set the <span class="code">wasmBinary</span> property to the contents of our WebAssembly binary:</p>

<div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nx">emscriptenLoaded</span><span class="p">() {</span>
  <span class="nx">board</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">Board</span><span class="p">();</span>
  <span class="nx">postMessage</span><span class="p">(</span><span class="s2">&quot;loaded&quot;</span><span class="p">);
}</span>

<span class="kd">function</span> <span class="nx">start</span><span class="p">() {</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">WebAssembly</span><span class="p">) {</span>
    <span class="k">try</span> <span class="p">{</span>
      <span class="nx">Module</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">postRun</span><span class="o">:</span> <span class="p">[</span><span class="kd">function</span><span class="p">() {</span> <span class="nx">emscriptenLoaded</span><span class="p">(); }] };</span>
      <span class="kd">var</span> <span class="nx">xhr</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">XMLHttpRequest</span><span class="p">();</span>
      <span class="nx">xhr</span><span class="p">.</span><span class="nx">open</span><span class="p">(</span><span class="s2">&quot;GET&quot;</span><span class="p">,</span> <span class="s2">&quot;wasm_othello.wasm&quot;</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
      <span class="nx">xhr</span><span class="p">.</span><span class="nx">responseType</span> <span class="o">=</span> <span class="s2">&quot;arraybuffer&quot;</span><span class="p">;</span>
      <span class="nx">xhr</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="kc">null</span><span class="p">);</span>
      <span class="nx">Module</span><span class="p">.</span><span class="nx">wasmBinary</span> <span class="o">=</span> <span class="nx">xhr</span><span class="p">.</span><span class="nx">response</span><span class="p">;</span>
      <span class="nx">importScripts</span><span class="p">(</span><span class="s2">&quot;wasm_othello.js&quot;</span><span class="p">);</span>
      <span class="k">return</span><span class="p">;
    }</span> <span class="k">catch</span> <span class="p">(</span><span class="nx">e</span><span class="p">) {</span>
      <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">e</span><span class="p">);
    }
  }</span>

  <span class="k">try</span> <span class="p">{</span>
    <span class="nx">Module</span> <span class="o">=</span> <span class="p">{</span> <span class="nx">postRun</span><span class="o">:</span> <span class="p">[</span><span class="kd">function</span><span class="p">() {</span> <span class="nx">emscriptenLoaded</span><span class="p">(); }] };</span>
    <span class="nx">importScripts</span><span class="p">(</span><span class="s2">&quot;othello.asm.js&quot;</span><span class="p">);
  }</span> <span class="k">catch</span><span class="p">(</span><span class="nx">e</span><span class="p">) {</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">error</span><span class="p">(</span><span class="nx">e</span><span class="p">);</span>
    <span class="nx">postMessage</span><span class="p">(</span><span class="s2">&quot;error&quot;</span><span class="p">);
  }
}</span>

<span class="nx">start</span><span class="p">();</span>
</pre></div>


<a name="web_build"></a>
<h4>Building</h4>

<p>To compile the Othello engine to asm.js and wasm, we use the <a href="https://kripken.github.io/emscripten-site/docs/getting_started/downloads.html">Emscripten SDK</a>. For asm.js:</p>

<div class="highlight"><pre><span></span><span class="gp">$</span> emcc ../othello.c -O3 -DNDEBUG -o othello.asm.js <span class="se">\</span>
  -s <span class="nv">EXPORTED_FUNCTIONS</span><span class="o">=</span><span class="s2">&quot;[&#39;_othello_init&#39;, \
                          &#39;_othello_cell_state&#39;, \
                          &#39;_othello_score&#39;, \
                          &#39;_othello_has_valid_move&#39;, \
                          &#39;_othello_is_valid_move&#39;, \
                          &#39;_othello_make_move&#39;, \
                          &#39;_othello_compute_move&#39;]&quot;</span> <span class="se">\</span>
  -s <span class="nv">EXPORTED_RUNTIME_METHODS</span><span class="o">=</span><span class="s2">&quot;[&#39;_malloc&#39;,&#39;ccall&#39;,&#39;getValue&#39;]&quot;</span> <span class="se">\</span>
  -s <span class="nv">NO_FILESYSTEM</span><span class="o">=</span><span class="m">1</span> --memory-init-file <span class="m">0</span>
</pre></div>


<p>(To look at the output, build with <span class="code">-g</span> to turn off minification.)</p>

<p>And for WebAssembly:</p>

<div class="highlight"><pre><span></span><span class="gp">$</span> emcc ../othello.c -O3 -DNDEBUG -o wasm_othello.js <span class="se">\</span>
  -s <span class="nv">EXPORTED_FUNCTIONS</span><span class="o">=</span><span class="s2">&quot;[&#39;_othello_init&#39;, \
                          &#39;_othello_cell_state&#39;, \
                          &#39;_othello_score&#39;, \
                          &#39;_othello_has_valid_move&#39;, \
                          &#39;_othello_is_valid_move&#39;, \
                          &#39;_othello_make_move&#39;, \
                          &#39;_othello_compute_move&#39;]&quot;</span> <span class="se">\</span>
  -s <span class="nv">EXPORTED_RUNTIME_METHODS</span><span class="o">=</span><span class="s2">&quot;[&#39;_malloc&#39;,&#39;ccall&#39;,&#39;getValue&#39;]&quot;</span> <span class="se">\</span>
  -s <span class="nv">NO_FILESYSTEM</span><span class="o">=</span><span class="m">1</span> --memory-init-file <span class="m">0</span> <span class="se">\</span>
  -s <span class="nv">WASM</span><span class="o">=</span><span class="m">1</span> -s <span class="s2">&quot;BINARYEN_METHOD=&#39;native-wasm&#39;&quot;</span>
</pre></div>


<p>Many of the flags are not strictly necessary, but they reduce the size of the generated code, for example by explicitly listing the functions that need to be exported.</p>

<p>Try out the game at <a href="files/othello/web/web_othello.html"><span class="code">web_othello.html</span></a>!</p>

<a name="exercises"></a>
<h2>Exercises</h2>
<ul>
<li>Make the AI stronger, for example: find a better evaluation function through self-play, implement move ordering, transposition tables, look into how good Othello engines work.</li>
<li>In the user interface of your choice, show the list of moves, highlight legal moves on the board and white's last move(s).</li>
<li>Add an option to set game difficulty, modifying both the game engine and the user interface.</li>
<li>On Windows, switch from GDI to GDI+ or DirectDraw to get nicer graphics, in particular anti-aliased drawing of the disks.</li>
</ul>

<p>If you read all the way here, you're an amazing person! Bugs? Feedback? Please let me know.</p>

<blockquote style="font-size: 10pt"><p>"Chess is the intellectual game par excellence. [..] If one could devise a successful chess machine, one would seem to have penetrated to the core of human intellectual endeavour."</p>
<div style="text-align: right">
<p><i>&mdash; <a href="http://archive.org/stream/bitsavers_randiplP13amsAndTheProblemOfComplexitySep58_3372055/P-1319_Chess-Playing_Programs_And_The_Problem_Of_Complexity_Sep58#page/n1/mode/2up">Allen Newell, Cliff Shaw and Herbert Simon</a></i></p>
</div>
</blockquote>

                        </div>
                </div>
                <div id="footer">
                        Hans Wennborg |
                        <a href="https://www.hanshq.net/">www.hanshq.net</a> |
                        hans (at) hanshq.net |
                        <a href="https://twitter.com/hansw2000">@hansw2000</a> |
                        <a href="feed.rss">RSS</a>
                </div>
        </div>
</div>
</body>
</html>
